/*@!Encoding:1252*/
/**
 * @file Road_Obj_PrivateFront_Inject.can
 * @author ADAS_HIL_TEAM
 * @date 09-25-2023
 * @brief 
 *
 * ################################################################
 * C O P Y R I G H T S
 * ----------------------------------------------------------------
 * Copyright (c) 2023 by Robert Bosch GmbH. All rights reserved.
 
 * The reproduction, distribution and utilization of this file as
 * well as the communication of its contents to others without express
 * authorization is prohibited. Offenders will be held liable for the
 * payment of damages. All rights reserved in the event of the grant
 * of a patent, utility model or design.
 *
 * ################################################################
*/

includes
{
  #include "Inject_Radar_FC.cin"
  #include "Inject_Radar_FL.cin"
  #include "Inject_Radar_FR.cin"
  #include "Inject_Radar_RL.cin"
  #include "Inject_Radar_RR.cin"
}

variables
{
  msTimer validity_timer_RFR, validity_timer_RFL, validity_timer_RFC, validity_timer_RRR, validity_timer_RRL;
  int radar_fl_deletion_needed[10] = {0,0,0,0,0,0,0,0,0,0};
  int radar_fr_deletion_needed[10] = {0,0,0,0,0,0,0,0,0,0};
  int radar_fc_deletion_needed[10] = {0,0,0,0,0,0,0,0,0,0};
  int radar_rl_deletion_needed[10] = {0,0,0,0,0,0,0,0,0,0};
  int radar_rr_deletion_needed[10] = {0,0,0,0,0,0,0,0,0,0};
  int front_corner_cycle_time = 100;
}

on start
{

}

/** @brief Starts or Stops sending of RFL and RFR messages depending on the chosen hil mode.
  * @return void
  */
on sysvar hil_ctrl::hil_mode
{
  if (@this != 1)
  {
  /**
  * Start validity timers
  */
  setTimerCyclic(validity_timer_RFC,front_corner_cycle_time);
  setTimerCyclic(validity_timer_RFL,front_corner_cycle_time);
  setTimerCyclic(validity_timer_RFR,front_corner_cycle_time); 
  setTimerCyclic(validity_timer_RRL,front_corner_cycle_time);
  setTimerCyclic(validity_timer_RRR,front_corner_cycle_time); 
  }
  else
  {
    cancelTimer(validity_timer_RFC);
    cancelTimer(validity_timer_RFL);
    cancelTimer(validity_timer_RFR); 
    cancelTimer(validity_timer_RRL);
    cancelTimer(validity_timer_RRR); 
  }
}

/** @brief Sending of RFC messages depending on the chosen sensor mode, hil mode and previously set validity flags.
  * @return void
  */
on timer validity_timer_RFC
{ 
  int object_counter=0;

  inject_radar_fc_hdr();
//  for(object_counter = 0; object_counter <= 9; object_counter++){
//    if(@hil_ctrl::ra6_fc_sgu_obj_sim > 0 && (@Classe_Obj_Sim::ValidityFlags.validityFlag_FC[object_counter] == 1 || radar_fc_deletion_needed[object_counter] == 1)){
//      if(@target_radar_fc_sim::objdata.empty_obj[object_counter] == 1 && radar_fc_deletion_needed[object_counter] == 1)
//      {
//        if(@hil_ctrl::ra6_fc_sgu_obj_sim == 1){
//          delete_radar_fc_bus_obj(object_counter);
//        }else if(@hil_ctrl::ra6_fc_sgu_obj_sim == 2){
////          obj_sim_delete_fradar_xcp(object_counter);
//        }
//        radar_fc_deletion_needed[object_counter] = 0;
//      }
//      else if(@target_radar_fc_sim::objdata.empty_obj[object_counter] == 0)
//      {
//        radar_fc_deletion_needed[object_counter] = 1;
//      }
//      inject_radar_fc_obj(object_counter,@hil_ctrl::ra6_fc_sgu_obj_sim);
//    }
//  }
  
  /**
    * Sending only the valid messages and only if VehicleModel is in Classe, CM or FDX mode
    * Currently no validity sending is used due to CAN TP -> everything is being sent by this one ON_OFF Flag not depending on the chosen mode
    */
  if(@hil_ctrl::ra6_fc_sgu_obj_sim == 1)
  {
    @CAN_RadarFC::RFC_Object::RFC_Object_ON_OFF = 1;
  }
  else
  {
    @CAN_RadarFC::RFC_Object::RFC_Object_ON_OFF = 0; 
  }
  
  /**
    * Setting the radar movement mode for the next cycle
    */
  if(@hil_ctrl::cm_driving_parking_mode == @hil_ctrl::cm_driving_parking_mode::CM_Driving)
  { // Set the radar mode to driving
    @hil_ctrl::radar_fc_type_req = 0;
  }
  else if(@hil_ctrl::cm_driving_parking_mode == @hil_ctrl::cm_driving_parking_mode::CM_Parking)
  { // Set the radar mode to parking
    @hil_ctrl::radar_fc_type_req = 1;
  }
  else if(@hil_ctrl::cm_driving_parking_mode == @hil_ctrl::cm_driving_parking_mode::CM_Alternating)
  { // Set the radar mode to alternate between driving and parking
    @hil_ctrl::radar_fc_type_req = 1 - @hil_ctrl::radar_fc_type_req;
  }
}

/** @brief Sending of RFL messages depending on the chosen sensor mode, hil mode and previously set validity flags.
  * @return void
  */
on timer validity_timer_RFL
{ 
  int object_counter=0;

  inject_radar_fl_hdr();
//  for(object_counter = 0; object_counter <= 9; object_counter++){
//    if(@hil_ctrl::ra6_fl_sgu_obj_sim > 0 && (@Classe_Obj_Sim::ValidityFlags.validityFlag_RFL[object_counter] == 1 || radar_fl_deletion_needed[object_counter] == 1)){
//      if(@target_radar_fl_sim::objdata.empty_obj[object_counter] == 1 && radar_fl_deletion_needed[object_counter] == 1)
//      {
//        if(@hil_ctrl::ra6_fl_sgu_obj_sim == 1){
//          delete_radar_fl_bus(object_counter);
//        }else if(@hil_ctrl::ra6_fl_sgu_obj_sim == 2){
////          obj_sim_delete_fradar_xcp(object_counter);
//        }
//        radar_fl_deletion_needed[object_counter] = 0;
//      }
//      else if(@target_radar_fl_sim::objdata.empty_obj[object_counter] == 0)
//      {
//        radar_fl_deletion_needed[object_counter] = 1;
//      }
//      inject_radar_fl_obj(object_counter,@hil_ctrl::ra6_fl_sgu_obj_sim);
//    }
//  }
  
  /**
    * Sending only the valid messages and only if VehicleModel is in Classe, CM or FDX mode
    * Currently no validity sending is used due to CAN TP -> everything is being sent by this one ON_OFF Flag not depending on the chosen mode
    */
  if(@hil_ctrl::ra6_fl_sgu_obj_sim == 1)
  {
    @CAN_RadarFL::RFL_Object::RFL_Object_ON_OFF = 1;
  }
  else
  {
    @CAN_RadarFL::RFL_Object::RFL_Object_ON_OFF = 0; 
  }
  
  /**
    * Setting the radar movement mode for the next cycle
    */
  if(@hil_ctrl::cm_driving_parking_mode == @hil_ctrl::cm_driving_parking_mode::CM_Driving)
  { // Set the radar mode to driving
    @hil_ctrl::radar_fl_type_req = 0;
  }
  else if(@hil_ctrl::cm_driving_parking_mode == @hil_ctrl::cm_driving_parking_mode::CM_Parking)
  { // Set the radar mode to parking
    @hil_ctrl::radar_fl_type_req = 1;
  }
  else if(@hil_ctrl::cm_driving_parking_mode == @hil_ctrl::cm_driving_parking_mode::CM_Alternating)
  { // Set the radar mode to alternate between driving and parking
    @hil_ctrl::radar_fl_type_req = 1 - @hil_ctrl::radar_fl_type_req;
  }
}

/** @brief Sending of RFR messages depending on the chosen sensor mode, hil mode and previously set validity flags.
  * @return void
  */
on timer validity_timer_RFR
{
  int object_counter=0;

  inject_radar_fr_hdr();
//  for(object_counter = 0; object_counter <= 9; object_counter++){
//    if(@hil_ctrl::ra6_fr_sgu_obj_sim > 0 && (@Classe_Obj_Sim::ValidityFlags.validityFlag_RFR[object_counter] == 1 || radar_fr_deletion_needed[object_counter] == 1)){
//      if(@target_radar_fr_sim::objdata.empty_obj[object_counter] == 1 && radar_fr_deletion_needed[object_counter] == 1)
//      {
//        if(@hil_ctrl::ra6_fr_sgu_obj_sim == 1){
//          delete_radar_fr_bus(object_counter);
//        }else if(@hil_ctrl::ra6_fr_sgu_obj_sim == 2){
////          obj_sim_delete_fradar_xcp(object_counter);
//        }
//        radar_fr_deletion_needed[object_counter] = 0;
//      }
//      else if(@target_radar_fr_sim::objdata.empty_obj[object_counter] == 0)
//      {
//        radar_fr_deletion_needed[object_counter] = 1;
//      }
//      inject_radar_fr_obj(object_counter,@hil_ctrl::ra6_fr_sgu_obj_sim);
//    }
//  }
  
  /**
    * Sending only the valid messages and only if VehicleModel is in Classe, CM or FDX mode
    * Currently no validity sending is used due to CAN TP -> everything is being sent by this one ON_OFF Flag not depending on the chosen mode
    */
  if(@hil_ctrl::ra6_fr_sgu_obj_sim == 1)
  {
    @CAN_RadarFR::RFR_Object::RFR_Object_ON_OFF = 1;
  }
  else
  {
    @CAN_RadarFR::RFR_Object::RFR_Object_ON_OFF = 0;
  } 
  
  /**
    * Setting the radar movement mode for the next cycle
    */
  if(@hil_ctrl::cm_driving_parking_mode == @hil_ctrl::cm_driving_parking_mode::CM_Driving)
  { // Set the radar mode to driving
    @hil_ctrl::radar_fr_type_req = 0;
  }
  else if(@hil_ctrl::cm_driving_parking_mode == @hil_ctrl::cm_driving_parking_mode::CM_Parking)
  { // Set the radar mode to parking
    @hil_ctrl::radar_fr_type_req = 1;
  }
  else if(@hil_ctrl::cm_driving_parking_mode == @hil_ctrl::cm_driving_parking_mode::CM_Alternating)
  { // Set the radar mode to alternate between driving and parking
    @hil_ctrl::radar_fr_type_req = 1 - @hil_ctrl::radar_fr_type_req;
  }
}

/** @brief Sending of RRL messages depending on the chosen sensor mode, hil mode and previously set validity flags.
  * @return void
  */
on timer validity_timer_RRL
{ 
  int object_counter=0;

  inject_radar_rl_hdr();
//  for(object_counter = 0; object_counter <= 9; object_counter++){
//    if(@hil_ctrl::ra6_rl_sgu_obj_sim > 0 && (@Classe_Obj_Sim::ValidityFlags.validityFlag_RRL[object_counter] == 1 || radar_rl_deletion_needed[object_counter] == 1)){
//      if(@target_radar_rl_sim::objdata.empty_obj[object_counter] == 1 && radar_rl_deletion_needed[object_counter] == 1)
//      {
//        if(@hil_ctrl::ra6_rl_sgu_obj_sim == 1){
//          delete_radar_rl_bus(object_counter);
//        }else if(@hil_ctrl::ra6_rl_sgu_obj_sim == 2){
////          obj_sim_delete_fradar_xcp(object_counter);
//        }
//        radar_rl_deletion_needed[object_counter] = 0;
//      }
//      else if(@target_radar_rl_sim::objdata.empty_obj[object_counter] == 0)
//      {
//        radar_rl_deletion_needed[object_counter] = 1;
//      }
//      inject_radar_rl_obj(object_counter,@hil_ctrl::ra6_rl_sgu_obj_sim);
//    }
//  }
  
  /**
    * Sending only the valid messages and only if VehicleModel is in Classe, CM or FDX mode
    * Currently no validity sending is used due to CAN TP -> everything is being sent by this one ON_OFF Flag not depending on the chosen mode
    */
  if(@hil_ctrl::ra6_rl_sgu_obj_sim == 1)
  {
    @CAN_RadarRL::RRL_Object::RRL_Object_ON_OFF = 1;
  }
  else
  {
    @CAN_RadarRL::RRL_Object::RRL_Object_ON_OFF = 0; 
  }
  
  /**
    * Setting the radar movement mode for the next cycle
    */
  if(@hil_ctrl::cm_driving_parking_mode == @hil_ctrl::cm_driving_parking_mode::CM_Driving)
  { // Set the radar mode to driving
    @hil_ctrl::radar_rl_type_req = 0;
  }
  else if(@hil_ctrl::cm_driving_parking_mode == @hil_ctrl::cm_driving_parking_mode::CM_Parking)
  { // Set the radar mode to parking
    @hil_ctrl::radar_rl_type_req = 1;
  }
  else if(@hil_ctrl::cm_driving_parking_mode == @hil_ctrl::cm_driving_parking_mode::CM_Alternating)
  { // Set the radar mode to alternate between driving and parking
    @hil_ctrl::radar_rl_type_req = 1 - @hil_ctrl::radar_rl_type_req;
  }
}

/** @brief Sending of RRR messages depending on the chosen sensor mode, hil mode and previously set validity flags.
  * @return void
  */
on timer validity_timer_RRR
{ 
  int object_counter=0;

  inject_radar_rr_hdr();
//  for(object_counter = 0; object_counter <= 9; object_counter++){
//    if(@hil_ctrl::ra6_rr_sgu_obj_sim > 0 && (@Classe_Obj_Sim::ValidityFlags.validityFlag_RRR[object_counter] == 1 || radar_rr_deletion_needed[object_counter] == 1)){
//      if(@target_radar_rr_sim::objdata.empty_obj[object_counter] == 1 && radar_rr_deletion_needed[object_counter] == 1)
//      {
//        if(@hil_ctrl::ra6_rr_sgu_obj_sim == 1){
//          delete_radar_rr_bus(object_counter);
//        }else if(@hil_ctrl::ra6_rr_sgu_obj_sim == 2){
////          obj_sim_delete_fradar_xcp(object_counter);
//        }
//        radar_rr_deletion_needed[object_counter] = 0;
//      }
//      else if(@target_radar_rr_sim::objdata.empty_obj[object_counter] == 0)
//      {
//        radar_rr_deletion_needed[object_counter] = 1;
//      }
//      inject_radar_rr_obj(object_counter,@hil_ctrl::ra6_rr_sgu_obj_sim);
//    }
//  }
  
  /**
    * Sending only the valid messages and only if VehicleModel is in Classe, CM or FDX mode
    * Currently no validity sending is used due to CAN TP -> everything is being sent by this one ON_OFF Flag not depending on the chosen mode
    */
  if(@hil_ctrl::ra6_rr_sgu_obj_sim == 1)
  {
    @CAN_RadarRR::RRR_Object::RRR_Object_ON_OFF = 1;
  }
  else
  {
    @CAN_RadarRR::RRR_Object::RRR_Object_ON_OFF = 0; 
  }
  
  /**
    * Setting the radar movement mode for the next cycle
    */
  if(@hil_ctrl::cm_driving_parking_mode == @hil_ctrl::cm_driving_parking_mode::CM_Driving)
  { // Set the radar mode to driving
    @hil_ctrl::radar_rr_type_req = 0;
  }
  else if(@hil_ctrl::cm_driving_parking_mode == @hil_ctrl::cm_driving_parking_mode::CM_Parking)
  { // Set the radar mode to parking
    @hil_ctrl::radar_rr_type_req = 1;
  }
  else if(@hil_ctrl::cm_driving_parking_mode == @hil_ctrl::cm_driving_parking_mode::CM_Alternating)
  { // Set the radar mode to alternate between driving and parking
    @hil_ctrl::radar_rr_type_req = 1 - @hil_ctrl::radar_rr_type_req;
  }
}