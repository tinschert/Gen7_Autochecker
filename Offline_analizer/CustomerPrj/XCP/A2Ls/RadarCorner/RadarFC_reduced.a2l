/* generated by ASAP2 Studio 2.2.52.10934 */

ASAP2_VERSION 1 71
/begin PROJECT GHS_PPC5674K ""

  /begin MODULE CPP ""

    /begin A2ML
      block "IF_DATA" taggedunion if_data {
        "CANAPE_EXT" struct {
          int;  /* version number */
          taggedstruct {
            "LINK_MAP" struct {
              char[256];  /* segment name */
              long;  /* base address of the segment */
              uint;  /* address extension of the segment */
              uint;  /* flag: address is relative to DS */
              long;  /* offset of the segment address */
              uint;  /* datatypValid */
              uint;  /* enum datatyp */
              uint;  /* bit offset of the segment */
            };
            "DISPLAY" struct {
              long;  /* display color */
              double;  /* minimal display value (phys)*/
              double;  /* maximal display value (phys)*/
            };
            "VIRTUAL_CONVERSION" struct {
              char[256];  /* name of the conversion formula */
            };
          };
        };
        "CANAPE_MODULE" struct {
          taggedstruct {
            ("RECORD_LAYOUT_STEPSIZE" struct {
              char[256];  /* name of record layout*/
              uint;  /* stepsize for FNC_VALUES */
              uint;  /* stepsize for AXIS_PTS_X */
              uint;  /* stepsize for AXIS_PTS_Y */
              uint;  /* stepsize for AXIS_PTS_Z */
              uint;  /* stepsize for AXIS_PTS_4 */
              uint;  /* stepsize for AXIS_PTS_5 */
            })*;
          };
        };
        "CANAPE_ADDRESS_UPDATE" taggedstruct {
          ("EPK_ADDRESS" struct {
            char[1024];  /* name of the corresponding symbol in MAP file */
            long;  /* optional address offset */
          })*;
          "ECU_CALIBRATION_OFFSET" struct {
            char[1024];  /* name of the corresponding symbol in MAP file */
            long;  /* optional address offset */
          };
          (block "CALIBRATION_METHOD" taggedunion {
            "AUTOSAR_SINGLE_POINTERED" struct {
              char[1024];  /* MAP symbol name for pointer table in RAM */
              long;  /* optional address offset */
              taggedstruct {
                "ORIGINAL_POINTER_TABLE" struct {
                  char[1024];  /* MAP symbol name for pointer table in FLASH */
                  long;  /* optional address offset */
                };
              };
            };
            "InCircuit2" struct {
              char[1024];  /* MAP symbol name for pointer table in RAM */
              long;  /* optional address offset */
              taggedstruct {
                "ORIGINAL_POINTER_TABLE" struct {
                  char[1024];  /* MAP symbol name for pointer table in FLASH */
                  long;  /* optional address offset */
                };
                "FLASH_SECTION" struct {
                  ulong;  /* start address of flash section */
                  ulong;  /* length of flash section */
                };
              };
            };
          })*;
          block "MAP_SYMBOL" taggedstruct {
            "FIRST" struct {
              char[1024];  /* symbol name of the corresponding segment in MAP file */
              long;  /* offset */
            };
            "LAST" struct {
              char[1024];  /* symbol name of the corresponding segment in MAP file */
              long;  /* offset */
            };
            ("ADDRESS_MAPPING_XCP" struct {
              char[1024];  /* symbol name of source range in MAP file */
              char[1024];  /* symbol name of destination range in MAP file */
            })*;
          };
          (block "MEMORY_SEGMENT" struct {
            char[1024];  /* name of the memory segment */
            taggedstruct {
              "FIRST" struct {
                char[1024];  /* symbol name of the corresponding segment in MAP file */
                long;  /* offset */
              };
              "LAST" struct {
                char[1024];  /* symbol name of the corresponding segment in MAP file */
                long;  /* offset */
              };
              ("ADDRESS_MAPPING_XCP" struct {
                char[1024];  /* symbol name of source range in MAP file */
                char[1024];  /* symbol name of destination range in MAP file */
              })*;
            };
          })*;
        };
        "CANAPE_GROUP" taggedstruct {
          block "STRUCTURE_LIST" (char[1024])*;
        };
        "XCP" struct {
          taggedstruct Common_Parameters {
            block "PROTOCOL_LAYER" struct Protocol_Layer {
              uint;  /* XCP protocol layer version, current 0x100*/
              uint;  /* T1 [ms] Time-out of the standard CTO, for example CONNECT*/
              uint;  /* T2 [ms] Time-out of the checksum calculation*/
              uint;  /* T3 [ms] Time-out of the non-volatile memory programming: PROGRAM_START, PROGRAM_VERIFY, PROGRAM_PREPARE*/
              uint;  /* T4 [ms] Time-out of the non-volatile memory programming: PROGRAM_CLEAR*/
              uint;  /* T5 [ms] Time-out of the non-volatile memory programming: PROGRAM, PROGRAM_RESET, PROGRAM_MAX*/
              uint;  /* T6 [ms] Time-out of the command CONNECT(USER_DEFINED)*/
              uint;  /* T7 [ms] Time-out of the pre-action*/
              uchar;  /* MAX_CTO: Indicates the maximum length of a CTO packet in bytes. */
              uint;  /* MAX_DTO: Indicates the maximum length of a DTO packet in bytes. */
              enum {
                "BYTE_ORDER_MSB_LAST" = 0,
                "BYTE_ORDER_MSB_FIRST" = 1
              };  /* BYTE_ORDER: BYTE_ORDER_MSB_LAST = Intel, BYTE_ORDER_MSB_FIRST = Motorola*/
              enum {
                "ADDRESS_GRANULARITY_BYTE" = 1,
                "ADDRESS_GRANULARITY_WORD" = 2,
                "ADDRESS_GRANULARITY_DWORD" = 4
              };  /*The address granularity indicates the size of an element contained at a single address.*/
              taggedstruct {
                ("OPTIONAL_CMD" enum {
                  "GET_COMM_MODE_INFO" = 251,
                  "GET_ID" = 250,
                  "SET_REQUEST" = 249,
                  "GET_SEED" = 248,
                  "UNLOCK" = 247,
                  "SET_MTA" = 246,
                  "UPLOAD" = 245,
                  "SHORT_UPLOAD" = 244,
                  "BUILD_CHECKSUM" = 243,
                  "TRANSPORT_LAYER_CMD" = 242,
                  "USER_CMD" = 241,
                  "DOWNLOAD" = 240,
                  "DOWNLOAD_NEXT" = 239,
                  "DOWNLOAD_MAX" = 238,
                  "SHORT_DOWNLOAD" = 237,
                  "MODIFY_BITS" = 236,
                  "SET_CAL_PAGE" = 235,
                  "GET_CAL_PAGE" = 234,
                  "GET_PAG_PROCESSOR_INFO" = 233,
                  "GET_SEGMENT_INFO" = 232,
                  "GET_PAGE_INFO" = 231,
                  "SET_SEGMENT_MODE" = 230,
                  "GET_SEGMENT_MODE" = 229,
                  "COPY_CAL_PAGE" = 228,
                  "CLEAR_DAQ_LIST" = 227,
                  "SET_DAQ_PTR" = 226,
                  "WRITE_DAQ" = 225,
                  "SET_DAQ_LIST_MODE" = 224,
                  "GET_DAQ_LIST_MODE" = 223,
                  "START_STOP_DAQ_LIST" = 222,
                  "START_STOP_SYNCH" = 221,
                  "GET_DAQ_CLOCK" = 220,
                  "READ_DAQ" = 219,
                  "GET_DAQ_PROCESSOR_INFO" = 218,
                  "GET_DAQ_RESOLUTION_INFO" = 217,
                  "GET_DAQ_LIST_INFO" = 216,
                  "GET_DAQ_EVENT_INFO" = 215,
                  "FREE_DAQ" = 214,
                  "ALLOC_DAQ" = 213,
                  "ALLOC_ODT" = 212,
                  "ALLOC_ODT_ENTRY" = 211,
                  "PROGRAM_START" = 210,
                  "PROGRAM_CLEAR" = 209,
                  "PROGRAM" = 208,
                  "PROGRAM_RESET" = 207,
                  "GET_PGM_PROCESSOR_INFO" = 206,
                  "GET_SECTOR_INFO" = 205,
                  "PROGRAM_PREPARE" = 204,
                  "PROGRAM_FORMAT" = 203,
                  "PROGRAM_NEXT" = 202,
                  "PROGRAM_MAX" = 201,
                  "PROGRAM_VERIFY" = 200
                })*;  /* XCP-Code of optional command supported by the slave*/
                "COMMUNICATION_MODE_SUPPORTED" taggedunion {
                  "BLOCK" taggedstruct {
                    "SLAVE" ;
                    "MASTER" struct {
                      uchar;  /* MAX_BS: Indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                      uchar;  /* MIN_ST: Indicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                    };
                  };
                  "INTERLEAVED" uchar;  /* QUEUE_SIZE: indicates the maximum number of consecutive command packets the master can send to the receipt queue of the slave*/
                };
                "SEED_AND_KEY_EXTERNAL_FUNCTION" char[256];  /* Name of the Seed&Key function*/
              };
            };
            block "SEGMENT" struct Segment {
              uchar;  /* SEGMENT_NUMBER: Logical data segment number*/
              uchar;  /* Total number of available pages */
              uchar;  /* ADDRESS_EXTENSION: Address extension for this SEGMENT*/
              uchar;  /* COMPRESSION_METHOD: The COMPRESSION_x flags indicate which compression state of the incoming data the slave can process*/
              uchar;  /* ENCRYPTION_METHOD: The  ENCRYPTION_x flags indicate which encryption state of the incoming data the slave can process.*/
              taggedstruct {
                block "CHECKSUM" struct {
                  enum {
                    "XCP_ADD_11" = 1,
                    "XCP_ADD_12" = 2,
                    "XCP_ADD_14" = 3,
                    "XCP_ADD_22" = 4,
                    "XCP_ADD_24" = 5,
                    "XCP_ADD_44" = 6,
                    "XCP_CRC_16" = 7,
                    "XCP_CRC_16_CITT" = 8,
                    "XCP_CRC_32" = 9,
                    "XCP_USER_DEFINED" = 255
                  };  /* Checksum type*/
                  taggedstruct {
                    "MAX_BLOCK_SIZE" ulong;  /* Maximum block size for checksum calculation */
                    "EXTERNAL_FUNCTION" char[256];  /* Name of the Checksum.DLL */
                  };
                };
                (block "PAGE" struct {
                  uchar;  /* PAGE_NUMBER: Logical page number*/
                  enum {
                    "ECU_ACCESS_NOT_ALLOWED" = 0,
                    "ECU_ACCESS_WITHOUT_XCP_ONLY" = 1,
                    "ECU_ACCESS_WITH_XCP_ONLY" = 2,
                    "ECU_ACCESS_DONT_CARE" = 3
                  };  /*The ECU_ACCESS_x  flags indicate whether and how the ECU can access this page.*/
                  enum {
                    "XCP_READ_ACCESS_NOT_ALLOWED" = 0,
                    "XCP_READ_ACCESS_WITHOUT_ECU_ONLY" = 1,
                    "XCP_READ_ACCESS_WITH_ECU_ONLY" = 2,
                    "XCP_READ_ACCESS_DONT_CARE" = 3
                  };  /*The XCP_x_ACCESS_y flags indicate whether and how the XCP master can access this page.*/
                  enum {
                    "XCP_WRITE_ACCESS_NOT_ALLOWED" = 0,
                    "XCP_WRITE_ACCESS_WITHOUT_ECU_ONLY" = 1,
                    "XCP_WRITE_ACCESS_WITH_ECU_ONLY" = 2,
                    "XCP_WRITE_ACCESS_DONT_CARE" = 3
                  };  /*The XCP_WRITE_ACCESS_x flags indicate whether the  X CP master can write to this PAGE*/
                  taggedstruct {
                    "INIT_SEGMENT" uchar;  /* references segment that initialises this page */
                  };
                })*;  /* PAGES for this SEGMENT */
                (block "ADDRESS_MAPPING" struct {
                  ulong;  /* source address */
                  ulong;  /* destination address */
                  ulong;  /* length */
                })*;
                "PGM_VERIFY" ulong;  /* verification value for PGM */
              };
            };
            block "DAQ" struct Daq {
              enum {
                "STATIC" = 0,
                "DYNAMIC" = 1
              };  /*The flag indicates whether the DAQ lists that are not PREDEFINED shall be configured statically or dynamically*/
              uint;  /* MAX_DAQ: Total number of available DAQ lists */
              uint;  /* MAX_EVENT_CHANNEL: Total number of available event channels*/
              uchar;  /* MIN_DAQ: Total number of predefined DAQ lists */
              enum {
                "OPTIMISATION_TYPE_DEFAULT" = 0,
                "OPTIMISATION_TYPE_ODT_TYPE_16" = 1,
                "OPTIMISATION_TYPE_ODT_TYPE_32" = 2,
                "OPTIMISATION_TYPE_ODT_TYPE_64" = 3,
                "OPTIMISATION_TYPE_ODT_TYPE_ALIGNMENT" = 4,
                "OPTIMISATION_TYPE_MAX_ENTRY_SIZE" = 5
              };  /* Indicate the Type of Optimisation Method the master preferably should use.*/
              enum {
                "ADDRESS_EXTENSION_FREE" = 0,
                "ADDRESS_EXTENSION_ODT" = 1,
                "ADDRESS_EXTENSION_DAQ" = 3
              };  /*The flag indicates whether the address extension of all entries within one ODT or within one DAQ must be the same. */
              enum {
                "IDENTIFICATION_FIELD_TYPE_ABSOLUTE" = 0,
                "IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE" = 1,
                "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD" = 2,
                "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED" = 3
              };  /* The type of Identification Field the slave will use when transferring DAQ Packets to the master*/
              enum {
                "GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE" = 1,
                "GRANULARITY_ODT_ENTRY_SIZE_DAQ_WORD" = 2,
                "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DWORD" = 4,
                "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DLONG" = 8
              };  /* Granularity for size of ODT entry */
              uchar;  /* MAX_ODT_ENTRY_SIZE_DAQ Maximum size of ODT entry (DIRECTION = DAQ) */
              enum {
                "NO_OVERLOAD_INDICATION" = 0,
                "OVERLOAD_INDICATION_PID" = 1,
                "OVERLOAD_INDICATION_EVENT" = 2
              };  /*OVERLOAD_INDICATION_PID: This means the higest bit is set in the PID, when an overload occurs
OVERLOAD_INDICATION_EVENT: This means an event is set, when an overload occurs*/
              taggedstruct {
                "PRESCALER_SUPPORTED" ;  /*This flag indicates that all DAQ lists support the prescaler for reducing the transmission period.*/
                "RESUME_SUPPORTED" ;  /*This  flag indicates that all DAQ lists can be put in RESUME mode. */
                block "STIM" struct {
                  enum {
                    "GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE" = 1,
                    "GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD" = 2,
                    "GRANULARITY_ODT_ENTRY_SIZE_STIM_DWORD" = 4,
                    "GRANULARITY_ODT_ENTRY_SIZE_STIM_DLONG" = 8
                  };  /* Granularity for size of ODT entry direction STIM*/
                  uchar;  /* MAX_ODT_ENTRY_SIZE_STIM Maximum size of ODT entry (DIRECTION = STIM)*/
                  taggedstruct {
                    "BIT_STIM_SUPPORTED" ;  /*The flag indicates  whether  bitwise  data  stimulation  through BIT_OFFSET in WRITE_DAQ is supported.*/
                  };
                };
                block "TIMESTAMP_SUPPORTED" struct {
                  uint;  /*The timestamp will increment by TIMESTAMP_TICKS per unit and wrap around if an overflow occurs. */
                  enum {
                    "NO_TIME_STAMP" = 0,
                    "SIZE_BYTE" = 1,
                    "SIZE_WORD" = 2,
                    "SIZE_DWORD" = 4
                  };  /*Timestamp size in bytes*/
                  enum {
                    "UNIT_1NS" = 0,
                    "UNIT_10NS" = 1,
                    "UNIT_100NS" = 2,
                    "UNIT_1US" = 3,
                    "UNIT_10US" = 4,
                    "UNIT_100US" = 5,
                    "UNIT_1MS" = 6,
                    "UNIT_10MS" = 7,
                    "UNIT_100MS" = 8,
                    "UNIT_1S" = 9
                  };  /*Ticks per unit*/
                  taggedstruct {
                    "TIMESTAMP_FIXED" ;
                  };  /* TIMESTAMP_FIXED flag indicates that the Slave always will send DTO Packets in time stamped mode. */
                };
                "PID_OFF_SUPPORTED" ;  /*Flag in DAQ_PROPERTIES indicates that transfer of DTO Packets without Identification Field is possible. */
                (block "DAQ_LIST" struct {
                  uint;  /* DAQ_LIST_NUMBER  is in the range [0,1,..MIN_DAQ-1]. */
                  taggedstruct {
                    "DAQ_LIST_TYPE" enum {
                      "DAQ" = 1,
                      "STIM" = 2,
                      "DAQ_STIM" = 3
                    };  /* DAQ: DIRECTION = DAQ only 
 STIM: DIRECTION = STIM only 
 DAQ_STIM: both directions are possible */
                    "MAX_ODT" uchar;  /*Number of ODTs in this DAQ list */
                    "MAX_ODT_ENTRIES" uchar;  /*Maximum number of entries in an ODT*/
                    "FIRST_PID" uchar;  /*FIRST_PID: Is the PID in the DTO Packet of the first ODT transferred by this DAQ list.*/
                    "EVENT_FIXED" uint;  /*The flag indicates that the Event Channel for this DAQ list can not be changed. */
                    block "PREDEFINED" taggedstruct {
                      (block "ODT" struct {
                        uchar;  /* ODT number */
                        taggedstruct {
                          ("ODT_ENTRY" struct {
                            uchar;  /* ODT_ENTRY number */
                            ulong;  /* address of element */
                            uchar;  /* address extension of element */
                            uchar;  /* size of element [AG] */
                            uchar;  /* BIT_OFFSET */
                          })*;
                        };
                      })*;
                    };  /*PREDEFINED;The DAQ list is predefined and fixed in the slave devices memory.*/
                  };
                })*;
                (block "EVENT" struct {
                  char[101];  /* EVENT_CHANNEL_NAME */
                  char[9];  /* EVENT_CHANNEL_SHORT_NAME */
                  uint;  /* EVENT_CHANNEL_NUMBER*/
                  enum {
                    "DAQ" = 1,
                    "STIM" = 2,
                    "DAQ_STIM" = 3
                  };  /* DAQ: only DAQ_LISTs with DIRECTION = DAQ 
 STIM: only DAQ_LISTs with DIRECTION = STIM 
 DAQ_STIM both kind of DAQ_LISTs*/
                  uchar;  /* MAX_DAQ_LIST:Maximum number of DAQ lists in this event channel */
                  uchar;  /* TIME_CYCLE: Event channel time cycle */
                  uchar;  /* TIME_UNIT: Event channel time unit*/
                  uchar;  /* PRIORITY:The event channel with event channel priority = FF has the highest priority */
                })*;
              };
            };
            block "PAG" struct Pag {
              uchar;  /* MAX_SEGMENTS: Is the total number of segments in the slave device*/
              taggedstruct {
                "FREEZE_SUPPORTED" ;  /*This flag indicates that all SEGMENTS can be put in FREEZE */
              };
            };
            block "PGM" struct Pgm {
              enum {
                "PGM_MODE_ABSOLUTE" = 1,
                "PGM_MODE_FUNCTIONAL" = 2,
                "PGM_MODE_ABSOLUTE_AND_FUNCTIONAL" = 3
              };  /*The  ABSOLUTE_MODE  and  FUNCTIONAL_MODE  flags  indicate  the  clear/programming mode that can be used */
              uchar;  /* MAX_SECTORS: Total number of available sectors */
              uchar;  /* MAX_CTO_PGM: Maximum CTO size for PGM */
              taggedstruct {
                (block "SECTOR" struct {
                  char[101];  /* SECTOR_NAME */
                  uchar;  /* SECTOR_NUMBER*/
                  ulong;  /* Start address for this SECTOR */
                  ulong;  /* Length of this SECTOR [AG] */
                  uchar;  /* CLEAR_SEQUENCE_NUMBER: The Clear Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
                  uchar;  /* PROGRAM_SEQUENCE_NUMBER: The Program Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
                  uchar;  /* PROGRAM_METHOD: The work flow depends on mode  absolute access or functional access*/
                })*;
                "COMMUNICATION_MODE_SUPPORTED" taggedunion {
                  "BLOCK" taggedstruct {
                    "SLAVE" ;  /*This flag indicates whether the Slave Block Mode is available during Programming. */
                    "MASTER" struct {
                      uchar;  /* MAX_BS_PGM:MAX_BS: indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                      uchar;  /* MIN_ST_PGM ndicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                    };  /*This flag indicates whether the Master Block Mode is available */
                  };
                  "INTERLEAVED" uchar;  /* QUEUE_SIZE_PGM: This value describe the total count of bytes for this queue*/
                };
              };
            };
            block "DAQ_EVENT" taggedunion Daq_Event {
              "FIXED_EVENT_LIST" taggedstruct {
                ("EVENT" uint)*;
              };
              "VARIABLE" taggedstruct {
                block "AVAILABLE_EVENT_LIST" taggedstruct {
                  ("EVENT" uint)*;
                };
                block "DEFAULT_EVENT_LIST" taggedstruct {
                  ("EVENT" uint)*;
                };
              };
            };
          };
          taggedstruct {
            block "XCP_ON_CAN" struct {
              struct CAN_Parameters {
                uint;  /* XCP on CAN version, currentl 0x0100 */
                taggedstruct {
                  "CAN_ID_BROADCAST" ulong;  /* Auto-detection CAN-ID */
                  "CAN_ID_MASTER" ulong;  /* CMD/STIM CAN-ID */
                  "CAN_ID_SLAVE" ulong;  /* RES/ERR/EV/SERV/DAQ CAN-ID */
                  "BAUDRATE" ulong;  /* Baudrate in Hz */
                  "SAMPLE_POINT" uchar;  /* Sample point in % of bit time */
                  "SAMPLE_RATE" enum {
                    "SINGLE" = 1,
                    "TRIPLE" = 3
                  };  /* Sample per bit */
                  "BTL_CYCLES" uchar;  /* slots per bit time */
                  "SJW" uchar;  /*Length synchr. segment */
                  "SYNC_EDGE" enum {
                    "SINGLE" = 1,
                    "DUAL" = 2
                  };  /* SINGLE: on falling edge only
 DUAL: on falling and rising edge*/
                  "MAX_DLC_REQUIRED" ;  /* master to slave frames always to have DLC = MAX_DLC = 8*/
                  (block "DAQ_LIST_CAN_ID" struct {
                    uint;  /* reference to DAQ_LIST_NUMBER */
                    taggedstruct {
                      "VARIABLE" ;
                      "FIXED" ulong;  /* this DAQ_LIST always on this CAN_ID */
                    };  /* exclusive tags: either VARIABLE or FIXED */
                  })*;
                };
              };  /* specific for CAN */
              taggedstruct Common_Parameters {
                block "PROTOCOL_LAYER" struct Protocol_Layer {
                  uint;  /* XCP protocol layer version, current 0x100*/
                  uint;  /* T1 [ms] Time-out of the standard CTO, for example CONNECT*/
                  uint;  /* T2 [ms] Time-out of the checksum calculation*/
                  uint;  /* T3 [ms] Time-out of the non-volatile memory programming: PROGRAM_START, PROGRAM_VERIFY, PROGRAM_PREPARE*/
                  uint;  /* T4 [ms] Time-out of the non-volatile memory programming: PROGRAM_CLEAR*/
                  uint;  /* T5 [ms] Time-out of the non-volatile memory programming: PROGRAM, PROGRAM_RESET, PROGRAM_MAX*/
                  uint;  /* T6 [ms] Time-out of the command CONNECT(USER_DEFINED)*/
                  uint;  /* T7 [ms] Time-out of the pre-action*/
                  uchar;  /* MAX_CTO: Indicates the maximum length of a CTO packet in bytes. */
                  uint;  /* MAX_DTO: Indicates the maximum length of a DTO packet in bytes. */
                  enum {
                    "BYTE_ORDER_MSB_LAST" = 0,
                    "BYTE_ORDER_MSB_FIRST" = 1
                  };  /* BYTE_ORDER: BYTE_ORDER_MSB_LAST = Intel, BYTE_ORDER_MSB_FIRST = Motorola*/
                  enum {
                    "ADDRESS_GRANULARITY_BYTE" = 1,
                    "ADDRESS_GRANULARITY_WORD" = 2,
                    "ADDRESS_GRANULARITY_DWORD" = 4
                  };  /*The address granularity indicates the size of an element contained at a single address.*/
                  taggedstruct {
                    ("OPTIONAL_CMD" enum {
                      "GET_COMM_MODE_INFO" = 251,
                      "GET_ID" = 250,
                      "SET_REQUEST" = 249,
                      "GET_SEED" = 248,
                      "UNLOCK" = 247,
                      "SET_MTA" = 246,
                      "UPLOAD" = 245,
                      "SHORT_UPLOAD" = 244,
                      "BUILD_CHECKSUM" = 243,
                      "TRANSPORT_LAYER_CMD" = 242,
                      "USER_CMD" = 241,
                      "DOWNLOAD" = 240,
                      "DOWNLOAD_NEXT" = 239,
                      "DOWNLOAD_MAX" = 238,
                      "SHORT_DOWNLOAD" = 237,
                      "MODIFY_BITS" = 236,
                      "SET_CAL_PAGE" = 235,
                      "GET_CAL_PAGE" = 234,
                      "GET_PAG_PROCESSOR_INFO" = 233,
                      "GET_SEGMENT_INFO" = 232,
                      "GET_PAGE_INFO" = 231,
                      "SET_SEGMENT_MODE" = 230,
                      "GET_SEGMENT_MODE" = 229,
                      "COPY_CAL_PAGE" = 228,
                      "CLEAR_DAQ_LIST" = 227,
                      "SET_DAQ_PTR" = 226,
                      "WRITE_DAQ" = 225,
                      "SET_DAQ_LIST_MODE" = 224,
                      "GET_DAQ_LIST_MODE" = 223,
                      "START_STOP_DAQ_LIST" = 222,
                      "START_STOP_SYNCH" = 221,
                      "GET_DAQ_CLOCK" = 220,
                      "READ_DAQ" = 219,
                      "GET_DAQ_PROCESSOR_INFO" = 218,
                      "GET_DAQ_RESOLUTION_INFO" = 217,
                      "GET_DAQ_LIST_INFO" = 216,
                      "GET_DAQ_EVENT_INFO" = 215,
                      "FREE_DAQ" = 214,
                      "ALLOC_DAQ" = 213,
                      "ALLOC_ODT" = 212,
                      "ALLOC_ODT_ENTRY" = 211,
                      "PROGRAM_START" = 210,
                      "PROGRAM_CLEAR" = 209,
                      "PROGRAM" = 208,
                      "PROGRAM_RESET" = 207,
                      "GET_PGM_PROCESSOR_INFO" = 206,
                      "GET_SECTOR_INFO" = 205,
                      "PROGRAM_PREPARE" = 204,
                      "PROGRAM_FORMAT" = 203,
                      "PROGRAM_NEXT" = 202,
                      "PROGRAM_MAX" = 201,
                      "PROGRAM_VERIFY" = 200
                    })*;  /* XCP-Code of optional command supported by the slave*/
                    "COMMUNICATION_MODE_SUPPORTED" taggedunion {
                      "BLOCK" taggedstruct {
                        "SLAVE" ;
                        "MASTER" struct {
                          uchar;  /* MAX_BS: Indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                          uchar;  /* MIN_ST: Indicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                        };
                      };
                      "INTERLEAVED" uchar;  /* QUEUE_SIZE: indicates the maximum number of consecutive command packets the master can send to the receipt queue of the slave*/
                    };
                    "SEED_AND_KEY_EXTERNAL_FUNCTION" char[256];  /* Name of the Seed&Key function*/
                  };
                };
                block "SEGMENT" struct Segment {
                  uchar;  /* SEGMENT_NUMBER: Logical data segment number*/
                  uchar;  /* Total number of available pages */
                  uchar;  /* ADDRESS_EXTENSION: Address extension for this SEGMENT*/
                  uchar;  /* COMPRESSION_METHOD: The COMPRESSION_x flags indicate which compression state of the incoming data the slave can process*/
                  uchar;  /* ENCRYPTION_METHOD: The  ENCRYPTION_x flags indicate which encryption state of the incoming data the slave can process.*/
                  taggedstruct {
                    block "CHECKSUM" struct {
                      enum {
                        "XCP_ADD_11" = 1,
                        "XCP_ADD_12" = 2,
                        "XCP_ADD_14" = 3,
                        "XCP_ADD_22" = 4,
                        "XCP_ADD_24" = 5,
                        "XCP_ADD_44" = 6,
                        "XCP_CRC_16" = 7,
                        "XCP_CRC_16_CITT" = 8,
                        "XCP_CRC_32" = 9,
                        "XCP_USER_DEFINED" = 255
                      };  /* Checksum type*/
                      taggedstruct {
                        "MAX_BLOCK_SIZE" ulong;  /* Maximum block size for checksum calculation */
                        "EXTERNAL_FUNCTION" char[256];  /* Name of the Checksum.DLL */
                      };
                    };
                    (block "PAGE" struct {
                      uchar;  /* PAGE_NUMBER: Logical page number*/
                      enum {
                        "ECU_ACCESS_NOT_ALLOWED" = 0,
                        "ECU_ACCESS_WITHOUT_XCP_ONLY" = 1,
                        "ECU_ACCESS_WITH_XCP_ONLY" = 2,
                        "ECU_ACCESS_DONT_CARE" = 3
                      };  /*The ECU_ACCESS_x  flags indicate whether and how the ECU can access this page.*/
                      enum {
                        "XCP_READ_ACCESS_NOT_ALLOWED" = 0,
                        "XCP_READ_ACCESS_WITHOUT_ECU_ONLY" = 1,
                        "XCP_READ_ACCESS_WITH_ECU_ONLY" = 2,
                        "XCP_READ_ACCESS_DONT_CARE" = 3
                      };  /*The XCP_x_ACCESS_y flags indicate whether and how the XCP master can access this page.*/
                      enum {
                        "XCP_WRITE_ACCESS_NOT_ALLOWED" = 0,
                        "XCP_WRITE_ACCESS_WITHOUT_ECU_ONLY" = 1,
                        "XCP_WRITE_ACCESS_WITH_ECU_ONLY" = 2,
                        "XCP_WRITE_ACCESS_DONT_CARE" = 3
                      };  /*The XCP_WRITE_ACCESS_x flags indicate whether the  X CP master can write to this PAGE*/
                      taggedstruct {
                        "INIT_SEGMENT" uchar;  /* references segment that initialises this page */
                      };
                    })*;  /* PAGES for this SEGMENT */
                    (block "ADDRESS_MAPPING" struct {
                      ulong;  /* source address */
                      ulong;  /* destination address */
                      ulong;  /* length */
                    })*;
                    "PGM_VERIFY" ulong;  /* verification value for PGM */
                  };
                };
                block "DAQ" struct Daq {
                  enum {
                    "STATIC" = 0,
                    "DYNAMIC" = 1
                  };  /*The flag indicates whether the DAQ lists that are not PREDEFINED shall be configured statically or dynamically*/
                  uint;  /* MAX_DAQ: Total number of available DAQ lists */
                  uint;  /* MAX_EVENT_CHANNEL: Total number of available event channels*/
                  uchar;  /* MIN_DAQ: Total number of predefined DAQ lists */
                  enum {
                    "OPTIMISATION_TYPE_DEFAULT" = 0,
                    "OPTIMISATION_TYPE_ODT_TYPE_16" = 1,
                    "OPTIMISATION_TYPE_ODT_TYPE_32" = 2,
                    "OPTIMISATION_TYPE_ODT_TYPE_64" = 3,
                    "OPTIMISATION_TYPE_ODT_TYPE_ALIGNMENT" = 4,
                    "OPTIMISATION_TYPE_MAX_ENTRY_SIZE" = 5
                  };  /* Indicate the Type of Optimisation Method the master preferably should use.*/
                  enum {
                    "ADDRESS_EXTENSION_FREE" = 0,
                    "ADDRESS_EXTENSION_ODT" = 1,
                    "ADDRESS_EXTENSION_DAQ" = 3
                  };  /*The flag indicates whether the address extension of all entries within one ODT or within one DAQ must be the same. */
                  enum {
                    "IDENTIFICATION_FIELD_TYPE_ABSOLUTE" = 0,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE" = 1,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD" = 2,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED" = 3
                  };  /* The type of Identification Field the slave will use when transferring DAQ Packets to the master*/
                  enum {
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE" = 1,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_WORD" = 2,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DWORD" = 4,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DLONG" = 8
                  };  /* Granularity for size of ODT entry */
                  uchar;  /* MAX_ODT_ENTRY_SIZE_DAQ Maximum size of ODT entry (DIRECTION = DAQ) */
                  enum {
                    "NO_OVERLOAD_INDICATION" = 0,
                    "OVERLOAD_INDICATION_PID" = 1,
                    "OVERLOAD_INDICATION_EVENT" = 2
                  };  /*OVERLOAD_INDICATION_PID: This means the higest bit is set in the PID, when an overload occurs
OVERLOAD_INDICATION_EVENT: This means an event is set, when an overload occurs*/
                  taggedstruct {
                    "PRESCALER_SUPPORTED" ;  /*This flag indicates that all DAQ lists support the prescaler for reducing the transmission period.*/
                    "RESUME_SUPPORTED" ;  /*This  flag indicates that all DAQ lists can be put in RESUME mode. */
                    block "STIM" struct {
                      enum {
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE" = 1,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD" = 2,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_DWORD" = 4,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_DLONG" = 8
                      };  /* Granularity for size of ODT entry direction STIM*/
                      uchar;  /* MAX_ODT_ENTRY_SIZE_STIM Maximum size of ODT entry (DIRECTION = STIM)*/
                      taggedstruct {
                        "BIT_STIM_SUPPORTED" ;  /*The flag indicates  whether  bitwise  data  stimulation  through BIT_OFFSET in WRITE_DAQ is supported.*/
                      };
                    };
                    block "TIMESTAMP_SUPPORTED" struct {
                      uint;  /*The timestamp will increment by TIMESTAMP_TICKS per unit and wrap around if an overflow occurs. */
                      enum {
                        "NO_TIME_STAMP" = 0,
                        "SIZE_BYTE" = 1,
                        "SIZE_WORD" = 2,
                        "SIZE_DWORD" = 4
                      };  /*Timestamp size in bytes*/
                      enum {
                        "UNIT_1NS" = 0,
                        "UNIT_10NS" = 1,
                        "UNIT_100NS" = 2,
                        "UNIT_1US" = 3,
                        "UNIT_10US" = 4,
                        "UNIT_100US" = 5,
                        "UNIT_1MS" = 6,
                        "UNIT_10MS" = 7,
                        "UNIT_100MS" = 8,
                        "UNIT_1S" = 9
                      };  /*Ticks per unit*/
                      taggedstruct {
                        "TIMESTAMP_FIXED" ;
                      };  /* TIMESTAMP_FIXED flag indicates that the Slave always will send DTO Packets in time stamped mode. */
                    };
                    "PID_OFF_SUPPORTED" ;  /*Flag in DAQ_PROPERTIES indicates that transfer of DTO Packets without Identification Field is possible. */
                    (block "DAQ_LIST" struct {
                      uint;  /* DAQ_LIST_NUMBER  is in the range [0,1,..MIN_DAQ-1]. */
                      taggedstruct {
                        "DAQ_LIST_TYPE" enum {
                          "DAQ" = 1,
                          "STIM" = 2,
                          "DAQ_STIM" = 3
                        };  /* DAQ: DIRECTION = DAQ only 
 STIM: DIRECTION = STIM only 
 DAQ_STIM: both directions are possible */
                        "MAX_ODT" uchar;  /*Number of ODTs in this DAQ list */
                        "MAX_ODT_ENTRIES" uchar;  /*Maximum number of entries in an ODT*/
                        "FIRST_PID" uchar;  /*FIRST_PID: Is the PID in the DTO Packet of the first ODT transferred by this DAQ list.*/
                        "EVENT_FIXED" uint;  /*The flag indicates that the Event Channel for this DAQ list can not be changed. */
                        block "PREDEFINED" taggedstruct {
                          (block "ODT" struct {
                            uchar;  /* ODT number */
                            taggedstruct {
                              ("ODT_ENTRY" struct {
                                uchar;  /* ODT_ENTRY number */
                                ulong;  /* address of element */
                                uchar;  /* address extension of element */
                                uchar;  /* size of element [AG] */
                                uchar;  /* BIT_OFFSET */
                              })*;
                            };
                          })*;
                        };  /*PREDEFINED;The DAQ list is predefined and fixed in the slave devices memory.*/
                      };
                    })*;
                    (block "EVENT" struct {
                      char[101];  /* EVENT_CHANNEL_NAME */
                      char[9];  /* EVENT_CHANNEL_SHORT_NAME */
                      uint;  /* EVENT_CHANNEL_NUMBER*/
                      enum {
                        "DAQ" = 1,
                        "STIM" = 2,
                        "DAQ_STIM" = 3
                      };  /* DAQ: only DAQ_LISTs with DIRECTION = DAQ 
 STIM: only DAQ_LISTs with DIRECTION = STIM 
 DAQ_STIM both kind of DAQ_LISTs*/
                      uchar;  /* MAX_DAQ_LIST:Maximum number of DAQ lists in this event channel */
                      uchar;  /* TIME_CYCLE: Event channel time cycle */
                      uchar;  /* TIME_UNIT: Event channel time unit*/
                      uchar;  /* PRIORITY:The event channel with event channel priority = FF has the highest priority */
                    })*;
                  };
                };
                block "PAG" struct Pag {
                  uchar;  /* MAX_SEGMENTS: Is the total number of segments in the slave device*/
                  taggedstruct {
                    "FREEZE_SUPPORTED" ;  /*This flag indicates that all SEGMENTS can be put in FREEZE */
                  };
                };
                block "PGM" struct Pgm {
                  enum {
                    "PGM_MODE_ABSOLUTE" = 1,
                    "PGM_MODE_FUNCTIONAL" = 2,
                    "PGM_MODE_ABSOLUTE_AND_FUNCTIONAL" = 3
                  };  /*The  ABSOLUTE_MODE  and  FUNCTIONAL_MODE  flags  indicate  the  clear/programming mode that can be used */
                  uchar;  /* MAX_SECTORS: Total number of available sectors */
                  uchar;  /* MAX_CTO_PGM: Maximum CTO size for PGM */
                  taggedstruct {
                    (block "SECTOR" struct {
                      char[101];  /* SECTOR_NAME */
                      uchar;  /* SECTOR_NUMBER*/
                      ulong;  /* Start address for this SECTOR */
                      ulong;  /* Length of this SECTOR [AG] */
                      uchar;  /* CLEAR_SEQUENCE_NUMBER: The Clear Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
                      uchar;  /* PROGRAM_SEQUENCE_NUMBER: The Program Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
                      uchar;  /* PROGRAM_METHOD: The work flow depends on mode  absolute access or functional access*/
                    })*;
                    "COMMUNICATION_MODE_SUPPORTED" taggedunion {
                      "BLOCK" taggedstruct {
                        "SLAVE" ;  /*This flag indicates whether the Slave Block Mode is available during Programming. */
                        "MASTER" struct {
                          uchar;  /* MAX_BS_PGM:MAX_BS: indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                          uchar;  /* MIN_ST_PGM ndicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                        };  /*This flag indicates whether the Master Block Mode is available */
                      };
                      "INTERLEAVED" uchar;  /* QUEUE_SIZE_PGM: This value describe the total count of bytes for this queue*/
                    };
                  };
                };
                block "DAQ_EVENT" taggedunion Daq_Event {
                  "FIXED_EVENT_LIST" taggedstruct {
                    ("EVENT" uint)*;
                  };
                  "VARIABLE" taggedstruct {
                    block "AVAILABLE_EVENT_LIST" taggedstruct {
                      ("EVENT" uint)*;
                    };
                    block "DEFAULT_EVENT_LIST" taggedstruct {
                      ("EVENT" uint)*;
                    };
                  };
                };
              };  /* overruling of default */
            };
            block "XCP_ON_SxI" struct {
              struct SxI_Parameters {
                uint;  /* XCP on SxI version, currently 0x0100 */
                ulong;  /* BAUDRATE [Hz] */
                taggedstruct {
                  "ASYNCH_FULL_DUPLEX_MODE" struct {
                    enum {
                      "PARITY_NONE" = 0,
                      "PARITY_ODD" = 1,
                      "PARITY_EVEN" = 2
                    };  /* Parity bit settings*/
                    enum {
                      "ONE_STOP_BIT" = 1,
                      "TWO_STOP_BITS" = 2
                    };  /*Stop bit settings*/
                  };
                  "SYNCH_FULL_DUPLEX_MODE_BYTE" ;
                  "SYNCH_FULL_DUPLEX_MODE_WORD" ;
                  "SYNCH_FULL_DUPLEX_MODE_DWORD" ;
                  "SYNCH_MASTER_SLAVE_MODE_BYTE" ;
                  "SYNCH_MASTER_SLAVE_MODE_WORD" ;
                  "SYNCH_MASTER_SLAVE_MODE_DWORD" ;
                };  /* exclusive tags */
                enum {
                  "HEADER_LEN_BYTE" = 0,
                  "HEADER_LEN_CTR_BYTE" = 1,
                  "HEADER_LEN_FILL_BYTE" = 2,
                  "HEADER_LEN_WORD" = 3,
                  "HEADER_LEN_CTR_WORD" = 4,
                  "HEADER_LEN_FILL_WORD" = 5
                };  /* XCP packet header */
                enum {
                  "NO_CHECKSUM" = 0,
                  "CHECKSUM_BYTE" = 1,
                  "CHECKSUM_WORD" = 2
                };  /* Checksum type*/
              };  /* specific for SxI */
              taggedstruct Common_Parameters {
                block "PROTOCOL_LAYER" struct Protocol_Layer {
                  uint;  /* XCP protocol layer version, current 0x100*/
                  uint;  /* T1 [ms] Time-out of the standard CTO, for example CONNECT*/
                  uint;  /* T2 [ms] Time-out of the checksum calculation*/
                  uint;  /* T3 [ms] Time-out of the non-volatile memory programming: PROGRAM_START, PROGRAM_VERIFY, PROGRAM_PREPARE*/
                  uint;  /* T4 [ms] Time-out of the non-volatile memory programming: PROGRAM_CLEAR*/
                  uint;  /* T5 [ms] Time-out of the non-volatile memory programming: PROGRAM, PROGRAM_RESET, PROGRAM_MAX*/
                  uint;  /* T6 [ms] Time-out of the command CONNECT(USER_DEFINED)*/
                  uint;  /* T7 [ms] Time-out of the pre-action*/
                  uchar;  /* MAX_CTO: Indicates the maximum length of a CTO packet in bytes. */
                  uint;  /* MAX_DTO: Indicates the maximum length of a DTO packet in bytes. */
                  enum {
                    "BYTE_ORDER_MSB_LAST" = 0,
                    "BYTE_ORDER_MSB_FIRST" = 1
                  };  /* BYTE_ORDER: BYTE_ORDER_MSB_LAST = Intel, BYTE_ORDER_MSB_FIRST = Motorola*/
                  enum {
                    "ADDRESS_GRANULARITY_BYTE" = 1,
                    "ADDRESS_GRANULARITY_WORD" = 2,
                    "ADDRESS_GRANULARITY_DWORD" = 4
                  };  /*The address granularity indicates the size of an element contained at a single address.*/
                  taggedstruct {
                    ("OPTIONAL_CMD" enum {
                      "GET_COMM_MODE_INFO" = 251,
                      "GET_ID" = 250,
                      "SET_REQUEST" = 249,
                      "GET_SEED" = 248,
                      "UNLOCK" = 247,
                      "SET_MTA" = 246,
                      "UPLOAD" = 245,
                      "SHORT_UPLOAD" = 244,
                      "BUILD_CHECKSUM" = 243,
                      "TRANSPORT_LAYER_CMD" = 242,
                      "USER_CMD" = 241,
                      "DOWNLOAD" = 240,
                      "DOWNLOAD_NEXT" = 239,
                      "DOWNLOAD_MAX" = 238,
                      "SHORT_DOWNLOAD" = 237,
                      "MODIFY_BITS" = 236,
                      "SET_CAL_PAGE" = 235,
                      "GET_CAL_PAGE" = 234,
                      "GET_PAG_PROCESSOR_INFO" = 233,
                      "GET_SEGMENT_INFO" = 232,
                      "GET_PAGE_INFO" = 231,
                      "SET_SEGMENT_MODE" = 230,
                      "GET_SEGMENT_MODE" = 229,
                      "COPY_CAL_PAGE" = 228,
                      "CLEAR_DAQ_LIST" = 227,
                      "SET_DAQ_PTR" = 226,
                      "WRITE_DAQ" = 225,
                      "SET_DAQ_LIST_MODE" = 224,
                      "GET_DAQ_LIST_MODE" = 223,
                      "START_STOP_DAQ_LIST" = 222,
                      "START_STOP_SYNCH" = 221,
                      "GET_DAQ_CLOCK" = 220,
                      "READ_DAQ" = 219,
                      "GET_DAQ_PROCESSOR_INFO" = 218,
                      "GET_DAQ_RESOLUTION_INFO" = 217,
                      "GET_DAQ_LIST_INFO" = 216,
                      "GET_DAQ_EVENT_INFO" = 215,
                      "FREE_DAQ" = 214,
                      "ALLOC_DAQ" = 213,
                      "ALLOC_ODT" = 212,
                      "ALLOC_ODT_ENTRY" = 211,
                      "PROGRAM_START" = 210,
                      "PROGRAM_CLEAR" = 209,
                      "PROGRAM" = 208,
                      "PROGRAM_RESET" = 207,
                      "GET_PGM_PROCESSOR_INFO" = 206,
                      "GET_SECTOR_INFO" = 205,
                      "PROGRAM_PREPARE" = 204,
                      "PROGRAM_FORMAT" = 203,
                      "PROGRAM_NEXT" = 202,
                      "PROGRAM_MAX" = 201,
                      "PROGRAM_VERIFY" = 200
                    })*;  /* XCP-Code of optional command supported by the slave*/
                    "COMMUNICATION_MODE_SUPPORTED" taggedunion {
                      "BLOCK" taggedstruct {
                        "SLAVE" ;
                        "MASTER" struct {
                          uchar;  /* MAX_BS: Indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                          uchar;  /* MIN_ST: Indicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                        };
                      };
                      "INTERLEAVED" uchar;  /* QUEUE_SIZE: indicates the maximum number of consecutive command packets the master can send to the receipt queue of the slave*/
                    };
                    "SEED_AND_KEY_EXTERNAL_FUNCTION" char[256];  /* Name of the Seed&Key function*/
                  };
                };
                block "SEGMENT" struct Segment {
                  uchar;  /* SEGMENT_NUMBER: Logical data segment number*/
                  uchar;  /* Total number of available pages */
                  uchar;  /* ADDRESS_EXTENSION: Address extension for this SEGMENT*/
                  uchar;  /* COMPRESSION_METHOD: The COMPRESSION_x flags indicate which compression state of the incoming data the slave can process*/
                  uchar;  /* ENCRYPTION_METHOD: The  ENCRYPTION_x flags indicate which encryption state of the incoming data the slave can process.*/
                  taggedstruct {
                    block "CHECKSUM" struct {
                      enum {
                        "XCP_ADD_11" = 1,
                        "XCP_ADD_12" = 2,
                        "XCP_ADD_14" = 3,
                        "XCP_ADD_22" = 4,
                        "XCP_ADD_24" = 5,
                        "XCP_ADD_44" = 6,
                        "XCP_CRC_16" = 7,
                        "XCP_CRC_16_CITT" = 8,
                        "XCP_CRC_32" = 9,
                        "XCP_USER_DEFINED" = 255
                      };  /* Checksum type*/
                      taggedstruct {
                        "MAX_BLOCK_SIZE" ulong;  /* Maximum block size for checksum calculation */
                        "EXTERNAL_FUNCTION" char[256];  /* Name of the Checksum.DLL */
                      };
                    };
                    (block "PAGE" struct {
                      uchar;  /* PAGE_NUMBER: Logical page number*/
                      enum {
                        "ECU_ACCESS_NOT_ALLOWED" = 0,
                        "ECU_ACCESS_WITHOUT_XCP_ONLY" = 1,
                        "ECU_ACCESS_WITH_XCP_ONLY" = 2,
                        "ECU_ACCESS_DONT_CARE" = 3
                      };  /*The ECU_ACCESS_x  flags indicate whether and how the ECU can access this page.*/
                      enum {
                        "XCP_READ_ACCESS_NOT_ALLOWED" = 0,
                        "XCP_READ_ACCESS_WITHOUT_ECU_ONLY" = 1,
                        "XCP_READ_ACCESS_WITH_ECU_ONLY" = 2,
                        "XCP_READ_ACCESS_DONT_CARE" = 3
                      };  /*The XCP_x_ACCESS_y flags indicate whether and how the XCP master can access this page.*/
                      enum {
                        "XCP_WRITE_ACCESS_NOT_ALLOWED" = 0,
                        "XCP_WRITE_ACCESS_WITHOUT_ECU_ONLY" = 1,
                        "XCP_WRITE_ACCESS_WITH_ECU_ONLY" = 2,
                        "XCP_WRITE_ACCESS_DONT_CARE" = 3
                      };  /*The XCP_WRITE_ACCESS_x flags indicate whether the  X CP master can write to this PAGE*/
                      taggedstruct {
                        "INIT_SEGMENT" uchar;  /* references segment that initialises this page */
                      };
                    })*;  /* PAGES for this SEGMENT */
                    (block "ADDRESS_MAPPING" struct {
                      ulong;  /* source address */
                      ulong;  /* destination address */
                      ulong;  /* length */
                    })*;
                    "PGM_VERIFY" ulong;  /* verification value for PGM */
                  };
                };
                block "DAQ" struct Daq {
                  enum {
                    "STATIC" = 0,
                    "DYNAMIC" = 1
                  };  /*The flag indicates whether the DAQ lists that are not PREDEFINED shall be configured statically or dynamically*/
                  uint;  /* MAX_DAQ: Total number of available DAQ lists */
                  uint;  /* MAX_EVENT_CHANNEL: Total number of available event channels*/
                  uchar;  /* MIN_DAQ: Total number of predefined DAQ lists */
                  enum {
                    "OPTIMISATION_TYPE_DEFAULT" = 0,
                    "OPTIMISATION_TYPE_ODT_TYPE_16" = 1,
                    "OPTIMISATION_TYPE_ODT_TYPE_32" = 2,
                    "OPTIMISATION_TYPE_ODT_TYPE_64" = 3,
                    "OPTIMISATION_TYPE_ODT_TYPE_ALIGNMENT" = 4,
                    "OPTIMISATION_TYPE_MAX_ENTRY_SIZE" = 5
                  };  /* Indicate the Type of Optimisation Method the master preferably should use.*/
                  enum {
                    "ADDRESS_EXTENSION_FREE" = 0,
                    "ADDRESS_EXTENSION_ODT" = 1,
                    "ADDRESS_EXTENSION_DAQ" = 3
                  };  /*The flag indicates whether the address extension of all entries within one ODT or within one DAQ must be the same. */
                  enum {
                    "IDENTIFICATION_FIELD_TYPE_ABSOLUTE" = 0,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE" = 1,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD" = 2,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED" = 3
                  };  /* The type of Identification Field the slave will use when transferring DAQ Packets to the master*/
                  enum {
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE" = 1,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_WORD" = 2,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DWORD" = 4,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DLONG" = 8
                  };  /* Granularity for size of ODT entry */
                  uchar;  /* MAX_ODT_ENTRY_SIZE_DAQ Maximum size of ODT entry (DIRECTION = DAQ) */
                  enum {
                    "NO_OVERLOAD_INDICATION" = 0,
                    "OVERLOAD_INDICATION_PID" = 1,
                    "OVERLOAD_INDICATION_EVENT" = 2
                  };  /*OVERLOAD_INDICATION_PID: This means the higest bit is set in the PID, when an overload occurs
OVERLOAD_INDICATION_EVENT: This means an event is set, when an overload occurs*/
                  taggedstruct {
                    "PRESCALER_SUPPORTED" ;  /*This flag indicates that all DAQ lists support the prescaler for reducing the transmission period.*/
                    "RESUME_SUPPORTED" ;  /*This  flag indicates that all DAQ lists can be put in RESUME mode. */
                    block "STIM" struct {
                      enum {
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE" = 1,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD" = 2,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_DWORD" = 4,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_DLONG" = 8
                      };  /* Granularity for size of ODT entry direction STIM*/
                      uchar;  /* MAX_ODT_ENTRY_SIZE_STIM Maximum size of ODT entry (DIRECTION = STIM)*/
                      taggedstruct {
                        "BIT_STIM_SUPPORTED" ;  /*The flag indicates  whether  bitwise  data  stimulation  through BIT_OFFSET in WRITE_DAQ is supported.*/
                      };
                    };
                    block "TIMESTAMP_SUPPORTED" struct {
                      uint;  /*The timestamp will increment by TIMESTAMP_TICKS per unit and wrap around if an overflow occurs. */
                      enum {
                        "NO_TIME_STAMP" = 0,
                        "SIZE_BYTE" = 1,
                        "SIZE_WORD" = 2,
                        "SIZE_DWORD" = 4
                      };  /*Timestamp size in bytes*/
                      enum {
                        "UNIT_1NS" = 0,
                        "UNIT_10NS" = 1,
                        "UNIT_100NS" = 2,
                        "UNIT_1US" = 3,
                        "UNIT_10US" = 4,
                        "UNIT_100US" = 5,
                        "UNIT_1MS" = 6,
                        "UNIT_10MS" = 7,
                        "UNIT_100MS" = 8,
                        "UNIT_1S" = 9
                      };  /*Ticks per unit*/
                      taggedstruct {
                        "TIMESTAMP_FIXED" ;
                      };  /* TIMESTAMP_FIXED flag indicates that the Slave always will send DTO Packets in time stamped mode. */
                    };
                    "PID_OFF_SUPPORTED" ;  /*Flag in DAQ_PROPERTIES indicates that transfer of DTO Packets without Identification Field is possible. */
                    (block "DAQ_LIST" struct {
                      uint;  /* DAQ_LIST_NUMBER  is in the range [0,1,..MIN_DAQ-1]. */
                      taggedstruct {
                        "DAQ_LIST_TYPE" enum {
                          "DAQ" = 1,
                          "STIM" = 2,
                          "DAQ_STIM" = 3
                        };  /* DAQ: DIRECTION = DAQ only 
 STIM: DIRECTION = STIM only 
 DAQ_STIM: both directions are possible */
                        "MAX_ODT" uchar;  /*Number of ODTs in this DAQ list */
                        "MAX_ODT_ENTRIES" uchar;  /*Maximum number of entries in an ODT*/
                        "FIRST_PID" uchar;  /*FIRST_PID: Is the PID in the DTO Packet of the first ODT transferred by this DAQ list.*/
                        "EVENT_FIXED" uint;  /*The flag indicates that the Event Channel for this DAQ list can not be changed. */
                        block "PREDEFINED" taggedstruct {
                          (block "ODT" struct {
                            uchar;  /* ODT number */
                            taggedstruct {
                              ("ODT_ENTRY" struct {
                                uchar;  /* ODT_ENTRY number */
                                ulong;  /* address of element */
                                uchar;  /* address extension of element */
                                uchar;  /* size of element [AG] */
                                uchar;  /* BIT_OFFSET */
                              })*;
                            };
                          })*;
                        };  /*PREDEFINED;The DAQ list is predefined and fixed in the slave devices memory.*/
                      };
                    })*;
                    (block "EVENT" struct {
                      char[101];  /* EVENT_CHANNEL_NAME */
                      char[9];  /* EVENT_CHANNEL_SHORT_NAME */
                      uint;  /* EVENT_CHANNEL_NUMBER*/
                      enum {
                        "DAQ" = 1,
                        "STIM" = 2,
                        "DAQ_STIM" = 3
                      };  /* DAQ: only DAQ_LISTs with DIRECTION = DAQ 
 STIM: only DAQ_LISTs with DIRECTION = STIM 
 DAQ_STIM both kind of DAQ_LISTs*/
                      uchar;  /* MAX_DAQ_LIST:Maximum number of DAQ lists in this event channel */
                      uchar;  /* TIME_CYCLE: Event channel time cycle */
                      uchar;  /* TIME_UNIT: Event channel time unit*/
                      uchar;  /* PRIORITY:The event channel with event channel priority = FF has the highest priority */
                    })*;
                  };
                };
                block "PAG" struct Pag {
                  uchar;  /* MAX_SEGMENTS: Is the total number of segments in the slave device*/
                  taggedstruct {
                    "FREEZE_SUPPORTED" ;  /*This flag indicates that all SEGMENTS can be put in FREEZE */
                  };
                };
                block "PGM" struct Pgm {
                  enum {
                    "PGM_MODE_ABSOLUTE" = 1,
                    "PGM_MODE_FUNCTIONAL" = 2,
                    "PGM_MODE_ABSOLUTE_AND_FUNCTIONAL" = 3
                  };  /*The  ABSOLUTE_MODE  and  FUNCTIONAL_MODE  flags  indicate  the  clear/programming mode that can be used */
                  uchar;  /* MAX_SECTORS: Total number of available sectors */
                  uchar;  /* MAX_CTO_PGM: Maximum CTO size for PGM */
                  taggedstruct {
                    (block "SECTOR" struct {
                      char[101];  /* SECTOR_NAME */
                      uchar;  /* SECTOR_NUMBER*/
                      ulong;  /* Start address for this SECTOR */
                      ulong;  /* Length of this SECTOR [AG] */
                      uchar;  /* CLEAR_SEQUENCE_NUMBER: The Clear Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
                      uchar;  /* PROGRAM_SEQUENCE_NUMBER: The Program Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
                      uchar;  /* PROGRAM_METHOD: The work flow depends on mode  absolute access or functional access*/
                    })*;
                    "COMMUNICATION_MODE_SUPPORTED" taggedunion {
                      "BLOCK" taggedstruct {
                        "SLAVE" ;  /*This flag indicates whether the Slave Block Mode is available during Programming. */
                        "MASTER" struct {
                          uchar;  /* MAX_BS_PGM:MAX_BS: indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                          uchar;  /* MIN_ST_PGM ndicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                        };  /*This flag indicates whether the Master Block Mode is available */
                      };
                      "INTERLEAVED" uchar;  /* QUEUE_SIZE_PGM: This value describe the total count of bytes for this queue*/
                    };
                  };
                };
                block "DAQ_EVENT" taggedunion Daq_Event {
                  "FIXED_EVENT_LIST" taggedstruct {
                    ("EVENT" uint)*;
                  };
                  "VARIABLE" taggedstruct {
                    block "AVAILABLE_EVENT_LIST" taggedstruct {
                      ("EVENT" uint)*;
                    };
                    block "DEFAULT_EVENT_LIST" taggedstruct {
                      ("EVENT" uint)*;
                    };
                  };
                };
              };  /* overruling of default */
            };
            block "XCP_ON_TCP_IP" struct {
              struct TCP_IP_Parameters {
                uint;  /* XCP on TCP_IP version, currently 0x0100 */
                uint;  /* PORT */
                taggedunion {
                  "HOST_NAME" char[256];  /*Name of the host like localhost*/
                  "ADDRESS" char[15];  /* IP address like 127.0.0.1*/
                };
              };  /* specific for TCP_IP */
              taggedstruct Common_Parameters {
                block "PROTOCOL_LAYER" struct Protocol_Layer {
                  uint;  /* XCP protocol layer version, current 0x100*/
                  uint;  /* T1 [ms] Time-out of the standard CTO, for example CONNECT*/
                  uint;  /* T2 [ms] Time-out of the checksum calculation*/
                  uint;  /* T3 [ms] Time-out of the non-volatile memory programming: PROGRAM_START, PROGRAM_VERIFY, PROGRAM_PREPARE*/
                  uint;  /* T4 [ms] Time-out of the non-volatile memory programming: PROGRAM_CLEAR*/
                  uint;  /* T5 [ms] Time-out of the non-volatile memory programming: PROGRAM, PROGRAM_RESET, PROGRAM_MAX*/
                  uint;  /* T6 [ms] Time-out of the command CONNECT(USER_DEFINED)*/
                  uint;  /* T7 [ms] Time-out of the pre-action*/
                  uchar;  /* MAX_CTO: Indicates the maximum length of a CTO packet in bytes. */
                  uint;  /* MAX_DTO: Indicates the maximum length of a DTO packet in bytes. */
                  enum {
                    "BYTE_ORDER_MSB_LAST" = 0,
                    "BYTE_ORDER_MSB_FIRST" = 1
                  };  /* BYTE_ORDER: BYTE_ORDER_MSB_LAST = Intel, BYTE_ORDER_MSB_FIRST = Motorola*/
                  enum {
                    "ADDRESS_GRANULARITY_BYTE" = 1,
                    "ADDRESS_GRANULARITY_WORD" = 2,
                    "ADDRESS_GRANULARITY_DWORD" = 4
                  };  /*The address granularity indicates the size of an element contained at a single address.*/
                  taggedstruct {
                    ("OPTIONAL_CMD" enum {
                      "GET_COMM_MODE_INFO" = 251,
                      "GET_ID" = 250,
                      "SET_REQUEST" = 249,
                      "GET_SEED" = 248,
                      "UNLOCK" = 247,
                      "SET_MTA" = 246,
                      "UPLOAD" = 245,
                      "SHORT_UPLOAD" = 244,
                      "BUILD_CHECKSUM" = 243,
                      "TRANSPORT_LAYER_CMD" = 242,
                      "USER_CMD" = 241,
                      "DOWNLOAD" = 240,
                      "DOWNLOAD_NEXT" = 239,
                      "DOWNLOAD_MAX" = 238,
                      "SHORT_DOWNLOAD" = 237,
                      "MODIFY_BITS" = 236,
                      "SET_CAL_PAGE" = 235,
                      "GET_CAL_PAGE" = 234,
                      "GET_PAG_PROCESSOR_INFO" = 233,
                      "GET_SEGMENT_INFO" = 232,
                      "GET_PAGE_INFO" = 231,
                      "SET_SEGMENT_MODE" = 230,
                      "GET_SEGMENT_MODE" = 229,
                      "COPY_CAL_PAGE" = 228,
                      "CLEAR_DAQ_LIST" = 227,
                      "SET_DAQ_PTR" = 226,
                      "WRITE_DAQ" = 225,
                      "SET_DAQ_LIST_MODE" = 224,
                      "GET_DAQ_LIST_MODE" = 223,
                      "START_STOP_DAQ_LIST" = 222,
                      "START_STOP_SYNCH" = 221,
                      "GET_DAQ_CLOCK" = 220,
                      "READ_DAQ" = 219,
                      "GET_DAQ_PROCESSOR_INFO" = 218,
                      "GET_DAQ_RESOLUTION_INFO" = 217,
                      "GET_DAQ_LIST_INFO" = 216,
                      "GET_DAQ_EVENT_INFO" = 215,
                      "FREE_DAQ" = 214,
                      "ALLOC_DAQ" = 213,
                      "ALLOC_ODT" = 212,
                      "ALLOC_ODT_ENTRY" = 211,
                      "PROGRAM_START" = 210,
                      "PROGRAM_CLEAR" = 209,
                      "PROGRAM" = 208,
                      "PROGRAM_RESET" = 207,
                      "GET_PGM_PROCESSOR_INFO" = 206,
                      "GET_SECTOR_INFO" = 205,
                      "PROGRAM_PREPARE" = 204,
                      "PROGRAM_FORMAT" = 203,
                      "PROGRAM_NEXT" = 202,
                      "PROGRAM_MAX" = 201,
                      "PROGRAM_VERIFY" = 200
                    })*;  /* XCP-Code of optional command supported by the slave*/
                    "COMMUNICATION_MODE_SUPPORTED" taggedunion {
                      "BLOCK" taggedstruct {
                        "SLAVE" ;
                        "MASTER" struct {
                          uchar;  /* MAX_BS: Indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                          uchar;  /* MIN_ST: Indicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                        };
                      };
                      "INTERLEAVED" uchar;  /* QUEUE_SIZE: indicates the maximum number of consecutive command packets the master can send to the receipt queue of the slave*/
                    };
                    "SEED_AND_KEY_EXTERNAL_FUNCTION" char[256];  /* Name of the Seed&Key function*/
                  };
                };
                block "SEGMENT" struct Segment {
                  uchar;  /* SEGMENT_NUMBER: Logical data segment number*/
                  uchar;  /* Total number of available pages */
                  uchar;  /* ADDRESS_EXTENSION: Address extension for this SEGMENT*/
                  uchar;  /* COMPRESSION_METHOD: The COMPRESSION_x flags indicate which compression state of the incoming data the slave can process*/
                  uchar;  /* ENCRYPTION_METHOD: The  ENCRYPTION_x flags indicate which encryption state of the incoming data the slave can process.*/
                  taggedstruct {
                    block "CHECKSUM" struct {
                      enum {
                        "XCP_ADD_11" = 1,
                        "XCP_ADD_12" = 2,
                        "XCP_ADD_14" = 3,
                        "XCP_ADD_22" = 4,
                        "XCP_ADD_24" = 5,
                        "XCP_ADD_44" = 6,
                        "XCP_CRC_16" = 7,
                        "XCP_CRC_16_CITT" = 8,
                        "XCP_CRC_32" = 9,
                        "XCP_USER_DEFINED" = 255
                      };  /* Checksum type*/
                      taggedstruct {
                        "MAX_BLOCK_SIZE" ulong;  /* Maximum block size for checksum calculation */
                        "EXTERNAL_FUNCTION" char[256];  /* Name of the Checksum.DLL */
                      };
                    };
                    (block "PAGE" struct {
                      uchar;  /* PAGE_NUMBER: Logical page number*/
                      enum {
                        "ECU_ACCESS_NOT_ALLOWED" = 0,
                        "ECU_ACCESS_WITHOUT_XCP_ONLY" = 1,
                        "ECU_ACCESS_WITH_XCP_ONLY" = 2,
                        "ECU_ACCESS_DONT_CARE" = 3
                      };  /*The ECU_ACCESS_x  flags indicate whether and how the ECU can access this page.*/
                      enum {
                        "XCP_READ_ACCESS_NOT_ALLOWED" = 0,
                        "XCP_READ_ACCESS_WITHOUT_ECU_ONLY" = 1,
                        "XCP_READ_ACCESS_WITH_ECU_ONLY" = 2,
                        "XCP_READ_ACCESS_DONT_CARE" = 3
                      };  /*The XCP_x_ACCESS_y flags indicate whether and how the XCP master can access this page.*/
                      enum {
                        "XCP_WRITE_ACCESS_NOT_ALLOWED" = 0,
                        "XCP_WRITE_ACCESS_WITHOUT_ECU_ONLY" = 1,
                        "XCP_WRITE_ACCESS_WITH_ECU_ONLY" = 2,
                        "XCP_WRITE_ACCESS_DONT_CARE" = 3
                      };  /*The XCP_WRITE_ACCESS_x flags indicate whether the  X CP master can write to this PAGE*/
                      taggedstruct {
                        "INIT_SEGMENT" uchar;  /* references segment that initialises this page */
                      };
                    })*;  /* PAGES for this SEGMENT */
                    (block "ADDRESS_MAPPING" struct {
                      ulong;  /* source address */
                      ulong;  /* destination address */
                      ulong;  /* length */
                    })*;
                    "PGM_VERIFY" ulong;  /* verification value for PGM */
                  };
                };
                block "DAQ" struct Daq {
                  enum {
                    "STATIC" = 0,
                    "DYNAMIC" = 1
                  };  /*The flag indicates whether the DAQ lists that are not PREDEFINED shall be configured statically or dynamically*/
                  uint;  /* MAX_DAQ: Total number of available DAQ lists */
                  uint;  /* MAX_EVENT_CHANNEL: Total number of available event channels*/
                  uchar;  /* MIN_DAQ: Total number of predefined DAQ lists */
                  enum {
                    "OPTIMISATION_TYPE_DEFAULT" = 0,
                    "OPTIMISATION_TYPE_ODT_TYPE_16" = 1,
                    "OPTIMISATION_TYPE_ODT_TYPE_32" = 2,
                    "OPTIMISATION_TYPE_ODT_TYPE_64" = 3,
                    "OPTIMISATION_TYPE_ODT_TYPE_ALIGNMENT" = 4,
                    "OPTIMISATION_TYPE_MAX_ENTRY_SIZE" = 5
                  };  /* Indicate the Type of Optimisation Method the master preferably should use.*/
                  enum {
                    "ADDRESS_EXTENSION_FREE" = 0,
                    "ADDRESS_EXTENSION_ODT" = 1,
                    "ADDRESS_EXTENSION_DAQ" = 3
                  };  /*The flag indicates whether the address extension of all entries within one ODT or within one DAQ must be the same. */
                  enum {
                    "IDENTIFICATION_FIELD_TYPE_ABSOLUTE" = 0,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE" = 1,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD" = 2,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED" = 3
                  };  /* The type of Identification Field the slave will use when transferring DAQ Packets to the master*/
                  enum {
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE" = 1,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_WORD" = 2,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DWORD" = 4,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DLONG" = 8
                  };  /* Granularity for size of ODT entry */
                  uchar;  /* MAX_ODT_ENTRY_SIZE_DAQ Maximum size of ODT entry (DIRECTION = DAQ) */
                  enum {
                    "NO_OVERLOAD_INDICATION" = 0,
                    "OVERLOAD_INDICATION_PID" = 1,
                    "OVERLOAD_INDICATION_EVENT" = 2
                  };  /*OVERLOAD_INDICATION_PID: This means the higest bit is set in the PID, when an overload occurs
OVERLOAD_INDICATION_EVENT: This means an event is set, when an overload occurs*/
                  taggedstruct {
                    "PRESCALER_SUPPORTED" ;  /*This flag indicates that all DAQ lists support the prescaler for reducing the transmission period.*/
                    "RESUME_SUPPORTED" ;  /*This  flag indicates that all DAQ lists can be put in RESUME mode. */
                    block "STIM" struct {
                      enum {
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE" = 1,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD" = 2,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_DWORD" = 4,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_DLONG" = 8
                      };  /* Granularity for size of ODT entry direction STIM*/
                      uchar;  /* MAX_ODT_ENTRY_SIZE_STIM Maximum size of ODT entry (DIRECTION = STIM)*/
                      taggedstruct {
                        "BIT_STIM_SUPPORTED" ;  /*The flag indicates  whether  bitwise  data  stimulation  through BIT_OFFSET in WRITE_DAQ is supported.*/
                      };
                    };
                    block "TIMESTAMP_SUPPORTED" struct {
                      uint;  /*The timestamp will increment by TIMESTAMP_TICKS per unit and wrap around if an overflow occurs. */
                      enum {
                        "NO_TIME_STAMP" = 0,
                        "SIZE_BYTE" = 1,
                        "SIZE_WORD" = 2,
                        "SIZE_DWORD" = 4
                      };  /*Timestamp size in bytes*/
                      enum {
                        "UNIT_1NS" = 0,
                        "UNIT_10NS" = 1,
                        "UNIT_100NS" = 2,
                        "UNIT_1US" = 3,
                        "UNIT_10US" = 4,
                        "UNIT_100US" = 5,
                        "UNIT_1MS" = 6,
                        "UNIT_10MS" = 7,
                        "UNIT_100MS" = 8,
                        "UNIT_1S" = 9
                      };  /*Ticks per unit*/
                      taggedstruct {
                        "TIMESTAMP_FIXED" ;
                      };  /* TIMESTAMP_FIXED flag indicates that the Slave always will send DTO Packets in time stamped mode. */
                    };
                    "PID_OFF_SUPPORTED" ;  /*Flag in DAQ_PROPERTIES indicates that transfer of DTO Packets without Identification Field is possible. */
                    (block "DAQ_LIST" struct {
                      uint;  /* DAQ_LIST_NUMBER  is in the range [0,1,..MIN_DAQ-1]. */
                      taggedstruct {
                        "DAQ_LIST_TYPE" enum {
                          "DAQ" = 1,
                          "STIM" = 2,
                          "DAQ_STIM" = 3
                        };  /* DAQ: DIRECTION = DAQ only 
 STIM: DIRECTION = STIM only 
 DAQ_STIM: both directions are possible */
                        "MAX_ODT" uchar;  /*Number of ODTs in this DAQ list */
                        "MAX_ODT_ENTRIES" uchar;  /*Maximum number of entries in an ODT*/
                        "FIRST_PID" uchar;  /*FIRST_PID: Is the PID in the DTO Packet of the first ODT transferred by this DAQ list.*/
                        "EVENT_FIXED" uint;  /*The flag indicates that the Event Channel for this DAQ list can not be changed. */
                        block "PREDEFINED" taggedstruct {
                          (block "ODT" struct {
                            uchar;  /* ODT number */
                            taggedstruct {
                              ("ODT_ENTRY" struct {
                                uchar;  /* ODT_ENTRY number */
                                ulong;  /* address of element */
                                uchar;  /* address extension of element */
                                uchar;  /* size of element [AG] */
                                uchar;  /* BIT_OFFSET */
                              })*;
                            };
                          })*;
                        };  /*PREDEFINED;The DAQ list is predefined and fixed in the slave devices memory.*/
                      };
                    })*;
                    (block "EVENT" struct {
                      char[101];  /* EVENT_CHANNEL_NAME */
                      char[9];  /* EVENT_CHANNEL_SHORT_NAME */
                      uint;  /* EVENT_CHANNEL_NUMBER*/
                      enum {
                        "DAQ" = 1,
                        "STIM" = 2,
                        "DAQ_STIM" = 3
                      };  /* DAQ: only DAQ_LISTs with DIRECTION = DAQ 
 STIM: only DAQ_LISTs with DIRECTION = STIM 
 DAQ_STIM both kind of DAQ_LISTs*/
                      uchar;  /* MAX_DAQ_LIST:Maximum number of DAQ lists in this event channel */
                      uchar;  /* TIME_CYCLE: Event channel time cycle */
                      uchar;  /* TIME_UNIT: Event channel time unit*/
                      uchar;  /* PRIORITY:The event channel with event channel priority = FF has the highest priority */
                    })*;
                  };
                };
                block "PAG" struct Pag {
                  uchar;  /* MAX_SEGMENTS: Is the total number of segments in the slave device*/
                  taggedstruct {
                    "FREEZE_SUPPORTED" ;  /*This flag indicates that all SEGMENTS can be put in FREEZE */
                  };
                };
                block "PGM" struct Pgm {
                  enum {
                    "PGM_MODE_ABSOLUTE" = 1,
                    "PGM_MODE_FUNCTIONAL" = 2,
                    "PGM_MODE_ABSOLUTE_AND_FUNCTIONAL" = 3
                  };  /*The  ABSOLUTE_MODE  and  FUNCTIONAL_MODE  flags  indicate  the  clear/programming mode that can be used */
                  uchar;  /* MAX_SECTORS: Total number of available sectors */
                  uchar;  /* MAX_CTO_PGM: Maximum CTO size for PGM */
                  taggedstruct {
                    (block "SECTOR" struct {
                      char[101];  /* SECTOR_NAME */
                      uchar;  /* SECTOR_NUMBER*/
                      ulong;  /* Start address for this SECTOR */
                      ulong;  /* Length of this SECTOR [AG] */
                      uchar;  /* CLEAR_SEQUENCE_NUMBER: The Clear Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
                      uchar;  /* PROGRAM_SEQUENCE_NUMBER: The Program Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
                      uchar;  /* PROGRAM_METHOD: The work flow depends on mode  absolute access or functional access*/
                    })*;
                    "COMMUNICATION_MODE_SUPPORTED" taggedunion {
                      "BLOCK" taggedstruct {
                        "SLAVE" ;  /*This flag indicates whether the Slave Block Mode is available during Programming. */
                        "MASTER" struct {
                          uchar;  /* MAX_BS_PGM:MAX_BS: indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                          uchar;  /* MIN_ST_PGM ndicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                        };  /*This flag indicates whether the Master Block Mode is available */
                      };
                      "INTERLEAVED" uchar;  /* QUEUE_SIZE_PGM: This value describe the total count of bytes for this queue*/
                    };
                  };
                };
                block "DAQ_EVENT" taggedunion Daq_Event {
                  "FIXED_EVENT_LIST" taggedstruct {
                    ("EVENT" uint)*;
                  };
                  "VARIABLE" taggedstruct {
                    block "AVAILABLE_EVENT_LIST" taggedstruct {
                      ("EVENT" uint)*;
                    };
                    block "DEFAULT_EVENT_LIST" taggedstruct {
                      ("EVENT" uint)*;
                    };
                  };
                };
              };  /* overruling of default */
            };
            block "XCP_ON_UDP_IP" struct {
              struct UDP_Parameters {
                uint;  /* XCP on UDP version, currently 0x0100 */
                uint;  /* PORT */
                taggedunion {
                  "HOST_NAME" char[256];  /*Name of the host like localhost*/
                  "ADDRESS" char[15];  /* IP address like 127.0.0.1*/
                };
              };  /* specific for UDP_IP   */
              taggedstruct Common_Parameters {
                block "PROTOCOL_LAYER" struct Protocol_Layer {
                  uint;  /* XCP protocol layer version, current 0x100*/
                  uint;  /* T1 [ms] Time-out of the standard CTO, for example CONNECT*/
                  uint;  /* T2 [ms] Time-out of the checksum calculation*/
                  uint;  /* T3 [ms] Time-out of the non-volatile memory programming: PROGRAM_START, PROGRAM_VERIFY, PROGRAM_PREPARE*/
                  uint;  /* T4 [ms] Time-out of the non-volatile memory programming: PROGRAM_CLEAR*/
                  uint;  /* T5 [ms] Time-out of the non-volatile memory programming: PROGRAM, PROGRAM_RESET, PROGRAM_MAX*/
                  uint;  /* T6 [ms] Time-out of the command CONNECT(USER_DEFINED)*/
                  uint;  /* T7 [ms] Time-out of the pre-action*/
                  uchar;  /* MAX_CTO: Indicates the maximum length of a CTO packet in bytes. */
                  uint;  /* MAX_DTO: Indicates the maximum length of a DTO packet in bytes. */
                  enum {
                    "BYTE_ORDER_MSB_LAST" = 0,
                    "BYTE_ORDER_MSB_FIRST" = 1
                  };  /* BYTE_ORDER: BYTE_ORDER_MSB_LAST = Intel, BYTE_ORDER_MSB_FIRST = Motorola*/
                  enum {
                    "ADDRESS_GRANULARITY_BYTE" = 1,
                    "ADDRESS_GRANULARITY_WORD" = 2,
                    "ADDRESS_GRANULARITY_DWORD" = 4
                  };  /*The address granularity indicates the size of an element contained at a single address.*/
                  taggedstruct {
                    ("OPTIONAL_CMD" enum {
                      "GET_COMM_MODE_INFO" = 251,
                      "GET_ID" = 250,
                      "SET_REQUEST" = 249,
                      "GET_SEED" = 248,
                      "UNLOCK" = 247,
                      "SET_MTA" = 246,
                      "UPLOAD" = 245,
                      "SHORT_UPLOAD" = 244,
                      "BUILD_CHECKSUM" = 243,
                      "TRANSPORT_LAYER_CMD" = 242,
                      "USER_CMD" = 241,
                      "DOWNLOAD" = 240,
                      "DOWNLOAD_NEXT" = 239,
                      "DOWNLOAD_MAX" = 238,
                      "SHORT_DOWNLOAD" = 237,
                      "MODIFY_BITS" = 236,
                      "SET_CAL_PAGE" = 235,
                      "GET_CAL_PAGE" = 234,
                      "GET_PAG_PROCESSOR_INFO" = 233,
                      "GET_SEGMENT_INFO" = 232,
                      "GET_PAGE_INFO" = 231,
                      "SET_SEGMENT_MODE" = 230,
                      "GET_SEGMENT_MODE" = 229,
                      "COPY_CAL_PAGE" = 228,
                      "CLEAR_DAQ_LIST" = 227,
                      "SET_DAQ_PTR" = 226,
                      "WRITE_DAQ" = 225,
                      "SET_DAQ_LIST_MODE" = 224,
                      "GET_DAQ_LIST_MODE" = 223,
                      "START_STOP_DAQ_LIST" = 222,
                      "START_STOP_SYNCH" = 221,
                      "GET_DAQ_CLOCK" = 220,
                      "READ_DAQ" = 219,
                      "GET_DAQ_PROCESSOR_INFO" = 218,
                      "GET_DAQ_RESOLUTION_INFO" = 217,
                      "GET_DAQ_LIST_INFO" = 216,
                      "GET_DAQ_EVENT_INFO" = 215,
                      "FREE_DAQ" = 214,
                      "ALLOC_DAQ" = 213,
                      "ALLOC_ODT" = 212,
                      "ALLOC_ODT_ENTRY" = 211,
                      "PROGRAM_START" = 210,
                      "PROGRAM_CLEAR" = 209,
                      "PROGRAM" = 208,
                      "PROGRAM_RESET" = 207,
                      "GET_PGM_PROCESSOR_INFO" = 206,
                      "GET_SECTOR_INFO" = 205,
                      "PROGRAM_PREPARE" = 204,
                      "PROGRAM_FORMAT" = 203,
                      "PROGRAM_NEXT" = 202,
                      "PROGRAM_MAX" = 201,
                      "PROGRAM_VERIFY" = 200
                    })*;  /* XCP-Code of optional command supported by the slave*/
                    "COMMUNICATION_MODE_SUPPORTED" taggedunion {
                      "BLOCK" taggedstruct {
                        "SLAVE" ;
                        "MASTER" struct {
                          uchar;  /* MAX_BS: Indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                          uchar;  /* MIN_ST: Indicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                        };
                      };
                      "INTERLEAVED" uchar;  /* QUEUE_SIZE: indicates the maximum number of consecutive command packets the master can send to the receipt queue of the slave*/
                    };
                    "SEED_AND_KEY_EXTERNAL_FUNCTION" char[256];  /* Name of the Seed&Key function*/
                  };
                };
                block "SEGMENT" struct Segment {
                  uchar;  /* SEGMENT_NUMBER: Logical data segment number*/
                  uchar;  /* Total number of available pages */
                  uchar;  /* ADDRESS_EXTENSION: Address extension for this SEGMENT*/
                  uchar;  /* COMPRESSION_METHOD: The COMPRESSION_x flags indicate which compression state of the incoming data the slave can process*/
                  uchar;  /* ENCRYPTION_METHOD: The  ENCRYPTION_x flags indicate which encryption state of the incoming data the slave can process.*/
                  taggedstruct {
                    block "CHECKSUM" struct {
                      enum {
                        "XCP_ADD_11" = 1,
                        "XCP_ADD_12" = 2,
                        "XCP_ADD_14" = 3,
                        "XCP_ADD_22" = 4,
                        "XCP_ADD_24" = 5,
                        "XCP_ADD_44" = 6,
                        "XCP_CRC_16" = 7,
                        "XCP_CRC_16_CITT" = 8,
                        "XCP_CRC_32" = 9,
                        "XCP_USER_DEFINED" = 255
                      };  /* Checksum type*/
                      taggedstruct {
                        "MAX_BLOCK_SIZE" ulong;  /* Maximum block size for checksum calculation */
                        "EXTERNAL_FUNCTION" char[256];  /* Name of the Checksum.DLL */
                      };
                    };
                    (block "PAGE" struct {
                      uchar;  /* PAGE_NUMBER: Logical page number*/
                      enum {
                        "ECU_ACCESS_NOT_ALLOWED" = 0,
                        "ECU_ACCESS_WITHOUT_XCP_ONLY" = 1,
                        "ECU_ACCESS_WITH_XCP_ONLY" = 2,
                        "ECU_ACCESS_DONT_CARE" = 3
                      };  /*The ECU_ACCESS_x  flags indicate whether and how the ECU can access this page.*/
                      enum {
                        "XCP_READ_ACCESS_NOT_ALLOWED" = 0,
                        "XCP_READ_ACCESS_WITHOUT_ECU_ONLY" = 1,
                        "XCP_READ_ACCESS_WITH_ECU_ONLY" = 2,
                        "XCP_READ_ACCESS_DONT_CARE" = 3
                      };  /*The XCP_x_ACCESS_y flags indicate whether and how the XCP master can access this page.*/
                      enum {
                        "XCP_WRITE_ACCESS_NOT_ALLOWED" = 0,
                        "XCP_WRITE_ACCESS_WITHOUT_ECU_ONLY" = 1,
                        "XCP_WRITE_ACCESS_WITH_ECU_ONLY" = 2,
                        "XCP_WRITE_ACCESS_DONT_CARE" = 3
                      };  /*The XCP_WRITE_ACCESS_x flags indicate whether the  X CP master can write to this PAGE*/
                      taggedstruct {
                        "INIT_SEGMENT" uchar;  /* references segment that initialises this page */
                      };
                    })*;  /* PAGES for this SEGMENT */
                    (block "ADDRESS_MAPPING" struct {
                      ulong;  /* source address */
                      ulong;  /* destination address */
                      ulong;  /* length */
                    })*;
                    "PGM_VERIFY" ulong;  /* verification value for PGM */
                  };
                };
                block "DAQ" struct Daq {
                  enum {
                    "STATIC" = 0,
                    "DYNAMIC" = 1
                  };  /*The flag indicates whether the DAQ lists that are not PREDEFINED shall be configured statically or dynamically*/
                  uint;  /* MAX_DAQ: Total number of available DAQ lists */
                  uint;  /* MAX_EVENT_CHANNEL: Total number of available event channels*/
                  uchar;  /* MIN_DAQ: Total number of predefined DAQ lists */
                  enum {
                    "OPTIMISATION_TYPE_DEFAULT" = 0,
                    "OPTIMISATION_TYPE_ODT_TYPE_16" = 1,
                    "OPTIMISATION_TYPE_ODT_TYPE_32" = 2,
                    "OPTIMISATION_TYPE_ODT_TYPE_64" = 3,
                    "OPTIMISATION_TYPE_ODT_TYPE_ALIGNMENT" = 4,
                    "OPTIMISATION_TYPE_MAX_ENTRY_SIZE" = 5
                  };  /* Indicate the Type of Optimisation Method the master preferably should use.*/
                  enum {
                    "ADDRESS_EXTENSION_FREE" = 0,
                    "ADDRESS_EXTENSION_ODT" = 1,
                    "ADDRESS_EXTENSION_DAQ" = 3
                  };  /*The flag indicates whether the address extension of all entries within one ODT or within one DAQ must be the same. */
                  enum {
                    "IDENTIFICATION_FIELD_TYPE_ABSOLUTE" = 0,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE" = 1,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD" = 2,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED" = 3
                  };  /* The type of Identification Field the slave will use when transferring DAQ Packets to the master*/
                  enum {
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE" = 1,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_WORD" = 2,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DWORD" = 4,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DLONG" = 8
                  };  /* Granularity for size of ODT entry */
                  uchar;  /* MAX_ODT_ENTRY_SIZE_DAQ Maximum size of ODT entry (DIRECTION = DAQ) */
                  enum {
                    "NO_OVERLOAD_INDICATION" = 0,
                    "OVERLOAD_INDICATION_PID" = 1,
                    "OVERLOAD_INDICATION_EVENT" = 2
                  };  /*OVERLOAD_INDICATION_PID: This means the higest bit is set in the PID, when an overload occurs
OVERLOAD_INDICATION_EVENT: This means an event is set, when an overload occurs*/
                  taggedstruct {
                    "PRESCALER_SUPPORTED" ;  /*This flag indicates that all DAQ lists support the prescaler for reducing the transmission period.*/
                    "RESUME_SUPPORTED" ;  /*This  flag indicates that all DAQ lists can be put in RESUME mode. */
                    block "STIM" struct {
                      enum {
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE" = 1,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD" = 2,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_DWORD" = 4,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_DLONG" = 8
                      };  /* Granularity for size of ODT entry direction STIM*/
                      uchar;  /* MAX_ODT_ENTRY_SIZE_STIM Maximum size of ODT entry (DIRECTION = STIM)*/
                      taggedstruct {
                        "BIT_STIM_SUPPORTED" ;  /*The flag indicates  whether  bitwise  data  stimulation  through BIT_OFFSET in WRITE_DAQ is supported.*/
                      };
                    };
                    block "TIMESTAMP_SUPPORTED" struct {
                      uint;  /*The timestamp will increment by TIMESTAMP_TICKS per unit and wrap around if an overflow occurs. */
                      enum {
                        "NO_TIME_STAMP" = 0,
                        "SIZE_BYTE" = 1,
                        "SIZE_WORD" = 2,
                        "SIZE_DWORD" = 4
                      };  /*Timestamp size in bytes*/
                      enum {
                        "UNIT_1NS" = 0,
                        "UNIT_10NS" = 1,
                        "UNIT_100NS" = 2,
                        "UNIT_1US" = 3,
                        "UNIT_10US" = 4,
                        "UNIT_100US" = 5,
                        "UNIT_1MS" = 6,
                        "UNIT_10MS" = 7,
                        "UNIT_100MS" = 8,
                        "UNIT_1S" = 9
                      };  /*Ticks per unit*/
                      taggedstruct {
                        "TIMESTAMP_FIXED" ;
                      };  /* TIMESTAMP_FIXED flag indicates that the Slave always will send DTO Packets in time stamped mode. */
                    };
                    "PID_OFF_SUPPORTED" ;  /*Flag in DAQ_PROPERTIES indicates that transfer of DTO Packets without Identification Field is possible. */
                    (block "DAQ_LIST" struct {
                      uint;  /* DAQ_LIST_NUMBER  is in the range [0,1,..MIN_DAQ-1]. */
                      taggedstruct {
                        "DAQ_LIST_TYPE" enum {
                          "DAQ" = 1,
                          "STIM" = 2,
                          "DAQ_STIM" = 3
                        };  /* DAQ: DIRECTION = DAQ only 
 STIM: DIRECTION = STIM only 
 DAQ_STIM: both directions are possible */
                        "MAX_ODT" uchar;  /*Number of ODTs in this DAQ list */
                        "MAX_ODT_ENTRIES" uchar;  /*Maximum number of entries in an ODT*/
                        "FIRST_PID" uchar;  /*FIRST_PID: Is the PID in the DTO Packet of the first ODT transferred by this DAQ list.*/
                        "EVENT_FIXED" uint;  /*The flag indicates that the Event Channel for this DAQ list can not be changed. */
                        block "PREDEFINED" taggedstruct {
                          (block "ODT" struct {
                            uchar;  /* ODT number */
                            taggedstruct {
                              ("ODT_ENTRY" struct {
                                uchar;  /* ODT_ENTRY number */
                                ulong;  /* address of element */
                                uchar;  /* address extension of element */
                                uchar;  /* size of element [AG] */
                                uchar;  /* BIT_OFFSET */
                              })*;
                            };
                          })*;
                        };  /*PREDEFINED;The DAQ list is predefined and fixed in the slave devices memory.*/
                      };
                    })*;
                    (block "EVENT" struct {
                      char[101];  /* EVENT_CHANNEL_NAME */
                      char[9];  /* EVENT_CHANNEL_SHORT_NAME */
                      uint;  /* EVENT_CHANNEL_NUMBER*/
                      enum {
                        "DAQ" = 1,
                        "STIM" = 2,
                        "DAQ_STIM" = 3
                      };  /* DAQ: only DAQ_LISTs with DIRECTION = DAQ 
 STIM: only DAQ_LISTs with DIRECTION = STIM 
 DAQ_STIM both kind of DAQ_LISTs*/
                      uchar;  /* MAX_DAQ_LIST:Maximum number of DAQ lists in this event channel */
                      uchar;  /* TIME_CYCLE: Event channel time cycle */
                      uchar;  /* TIME_UNIT: Event channel time unit*/
                      uchar;  /* PRIORITY:The event channel with event channel priority = FF has the highest priority */
                    })*;
                  };
                };
                block "PAG" struct Pag {
                  uchar;  /* MAX_SEGMENTS: Is the total number of segments in the slave device*/
                  taggedstruct {
                    "FREEZE_SUPPORTED" ;  /*This flag indicates that all SEGMENTS can be put in FREEZE */
                  };
                };
                block "PGM" struct Pgm {
                  enum {
                    "PGM_MODE_ABSOLUTE" = 1,
                    "PGM_MODE_FUNCTIONAL" = 2,
                    "PGM_MODE_ABSOLUTE_AND_FUNCTIONAL" = 3
                  };  /*The  ABSOLUTE_MODE  and  FUNCTIONAL_MODE  flags  indicate  the  clear/programming mode that can be used */
                  uchar;  /* MAX_SECTORS: Total number of available sectors */
                  uchar;  /* MAX_CTO_PGM: Maximum CTO size for PGM */
                  taggedstruct {
                    (block "SECTOR" struct {
                      char[101];  /* SECTOR_NAME */
                      uchar;  /* SECTOR_NUMBER*/
                      ulong;  /* Start address for this SECTOR */
                      ulong;  /* Length of this SECTOR [AG] */
                      uchar;  /* CLEAR_SEQUENCE_NUMBER: The Clear Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
                      uchar;  /* PROGRAM_SEQUENCE_NUMBER: The Program Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
                      uchar;  /* PROGRAM_METHOD: The work flow depends on mode  absolute access or functional access*/
                    })*;
                    "COMMUNICATION_MODE_SUPPORTED" taggedunion {
                      "BLOCK" taggedstruct {
                        "SLAVE" ;  /*This flag indicates whether the Slave Block Mode is available during Programming. */
                        "MASTER" struct {
                          uchar;  /* MAX_BS_PGM:MAX_BS: indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                          uchar;  /* MIN_ST_PGM ndicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                        };  /*This flag indicates whether the Master Block Mode is available */
                      };
                      "INTERLEAVED" uchar;  /* QUEUE_SIZE_PGM: This value describe the total count of bytes for this queue*/
                    };
                  };
                };
                block "DAQ_EVENT" taggedunion Daq_Event {
                  "FIXED_EVENT_LIST" taggedstruct {
                    ("EVENT" uint)*;
                  };
                  "VARIABLE" taggedstruct {
                    block "AVAILABLE_EVENT_LIST" taggedstruct {
                      ("EVENT" uint)*;
                    };
                    block "DEFAULT_EVENT_LIST" taggedstruct {
                      ("EVENT" uint)*;
                    };
                  };
                };
              };  /* overruling of default */
            };
            block "XCP_ON_USB" struct {
              struct USB_Parameters {
                uint;  /* XCP on USB version  
 e.g. "1.0" = 0x0100 */
                uint;  /* Vendor ID                       */
                uint;  /* Product ID                      */
                uchar;  /* Number of interface             */
                enum {
                  "HEADER_LEN_BYTE" = 0,
                  "HEADER_LEN_CTR_BYTE" = 1,
                  "HEADER_LEN_FILL_BYTE" = 2,
                  "HEADER_LEN_WORD" = 3,
                  "HEADER_LEN_CTR_WORD" = 4,
                  "HEADER_LEN_FILL_WORD" = 5
                };  /* XCP packet header */
                taggedunion {
                  block "OUT_EP_CMD_STIM" struct ep_parameters {
                    uchar;  /* ENDPOINT_NUMBER, not endpoint address */
                    enum {
                      "BULK_TRANSFER" = 2,
                      "INTERRUPT_TRANSFER" = 3
                    };
                    uint;  /* wMaxPacketSize: Maximum packet  
 size of endpoint in bytes       */
                    uchar;  /* bInterval: polling of endpoint  */
                    enum {
                      "MESSAGE_PACKING_SINGLE" = 0,
                      "MESSAGE_PACKING_MULTIPLE" = 1,
                      "MESSAGE_PACKING_STREAMING" = 2
                    };  /* Packing of XCP Messages         
 SINGLE: Single per USB data packet    
 MULTIPLE: Multiple per USB data packet  
 STREAMING: No restriction by packet sizes*/
                    enum {
                      "ALIGNMENT_8_BIT" = 0,
                      "ALIGNMENT_16_BIT" = 1,
                      "ALIGNMENT_32_BIT" = 2,
                      "ALIGNMENT_64_BIT" = 3
                    };  /* Alignment mandatory for all packing types*/
                    taggedstruct {
                      "RECOMMENDED_HOST_BUFSIZE" uint;  /* Recommended size for the host 
 buffer size. The size is defined
 as multiple of wMaxPacketSize.  */
                    };
                  };  /* OUT-EP for CMD and STIM (if not specified otherwise)*/
                };
                taggedunion {
                  block "IN_EP_RESERR_DAQ_EVSERV" struct ep_parameters {
                    uchar;  /* ENDPOINT_NUMBER, not endpoint address */
                    enum {
                      "BULK_TRANSFER" = 2,
                      "INTERRUPT_TRANSFER" = 3
                    };
                    uint;  /* wMaxPacketSize: Maximum packet  
 size of endpoint in bytes       */
                    uchar;  /* bInterval: polling of endpoint  */
                    enum {
                      "MESSAGE_PACKING_SINGLE" = 0,
                      "MESSAGE_PACKING_MULTIPLE" = 1,
                      "MESSAGE_PACKING_STREAMING" = 2
                    };  /* Packing of XCP Messages         
 SINGLE: Single per USB data packet    
 MULTIPLE: Multiple per USB data packet  
 STREAMING: No restriction by packet sizes*/
                    enum {
                      "ALIGNMENT_8_BIT" = 0,
                      "ALIGNMENT_16_BIT" = 1,
                      "ALIGNMENT_32_BIT" = 2,
                      "ALIGNMENT_64_BIT" = 3
                    };  /* Alignment mandatory for all packing types*/
                    taggedstruct {
                      "RECOMMENDED_HOST_BUFSIZE" uint;  /* Recommended size for the host 
 buffer size. The size is defined
 as multiple of wMaxPacketSize.  */
                    };
                  };  /* IN-EP for RES/ERR, 
 DAQ (if not specified otherwise) and  
 EV/SERV (if not specified otherwise)  */
                };
                taggedstruct {
                  "ALTERNATE_SETTING_NO" uchar;  /* Number of alternate setting   */
                  "INTERFACE_STRING_DESCRIPTOR" char[101];  /* String Descriptor of XCP interface*/
                  (block "OUT_EP_ONLY_STIM" struct ep_parameters {
                    uchar;  /* ENDPOINT_NUMBER, not endpoint address */
                    enum {
                      "BULK_TRANSFER" = 2,
                      "INTERRUPT_TRANSFER" = 3
                    };
                    uint;  /* wMaxPacketSize: Maximum packet  
 size of endpoint in bytes       */
                    uchar;  /* bInterval: polling of endpoint  */
                    enum {
                      "MESSAGE_PACKING_SINGLE" = 0,
                      "MESSAGE_PACKING_MULTIPLE" = 1,
                      "MESSAGE_PACKING_STREAMING" = 2
                    };  /* Packing of XCP Messages         
 SINGLE: Single per USB data packet    
 MULTIPLE: Multiple per USB data packet  
 STREAMING: No restriction by packet sizes*/
                    enum {
                      "ALIGNMENT_8_BIT" = 0,
                      "ALIGNMENT_16_BIT" = 1,
                      "ALIGNMENT_32_BIT" = 2,
                      "ALIGNMENT_64_BIT" = 3
                    };  /* Alignment mandatory for all packing types*/
                    taggedstruct {
                      "RECOMMENDED_HOST_BUFSIZE" uint;  /* Recommended size for the host 
 buffer size. The size is defined
 as multiple of wMaxPacketSize.  */
                    };
                  })*;  /* multiple OUT-EP's for STIM */
                  (block "IN_EP_ONLY_DAQ" struct ep_parameters {
                    uchar;  /* ENDPOINT_NUMBER, not endpoint address */
                    enum {
                      "BULK_TRANSFER" = 2,
                      "INTERRUPT_TRANSFER" = 3
                    };
                    uint;  /* wMaxPacketSize: Maximum packet  
 size of endpoint in bytes       */
                    uchar;  /* bInterval: polling of endpoint  */
                    enum {
                      "MESSAGE_PACKING_SINGLE" = 0,
                      "MESSAGE_PACKING_MULTIPLE" = 1,
                      "MESSAGE_PACKING_STREAMING" = 2
                    };  /* Packing of XCP Messages         
 SINGLE: Single per USB data packet    
 MULTIPLE: Multiple per USB data packet  
 STREAMING: No restriction by packet sizes*/
                    enum {
                      "ALIGNMENT_8_BIT" = 0,
                      "ALIGNMENT_16_BIT" = 1,
                      "ALIGNMENT_32_BIT" = 2,
                      "ALIGNMENT_64_BIT" = 3
                    };  /* Alignment mandatory for all packing types*/
                    taggedstruct {
                      "RECOMMENDED_HOST_BUFSIZE" uint;  /* Recommended size for the host 
 buffer size. The size is defined
 as multiple of wMaxPacketSize.  */
                    };
                  })*;  /* multiple IN-EP's for DAQ*/
                  block "IN_EP_ONLY_EVSERV" struct ep_parameters {
                    uchar;  /* ENDPOINT_NUMBER, not endpoint address */
                    enum {
                      "BULK_TRANSFER" = 2,
                      "INTERRUPT_TRANSFER" = 3
                    };
                    uint;  /* wMaxPacketSize: Maximum packet  
 size of endpoint in bytes       */
                    uchar;  /* bInterval: polling of endpoint  */
                    enum {
                      "MESSAGE_PACKING_SINGLE" = 0,
                      "MESSAGE_PACKING_MULTIPLE" = 1,
                      "MESSAGE_PACKING_STREAMING" = 2
                    };  /* Packing of XCP Messages         
 SINGLE: Single per USB data packet    
 MULTIPLE: Multiple per USB data packet  
 STREAMING: No restriction by packet sizes*/
                    enum {
                      "ALIGNMENT_8_BIT" = 0,
                      "ALIGNMENT_16_BIT" = 1,
                      "ALIGNMENT_32_BIT" = 2,
                      "ALIGNMENT_64_BIT" = 3
                    };  /* Alignment mandatory for all packing types*/
                    taggedstruct {
                      "RECOMMENDED_HOST_BUFSIZE" uint;  /* Recommended size for the host 
 buffer size. The size is defined
 as multiple of wMaxPacketSize.  */
                    };
                  };  /* only one IN-EP for EV/SERV*/
                  (block "DAQ_LIST_USB_ENDPOINT" struct {
                    uint;  /* reference to DAQ_LIST_NUMBER          */
                    taggedstruct {
                      "FIXED_IN" uchar;  /* this DAQ list always                
 ENDPOINT_NUMBER, not endpoint address */
                      "FIXED_OUT" uchar;  /* this STIM list always               
 ENDPOINT_NUMBER, not endpoint address */
                    };
                  })*;
                };
              };  /* specific for USB      */
              taggedstruct Common_Parameters {
                block "PROTOCOL_LAYER" struct Protocol_Layer {
                  uint;  /* XCP protocol layer version, current 0x100*/
                  uint;  /* T1 [ms] Time-out of the standard CTO, for example CONNECT*/
                  uint;  /* T2 [ms] Time-out of the checksum calculation*/
                  uint;  /* T3 [ms] Time-out of the non-volatile memory programming: PROGRAM_START, PROGRAM_VERIFY, PROGRAM_PREPARE*/
                  uint;  /* T4 [ms] Time-out of the non-volatile memory programming: PROGRAM_CLEAR*/
                  uint;  /* T5 [ms] Time-out of the non-volatile memory programming: PROGRAM, PROGRAM_RESET, PROGRAM_MAX*/
                  uint;  /* T6 [ms] Time-out of the command CONNECT(USER_DEFINED)*/
                  uint;  /* T7 [ms] Time-out of the pre-action*/
                  uchar;  /* MAX_CTO: Indicates the maximum length of a CTO packet in bytes. */
                  uint;  /* MAX_DTO: Indicates the maximum length of a DTO packet in bytes. */
                  enum {
                    "BYTE_ORDER_MSB_LAST" = 0,
                    "BYTE_ORDER_MSB_FIRST" = 1
                  };  /* BYTE_ORDER: BYTE_ORDER_MSB_LAST = Intel, BYTE_ORDER_MSB_FIRST = Motorola*/
                  enum {
                    "ADDRESS_GRANULARITY_BYTE" = 1,
                    "ADDRESS_GRANULARITY_WORD" = 2,
                    "ADDRESS_GRANULARITY_DWORD" = 4
                  };  /*The address granularity indicates the size of an element contained at a single address.*/
                  taggedstruct {
                    ("OPTIONAL_CMD" enum {
                      "GET_COMM_MODE_INFO" = 251,
                      "GET_ID" = 250,
                      "SET_REQUEST" = 249,
                      "GET_SEED" = 248,
                      "UNLOCK" = 247,
                      "SET_MTA" = 246,
                      "UPLOAD" = 245,
                      "SHORT_UPLOAD" = 244,
                      "BUILD_CHECKSUM" = 243,
                      "TRANSPORT_LAYER_CMD" = 242,
                      "USER_CMD" = 241,
                      "DOWNLOAD" = 240,
                      "DOWNLOAD_NEXT" = 239,
                      "DOWNLOAD_MAX" = 238,
                      "SHORT_DOWNLOAD" = 237,
                      "MODIFY_BITS" = 236,
                      "SET_CAL_PAGE" = 235,
                      "GET_CAL_PAGE" = 234,
                      "GET_PAG_PROCESSOR_INFO" = 233,
                      "GET_SEGMENT_INFO" = 232,
                      "GET_PAGE_INFO" = 231,
                      "SET_SEGMENT_MODE" = 230,
                      "GET_SEGMENT_MODE" = 229,
                      "COPY_CAL_PAGE" = 228,
                      "CLEAR_DAQ_LIST" = 227,
                      "SET_DAQ_PTR" = 226,
                      "WRITE_DAQ" = 225,
                      "SET_DAQ_LIST_MODE" = 224,
                      "GET_DAQ_LIST_MODE" = 223,
                      "START_STOP_DAQ_LIST" = 222,
                      "START_STOP_SYNCH" = 221,
                      "GET_DAQ_CLOCK" = 220,
                      "READ_DAQ" = 219,
                      "GET_DAQ_PROCESSOR_INFO" = 218,
                      "GET_DAQ_RESOLUTION_INFO" = 217,
                      "GET_DAQ_LIST_INFO" = 216,
                      "GET_DAQ_EVENT_INFO" = 215,
                      "FREE_DAQ" = 214,
                      "ALLOC_DAQ" = 213,
                      "ALLOC_ODT" = 212,
                      "ALLOC_ODT_ENTRY" = 211,
                      "PROGRAM_START" = 210,
                      "PROGRAM_CLEAR" = 209,
                      "PROGRAM" = 208,
                      "PROGRAM_RESET" = 207,
                      "GET_PGM_PROCESSOR_INFO" = 206,
                      "GET_SECTOR_INFO" = 205,
                      "PROGRAM_PREPARE" = 204,
                      "PROGRAM_FORMAT" = 203,
                      "PROGRAM_NEXT" = 202,
                      "PROGRAM_MAX" = 201,
                      "PROGRAM_VERIFY" = 200
                    })*;  /* XCP-Code of optional command supported by the slave*/
                    "COMMUNICATION_MODE_SUPPORTED" taggedunion {
                      "BLOCK" taggedstruct {
                        "SLAVE" ;
                        "MASTER" struct {
                          uchar;  /* MAX_BS: Indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                          uchar;  /* MIN_ST: Indicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                        };
                      };
                      "INTERLEAVED" uchar;  /* QUEUE_SIZE: indicates the maximum number of consecutive command packets the master can send to the receipt queue of the slave*/
                    };
                    "SEED_AND_KEY_EXTERNAL_FUNCTION" char[256];  /* Name of the Seed&Key function*/
                  };
                };
                block "SEGMENT" struct Segment {
                  uchar;  /* SEGMENT_NUMBER: Logical data segment number*/
                  uchar;  /* Total number of available pages */
                  uchar;  /* ADDRESS_EXTENSION: Address extension for this SEGMENT*/
                  uchar;  /* COMPRESSION_METHOD: The COMPRESSION_x flags indicate which compression state of the incoming data the slave can process*/
                  uchar;  /* ENCRYPTION_METHOD: The  ENCRYPTION_x flags indicate which encryption state of the incoming data the slave can process.*/
                  taggedstruct {
                    block "CHECKSUM" struct {
                      enum {
                        "XCP_ADD_11" = 1,
                        "XCP_ADD_12" = 2,
                        "XCP_ADD_14" = 3,
                        "XCP_ADD_22" = 4,
                        "XCP_ADD_24" = 5,
                        "XCP_ADD_44" = 6,
                        "XCP_CRC_16" = 7,
                        "XCP_CRC_16_CITT" = 8,
                        "XCP_CRC_32" = 9,
                        "XCP_USER_DEFINED" = 255
                      };  /* Checksum type*/
                      taggedstruct {
                        "MAX_BLOCK_SIZE" ulong;  /* Maximum block size for checksum calculation */
                        "EXTERNAL_FUNCTION" char[256];  /* Name of the Checksum.DLL */
                      };
                    };
                    (block "PAGE" struct {
                      uchar;  /* PAGE_NUMBER: Logical page number*/
                      enum {
                        "ECU_ACCESS_NOT_ALLOWED" = 0,
                        "ECU_ACCESS_WITHOUT_XCP_ONLY" = 1,
                        "ECU_ACCESS_WITH_XCP_ONLY" = 2,
                        "ECU_ACCESS_DONT_CARE" = 3
                      };  /*The ECU_ACCESS_x  flags indicate whether and how the ECU can access this page.*/
                      enum {
                        "XCP_READ_ACCESS_NOT_ALLOWED" = 0,
                        "XCP_READ_ACCESS_WITHOUT_ECU_ONLY" = 1,
                        "XCP_READ_ACCESS_WITH_ECU_ONLY" = 2,
                        "XCP_READ_ACCESS_DONT_CARE" = 3
                      };  /*The XCP_x_ACCESS_y flags indicate whether and how the XCP master can access this page.*/
                      enum {
                        "XCP_WRITE_ACCESS_NOT_ALLOWED" = 0,
                        "XCP_WRITE_ACCESS_WITHOUT_ECU_ONLY" = 1,
                        "XCP_WRITE_ACCESS_WITH_ECU_ONLY" = 2,
                        "XCP_WRITE_ACCESS_DONT_CARE" = 3
                      };  /*The XCP_WRITE_ACCESS_x flags indicate whether the  X CP master can write to this PAGE*/
                      taggedstruct {
                        "INIT_SEGMENT" uchar;  /* references segment that initialises this page */
                      };
                    })*;  /* PAGES for this SEGMENT */
                    (block "ADDRESS_MAPPING" struct {
                      ulong;  /* source address */
                      ulong;  /* destination address */
                      ulong;  /* length */
                    })*;
                    "PGM_VERIFY" ulong;  /* verification value for PGM */
                  };
                };
                block "DAQ" struct Daq {
                  enum {
                    "STATIC" = 0,
                    "DYNAMIC" = 1
                  };  /*The flag indicates whether the DAQ lists that are not PREDEFINED shall be configured statically or dynamically*/
                  uint;  /* MAX_DAQ: Total number of available DAQ lists */
                  uint;  /* MAX_EVENT_CHANNEL: Total number of available event channels*/
                  uchar;  /* MIN_DAQ: Total number of predefined DAQ lists */
                  enum {
                    "OPTIMISATION_TYPE_DEFAULT" = 0,
                    "OPTIMISATION_TYPE_ODT_TYPE_16" = 1,
                    "OPTIMISATION_TYPE_ODT_TYPE_32" = 2,
                    "OPTIMISATION_TYPE_ODT_TYPE_64" = 3,
                    "OPTIMISATION_TYPE_ODT_TYPE_ALIGNMENT" = 4,
                    "OPTIMISATION_TYPE_MAX_ENTRY_SIZE" = 5
                  };  /* Indicate the Type of Optimisation Method the master preferably should use.*/
                  enum {
                    "ADDRESS_EXTENSION_FREE" = 0,
                    "ADDRESS_EXTENSION_ODT" = 1,
                    "ADDRESS_EXTENSION_DAQ" = 3
                  };  /*The flag indicates whether the address extension of all entries within one ODT or within one DAQ must be the same. */
                  enum {
                    "IDENTIFICATION_FIELD_TYPE_ABSOLUTE" = 0,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE" = 1,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD" = 2,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED" = 3
                  };  /* The type of Identification Field the slave will use when transferring DAQ Packets to the master*/
                  enum {
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE" = 1,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_WORD" = 2,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DWORD" = 4,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DLONG" = 8
                  };  /* Granularity for size of ODT entry */
                  uchar;  /* MAX_ODT_ENTRY_SIZE_DAQ Maximum size of ODT entry (DIRECTION = DAQ) */
                  enum {
                    "NO_OVERLOAD_INDICATION" = 0,
                    "OVERLOAD_INDICATION_PID" = 1,
                    "OVERLOAD_INDICATION_EVENT" = 2
                  };  /*OVERLOAD_INDICATION_PID: This means the higest bit is set in the PID, when an overload occurs
OVERLOAD_INDICATION_EVENT: This means an event is set, when an overload occurs*/
                  taggedstruct {
                    "PRESCALER_SUPPORTED" ;  /*This flag indicates that all DAQ lists support the prescaler for reducing the transmission period.*/
                    "RESUME_SUPPORTED" ;  /*This  flag indicates that all DAQ lists can be put in RESUME mode. */
                    block "STIM" struct {
                      enum {
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE" = 1,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD" = 2,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_DWORD" = 4,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_DLONG" = 8
                      };  /* Granularity for size of ODT entry direction STIM*/
                      uchar;  /* MAX_ODT_ENTRY_SIZE_STIM Maximum size of ODT entry (DIRECTION = STIM)*/
                      taggedstruct {
                        "BIT_STIM_SUPPORTED" ;  /*The flag indicates  whether  bitwise  data  stimulation  through BIT_OFFSET in WRITE_DAQ is supported.*/
                      };
                    };
                    block "TIMESTAMP_SUPPORTED" struct {
                      uint;  /*The timestamp will increment by TIMESTAMP_TICKS per unit and wrap around if an overflow occurs. */
                      enum {
                        "NO_TIME_STAMP" = 0,
                        "SIZE_BYTE" = 1,
                        "SIZE_WORD" = 2,
                        "SIZE_DWORD" = 4
                      };  /*Timestamp size in bytes*/
                      enum {
                        "UNIT_1NS" = 0,
                        "UNIT_10NS" = 1,
                        "UNIT_100NS" = 2,
                        "UNIT_1US" = 3,
                        "UNIT_10US" = 4,
                        "UNIT_100US" = 5,
                        "UNIT_1MS" = 6,
                        "UNIT_10MS" = 7,
                        "UNIT_100MS" = 8,
                        "UNIT_1S" = 9
                      };  /*Ticks per unit*/
                      taggedstruct {
                        "TIMESTAMP_FIXED" ;
                      };  /* TIMESTAMP_FIXED flag indicates that the Slave always will send DTO Packets in time stamped mode. */
                    };
                    "PID_OFF_SUPPORTED" ;  /*Flag in DAQ_PROPERTIES indicates that transfer of DTO Packets without Identification Field is possible. */
                    (block "DAQ_LIST" struct {
                      uint;  /* DAQ_LIST_NUMBER  is in the range [0,1,..MIN_DAQ-1]. */
                      taggedstruct {
                        "DAQ_LIST_TYPE" enum {
                          "DAQ" = 1,
                          "STIM" = 2,
                          "DAQ_STIM" = 3
                        };  /* DAQ: DIRECTION = DAQ only 
 STIM: DIRECTION = STIM only 
 DAQ_STIM: both directions are possible */
                        "MAX_ODT" uchar;  /*Number of ODTs in this DAQ list */
                        "MAX_ODT_ENTRIES" uchar;  /*Maximum number of entries in an ODT*/
                        "FIRST_PID" uchar;  /*FIRST_PID: Is the PID in the DTO Packet of the first ODT transferred by this DAQ list.*/
                        "EVENT_FIXED" uint;  /*The flag indicates that the Event Channel for this DAQ list can not be changed. */
                        block "PREDEFINED" taggedstruct {
                          (block "ODT" struct {
                            uchar;  /* ODT number */
                            taggedstruct {
                              ("ODT_ENTRY" struct {
                                uchar;  /* ODT_ENTRY number */
                                ulong;  /* address of element */
                                uchar;  /* address extension of element */
                                uchar;  /* size of element [AG] */
                                uchar;  /* BIT_OFFSET */
                              })*;
                            };
                          })*;
                        };  /*PREDEFINED;The DAQ list is predefined and fixed in the slave devices memory.*/
                      };
                    })*;
                    (block "EVENT" struct {
                      char[101];  /* EVENT_CHANNEL_NAME */
                      char[9];  /* EVENT_CHANNEL_SHORT_NAME */
                      uint;  /* EVENT_CHANNEL_NUMBER*/
                      enum {
                        "DAQ" = 1,
                        "STIM" = 2,
                        "DAQ_STIM" = 3
                      };  /* DAQ: only DAQ_LISTs with DIRECTION = DAQ 
 STIM: only DAQ_LISTs with DIRECTION = STIM 
 DAQ_STIM both kind of DAQ_LISTs*/
                      uchar;  /* MAX_DAQ_LIST:Maximum number of DAQ lists in this event channel */
                      uchar;  /* TIME_CYCLE: Event channel time cycle */
                      uchar;  /* TIME_UNIT: Event channel time unit*/
                      uchar;  /* PRIORITY:The event channel with event channel priority = FF has the highest priority */
                    })*;
                  };
                };
                block "PAG" struct Pag {
                  uchar;  /* MAX_SEGMENTS: Is the total number of segments in the slave device*/
                  taggedstruct {
                    "FREEZE_SUPPORTED" ;  /*This flag indicates that all SEGMENTS can be put in FREEZE */
                  };
                };
                block "PGM" struct Pgm {
                  enum {
                    "PGM_MODE_ABSOLUTE" = 1,
                    "PGM_MODE_FUNCTIONAL" = 2,
                    "PGM_MODE_ABSOLUTE_AND_FUNCTIONAL" = 3
                  };  /*The  ABSOLUTE_MODE  and  FUNCTIONAL_MODE  flags  indicate  the  clear/programming mode that can be used */
                  uchar;  /* MAX_SECTORS: Total number of available sectors */
                  uchar;  /* MAX_CTO_PGM: Maximum CTO size for PGM */
                  taggedstruct {
                    (block "SECTOR" struct {
                      char[101];  /* SECTOR_NAME */
                      uchar;  /* SECTOR_NUMBER*/
                      ulong;  /* Start address for this SECTOR */
                      ulong;  /* Length of this SECTOR [AG] */
                      uchar;  /* CLEAR_SEQUENCE_NUMBER: The Clear Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
                      uchar;  /* PROGRAM_SEQUENCE_NUMBER: The Program Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
                      uchar;  /* PROGRAM_METHOD: The work flow depends on mode  absolute access or functional access*/
                    })*;
                    "COMMUNICATION_MODE_SUPPORTED" taggedunion {
                      "BLOCK" taggedstruct {
                        "SLAVE" ;  /*This flag indicates whether the Slave Block Mode is available during Programming. */
                        "MASTER" struct {
                          uchar;  /* MAX_BS_PGM:MAX_BS: indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                          uchar;  /* MIN_ST_PGM ndicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                        };  /*This flag indicates whether the Master Block Mode is available */
                      };
                      "INTERLEAVED" uchar;  /* QUEUE_SIZE_PGM: This value describe the total count of bytes for this queue*/
                    };
                  };
                };
                block "DAQ_EVENT" taggedunion Daq_Event {
                  "FIXED_EVENT_LIST" taggedstruct {
                    ("EVENT" uint)*;
                  };
                  "VARIABLE" taggedstruct {
                    block "AVAILABLE_EVENT_LIST" taggedstruct {
                      ("EVENT" uint)*;
                    };
                    block "DEFAULT_EVENT_LIST" taggedstruct {
                      ("EVENT" uint)*;
                    };
                  };
                };
              };  /* overruling of default */
            };
            block "XCP_ON_FLX" struct {
              struct FLX_Parameters {
                uint;  /* XCP on FlexRay version
 e.g. "1.0" = 0x0100*/
                uint;  /* T1_FLX [ms] Time-out while waiting for an XCP on FlexRay response
 e.g. FLX_ASSIGN*/
                char[256];  /* FIBEX-file with extension and without path, including CHI information*/
                char[256];  /* cluster-ID, id attribute of the FIBEX cluster*/
                uchar;  /* NAX, node address of the ECU*/
                enum {
                  "HEADER_NAX" = 0,
                  "HEADER_NAX_FILL" = 1,
                  "HEADER_NAX_CTR" = 2,
                  "HEADER_NAX_FILL3" = 3,
                  "HEADER_NAX_CTR_FILL2" = 4,
                  "HEADER_NAX_LEN" = 5,
                  "HEADER_NAX_CTR_LEN" = 6,
                  "HEADER_NAX_FILL2_LEN" = 7,
                  "HEADER_NAX_CTR_FILL_LEN" = 8
                };  /* header type of the XCP on FlexRay message*/
                enum {
                  "PACKET_ALIGNMENT_8" = 0,
                  "PACKET_ALIGNMENT_16" = 1,
                  "PACKET_ALIGNMENT_32" = 2
                };  /* XCP packet alignment within the XCP on FlexRay Message*/
                taggedunion {
                  block "INITIAL_CMD_BUFFER" struct buffer {
                    uchar;  /* Buffer number*/
                    taggedstruct {
                      "MAX_FLX_LEN_BUF" taggedunion {
                        "FIXED" uchar;  /* constant value, can't be modified on runtime */
                        "VARIABLE" uchar;  /* initial value, can be modified on runtime*/
                      };  /* maximal size of the buffer [byte]*/
                      block "LPDU_ID" taggedstruct {
                        "FLX_SLOT_ID" taggedunion {
                          "FIXED" uint;  /* constant value, can't be modified on runtime*/
                          "VARIABLE" taggedstruct {
                            "INITIAL_VALUE" uint;
                          };  /* initial value, can be modified on runtime*/
                        };  /* FlexRay timing, slot id*/
                        "OFFSET" taggedunion {
                          "FIXED" uchar;  /* constant value, can't be modified on runtime*/
                          "VARIABLE" taggedstruct {
                            "INITIAL_VALUE" uchar;
                          };  /* initial value, can be modified on runtime*/
                        };  /* FlexRay timing, base cycle*/
                        "CYCLE_REPETITION" taggedunion {
                          "FIXED" uchar;  /* constant value, can't be modified on runtime*/
                          "VARIABLE" taggedstruct {
                            "INITIAL_VALUE" uchar;
                          };  /* initial value, can be modified on runtime*/
                        };  /* FlexRay timing, cycle repetition*/
                        "CHANNEL" taggedunion {
                          "FIXED" enum {
                            "A" = 0,
                            "B" = 1
                          };  /* constant value, can't be modified on runtime*/
                          "VARIABLE" taggedstruct {
                            "INITIAL_VALUE" enum {
                              "A" = 0,
                              "B" = 1
                            };
                          };  /* initial value, can be modified on runtime*/
                        };  /* FlexRay Channel A or B*/
                      };  /* LPDU-ID,  Data  Link  Layer  Protocol  Data  Unit  Identifier*/
                      block "XCP_PACKET" taggedstruct {
                        "CMD" enum packet_assignment_type {
                          "NOT_ALLOWED" = 0,
                          "FIXED" = 1,
                          "VARIABLE_INITIALISED" = 2,
                          "VARIABLE" = 3
                        };
                        "RES_ERR" enum packet_assignment_type {
                          "NOT_ALLOWED" = 0,
                          "FIXED" = 1,
                          "VARIABLE_INITIALISED" = 2,
                          "VARIABLE" = 3
                        };
                        "EV_SERV" enum packet_assignment_type {
                          "NOT_ALLOWED" = 0,
                          "FIXED" = 1,
                          "VARIABLE_INITIALISED" = 2,
                          "VARIABLE" = 3
                        };
                        "DAQ" enum packet_assignment_type {
                          "NOT_ALLOWED" = 0,
                          "FIXED" = 1,
                          "VARIABLE_INITIALISED" = 2,
                          "VARIABLE" = 3
                        };
                        "STIM" enum packet_assignment_type {
                          "NOT_ALLOWED" = 0,
                          "FIXED" = 1,
                          "VARIABLE_INITIALISED" = 2,
                          "VARIABLE" = 3
                        };
                      };  /* XCP packet type*/
                    };
                  };
                };  /* XCP dedicated buffer used to transmit XCP commands*/
                taggedunion {
                  block "INITIAL_RES_ERR_BUFFER" struct buffer {
                    uchar;  /* Buffer number*/
                    taggedstruct {
                      "MAX_FLX_LEN_BUF" taggedunion {
                        "FIXED" uchar;  /* constant value, can't be modified on runtime */
                        "VARIABLE" uchar;  /* initial value, can be modified on runtime*/
                      };  /* maximal size of the buffer [byte]*/
                      block "LPDU_ID" taggedstruct {
                        "FLX_SLOT_ID" taggedunion {
                          "FIXED" uint;  /* constant value, can't be modified on runtime*/
                          "VARIABLE" taggedstruct {
                            "INITIAL_VALUE" uint;
                          };  /* initial value, can be modified on runtime*/
                        };  /* FlexRay timing, slot id*/
                        "OFFSET" taggedunion {
                          "FIXED" uchar;  /* constant value, can't be modified on runtime*/
                          "VARIABLE" taggedstruct {
                            "INITIAL_VALUE" uchar;
                          };  /* initial value, can be modified on runtime*/
                        };  /* FlexRay timing, base cycle*/
                        "CYCLE_REPETITION" taggedunion {
                          "FIXED" uchar;  /* constant value, can't be modified on runtime*/
                          "VARIABLE" taggedstruct {
                            "INITIAL_VALUE" uchar;
                          };  /* initial value, can be modified on runtime*/
                        };  /* FlexRay timing, cycle repetition*/
                        "CHANNEL" taggedunion {
                          "FIXED" enum {
                            "A" = 0,
                            "B" = 1
                          };  /* constant value, can't be modified on runtime*/
                          "VARIABLE" taggedstruct {
                            "INITIAL_VALUE" enum {
                              "A" = 0,
                              "B" = 1
                            };
                          };  /* initial value, can be modified on runtime*/
                        };  /* FlexRay Channel A or B*/
                      };  /* LPDU-ID,  Data  Link  Layer  Protocol  Data  Unit  Identifier*/
                      block "XCP_PACKET" taggedstruct {
                        "CMD" enum packet_assignment_type {
                          "NOT_ALLOWED" = 0,
                          "FIXED" = 1,
                          "VARIABLE_INITIALISED" = 2,
                          "VARIABLE" = 3
                        };
                        "RES_ERR" enum packet_assignment_type {
                          "NOT_ALLOWED" = 0,
                          "FIXED" = 1,
                          "VARIABLE_INITIALISED" = 2,
                          "VARIABLE" = 3
                        };
                        "EV_SERV" enum packet_assignment_type {
                          "NOT_ALLOWED" = 0,
                          "FIXED" = 1,
                          "VARIABLE_INITIALISED" = 2,
                          "VARIABLE" = 3
                        };
                        "DAQ" enum packet_assignment_type {
                          "NOT_ALLOWED" = 0,
                          "FIXED" = 1,
                          "VARIABLE_INITIALISED" = 2,
                          "VARIABLE" = 3
                        };
                        "STIM" enum packet_assignment_type {
                          "NOT_ALLOWED" = 0,
                          "FIXED" = 1,
                          "VARIABLE_INITIALISED" = 2,
                          "VARIABLE" = 3
                        };
                      };  /* XCP packet type*/
                    };
                  };
                };  /* XCP dedicated buffer used to receive the responses on the XCP commands*/
                taggedstruct {
                  (block "POOL_BUFFER" struct buffer {
                    uchar;  /* Buffer number*/
                    taggedstruct {
                      "MAX_FLX_LEN_BUF" taggedunion {
                        "FIXED" uchar;  /* constant value, can't be modified on runtime */
                        "VARIABLE" uchar;  /* initial value, can be modified on runtime*/
                      };  /* maximal size of the buffer [byte]*/
                      block "LPDU_ID" taggedstruct {
                        "FLX_SLOT_ID" taggedunion {
                          "FIXED" uint;  /* constant value, can't be modified on runtime*/
                          "VARIABLE" taggedstruct {
                            "INITIAL_VALUE" uint;
                          };  /* initial value, can be modified on runtime*/
                        };  /* FlexRay timing, slot id*/
                        "OFFSET" taggedunion {
                          "FIXED" uchar;  /* constant value, can't be modified on runtime*/
                          "VARIABLE" taggedstruct {
                            "INITIAL_VALUE" uchar;
                          };  /* initial value, can be modified on runtime*/
                        };  /* FlexRay timing, base cycle*/
                        "CYCLE_REPETITION" taggedunion {
                          "FIXED" uchar;  /* constant value, can't be modified on runtime*/
                          "VARIABLE" taggedstruct {
                            "INITIAL_VALUE" uchar;
                          };  /* initial value, can be modified on runtime*/
                        };  /* FlexRay timing, cycle repetition*/
                        "CHANNEL" taggedunion {
                          "FIXED" enum {
                            "A" = 0,
                            "B" = 1
                          };  /* constant value, can't be modified on runtime*/
                          "VARIABLE" taggedstruct {
                            "INITIAL_VALUE" enum {
                              "A" = 0,
                              "B" = 1
                            };
                          };  /* initial value, can be modified on runtime*/
                        };  /* FlexRay Channel A or B*/
                      };  /* LPDU-ID,  Data  Link  Layer  Protocol  Data  Unit  Identifier*/
                      block "XCP_PACKET" taggedstruct {
                        "CMD" enum packet_assignment_type {
                          "NOT_ALLOWED" = 0,
                          "FIXED" = 1,
                          "VARIABLE_INITIALISED" = 2,
                          "VARIABLE" = 3
                        };
                        "RES_ERR" enum packet_assignment_type {
                          "NOT_ALLOWED" = 0,
                          "FIXED" = 1,
                          "VARIABLE_INITIALISED" = 2,
                          "VARIABLE" = 3
                        };
                        "EV_SERV" enum packet_assignment_type {
                          "NOT_ALLOWED" = 0,
                          "FIXED" = 1,
                          "VARIABLE_INITIALISED" = 2,
                          "VARIABLE" = 3
                        };
                        "DAQ" enum packet_assignment_type {
                          "NOT_ALLOWED" = 0,
                          "FIXED" = 1,
                          "VARIABLE_INITIALISED" = 2,
                          "VARIABLE" = 3
                        };
                        "STIM" enum packet_assignment_type {
                          "NOT_ALLOWED" = 0,
                          "FIXED" = 1,
                          "VARIABLE_INITIALISED" = 2,
                          "VARIABLE" = 3
                        };
                      };  /* XCP packet type*/
                    };
                  })*;
                };  /* XCP dedicated buffer(s) used for XCP-DAQ, -STIM and -EV/SERV*/
              };  /* specific for FlexRay  */
              taggedstruct Common_Parameters {
                block "PROTOCOL_LAYER" struct Protocol_Layer {
                  uint;  /* XCP protocol layer version, current 0x100*/
                  uint;  /* T1 [ms] Time-out of the standard CTO, for example CONNECT*/
                  uint;  /* T2 [ms] Time-out of the checksum calculation*/
                  uint;  /* T3 [ms] Time-out of the non-volatile memory programming: PROGRAM_START, PROGRAM_VERIFY, PROGRAM_PREPARE*/
                  uint;  /* T4 [ms] Time-out of the non-volatile memory programming: PROGRAM_CLEAR*/
                  uint;  /* T5 [ms] Time-out of the non-volatile memory programming: PROGRAM, PROGRAM_RESET, PROGRAM_MAX*/
                  uint;  /* T6 [ms] Time-out of the command CONNECT(USER_DEFINED)*/
                  uint;  /* T7 [ms] Time-out of the pre-action*/
                  uchar;  /* MAX_CTO: Indicates the maximum length of a CTO packet in bytes. */
                  uint;  /* MAX_DTO: Indicates the maximum length of a DTO packet in bytes. */
                  enum {
                    "BYTE_ORDER_MSB_LAST" = 0,
                    "BYTE_ORDER_MSB_FIRST" = 1
                  };  /* BYTE_ORDER: BYTE_ORDER_MSB_LAST = Intel, BYTE_ORDER_MSB_FIRST = Motorola*/
                  enum {
                    "ADDRESS_GRANULARITY_BYTE" = 1,
                    "ADDRESS_GRANULARITY_WORD" = 2,
                    "ADDRESS_GRANULARITY_DWORD" = 4
                  };  /*The address granularity indicates the size of an element contained at a single address.*/
                  taggedstruct {
                    ("OPTIONAL_CMD" enum {
                      "GET_COMM_MODE_INFO" = 251,
                      "GET_ID" = 250,
                      "SET_REQUEST" = 249,
                      "GET_SEED" = 248,
                      "UNLOCK" = 247,
                      "SET_MTA" = 246,
                      "UPLOAD" = 245,
                      "SHORT_UPLOAD" = 244,
                      "BUILD_CHECKSUM" = 243,
                      "TRANSPORT_LAYER_CMD" = 242,
                      "USER_CMD" = 241,
                      "DOWNLOAD" = 240,
                      "DOWNLOAD_NEXT" = 239,
                      "DOWNLOAD_MAX" = 238,
                      "SHORT_DOWNLOAD" = 237,
                      "MODIFY_BITS" = 236,
                      "SET_CAL_PAGE" = 235,
                      "GET_CAL_PAGE" = 234,
                      "GET_PAG_PROCESSOR_INFO" = 233,
                      "GET_SEGMENT_INFO" = 232,
                      "GET_PAGE_INFO" = 231,
                      "SET_SEGMENT_MODE" = 230,
                      "GET_SEGMENT_MODE" = 229,
                      "COPY_CAL_PAGE" = 228,
                      "CLEAR_DAQ_LIST" = 227,
                      "SET_DAQ_PTR" = 226,
                      "WRITE_DAQ" = 225,
                      "SET_DAQ_LIST_MODE" = 224,
                      "GET_DAQ_LIST_MODE" = 223,
                      "START_STOP_DAQ_LIST" = 222,
                      "START_STOP_SYNCH" = 221,
                      "GET_DAQ_CLOCK" = 220,
                      "READ_DAQ" = 219,
                      "GET_DAQ_PROCESSOR_INFO" = 218,
                      "GET_DAQ_RESOLUTION_INFO" = 217,
                      "GET_DAQ_LIST_INFO" = 216,
                      "GET_DAQ_EVENT_INFO" = 215,
                      "FREE_DAQ" = 214,
                      "ALLOC_DAQ" = 213,
                      "ALLOC_ODT" = 212,
                      "ALLOC_ODT_ENTRY" = 211,
                      "PROGRAM_START" = 210,
                      "PROGRAM_CLEAR" = 209,
                      "PROGRAM" = 208,
                      "PROGRAM_RESET" = 207,
                      "GET_PGM_PROCESSOR_INFO" = 206,
                      "GET_SECTOR_INFO" = 205,
                      "PROGRAM_PREPARE" = 204,
                      "PROGRAM_FORMAT" = 203,
                      "PROGRAM_NEXT" = 202,
                      "PROGRAM_MAX" = 201,
                      "PROGRAM_VERIFY" = 200
                    })*;  /* XCP-Code of optional command supported by the slave*/
                    "COMMUNICATION_MODE_SUPPORTED" taggedunion {
                      "BLOCK" taggedstruct {
                        "SLAVE" ;
                        "MASTER" struct {
                          uchar;  /* MAX_BS: Indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                          uchar;  /* MIN_ST: Indicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                        };
                      };
                      "INTERLEAVED" uchar;  /* QUEUE_SIZE: indicates the maximum number of consecutive command packets the master can send to the receipt queue of the slave*/
                    };
                    "SEED_AND_KEY_EXTERNAL_FUNCTION" char[256];  /* Name of the Seed&Key function*/
                  };
                };
                block "SEGMENT" struct Segment {
                  uchar;  /* SEGMENT_NUMBER: Logical data segment number*/
                  uchar;  /* Total number of available pages */
                  uchar;  /* ADDRESS_EXTENSION: Address extension for this SEGMENT*/
                  uchar;  /* COMPRESSION_METHOD: The COMPRESSION_x flags indicate which compression state of the incoming data the slave can process*/
                  uchar;  /* ENCRYPTION_METHOD: The  ENCRYPTION_x flags indicate which encryption state of the incoming data the slave can process.*/
                  taggedstruct {
                    block "CHECKSUM" struct {
                      enum {
                        "XCP_ADD_11" = 1,
                        "XCP_ADD_12" = 2,
                        "XCP_ADD_14" = 3,
                        "XCP_ADD_22" = 4,
                        "XCP_ADD_24" = 5,
                        "XCP_ADD_44" = 6,
                        "XCP_CRC_16" = 7,
                        "XCP_CRC_16_CITT" = 8,
                        "XCP_CRC_32" = 9,
                        "XCP_USER_DEFINED" = 255
                      };  /* Checksum type*/
                      taggedstruct {
                        "MAX_BLOCK_SIZE" ulong;  /* Maximum block size for checksum calculation */
                        "EXTERNAL_FUNCTION" char[256];  /* Name of the Checksum.DLL */
                      };
                    };
                    (block "PAGE" struct {
                      uchar;  /* PAGE_NUMBER: Logical page number*/
                      enum {
                        "ECU_ACCESS_NOT_ALLOWED" = 0,
                        "ECU_ACCESS_WITHOUT_XCP_ONLY" = 1,
                        "ECU_ACCESS_WITH_XCP_ONLY" = 2,
                        "ECU_ACCESS_DONT_CARE" = 3
                      };  /*The ECU_ACCESS_x  flags indicate whether and how the ECU can access this page.*/
                      enum {
                        "XCP_READ_ACCESS_NOT_ALLOWED" = 0,
                        "XCP_READ_ACCESS_WITHOUT_ECU_ONLY" = 1,
                        "XCP_READ_ACCESS_WITH_ECU_ONLY" = 2,
                        "XCP_READ_ACCESS_DONT_CARE" = 3
                      };  /*The XCP_x_ACCESS_y flags indicate whether and how the XCP master can access this page.*/
                      enum {
                        "XCP_WRITE_ACCESS_NOT_ALLOWED" = 0,
                        "XCP_WRITE_ACCESS_WITHOUT_ECU_ONLY" = 1,
                        "XCP_WRITE_ACCESS_WITH_ECU_ONLY" = 2,
                        "XCP_WRITE_ACCESS_DONT_CARE" = 3
                      };  /*The XCP_WRITE_ACCESS_x flags indicate whether the  X CP master can write to this PAGE*/
                      taggedstruct {
                        "INIT_SEGMENT" uchar;  /* references segment that initialises this page */
                      };
                    })*;  /* PAGES for this SEGMENT */
                    (block "ADDRESS_MAPPING" struct {
                      ulong;  /* source address */
                      ulong;  /* destination address */
                      ulong;  /* length */
                    })*;
                    "PGM_VERIFY" ulong;  /* verification value for PGM */
                  };
                };
                block "DAQ" struct Daq {
                  enum {
                    "STATIC" = 0,
                    "DYNAMIC" = 1
                  };  /*The flag indicates whether the DAQ lists that are not PREDEFINED shall be configured statically or dynamically*/
                  uint;  /* MAX_DAQ: Total number of available DAQ lists */
                  uint;  /* MAX_EVENT_CHANNEL: Total number of available event channels*/
                  uchar;  /* MIN_DAQ: Total number of predefined DAQ lists */
                  enum {
                    "OPTIMISATION_TYPE_DEFAULT" = 0,
                    "OPTIMISATION_TYPE_ODT_TYPE_16" = 1,
                    "OPTIMISATION_TYPE_ODT_TYPE_32" = 2,
                    "OPTIMISATION_TYPE_ODT_TYPE_64" = 3,
                    "OPTIMISATION_TYPE_ODT_TYPE_ALIGNMENT" = 4,
                    "OPTIMISATION_TYPE_MAX_ENTRY_SIZE" = 5
                  };  /* Indicate the Type of Optimisation Method the master preferably should use.*/
                  enum {
                    "ADDRESS_EXTENSION_FREE" = 0,
                    "ADDRESS_EXTENSION_ODT" = 1,
                    "ADDRESS_EXTENSION_DAQ" = 3
                  };  /*The flag indicates whether the address extension of all entries within one ODT or within one DAQ must be the same. */
                  enum {
                    "IDENTIFICATION_FIELD_TYPE_ABSOLUTE" = 0,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE" = 1,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD" = 2,
                    "IDENTIFICATION_FIELD_TYPE_RELATIVE_WORD_ALIGNED" = 3
                  };  /* The type of Identification Field the slave will use when transferring DAQ Packets to the master*/
                  enum {
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE" = 1,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_WORD" = 2,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DWORD" = 4,
                    "GRANULARITY_ODT_ENTRY_SIZE_DAQ_DLONG" = 8
                  };  /* Granularity for size of ODT entry */
                  uchar;  /* MAX_ODT_ENTRY_SIZE_DAQ Maximum size of ODT entry (DIRECTION = DAQ) */
                  enum {
                    "NO_OVERLOAD_INDICATION" = 0,
                    "OVERLOAD_INDICATION_PID" = 1,
                    "OVERLOAD_INDICATION_EVENT" = 2
                  };  /*OVERLOAD_INDICATION_PID: This means the higest bit is set in the PID, when an overload occurs
OVERLOAD_INDICATION_EVENT: This means an event is set, when an overload occurs*/
                  taggedstruct {
                    "PRESCALER_SUPPORTED" ;  /*This flag indicates that all DAQ lists support the prescaler for reducing the transmission period.*/
                    "RESUME_SUPPORTED" ;  /*This  flag indicates that all DAQ lists can be put in RESUME mode. */
                    block "STIM" struct {
                      enum {
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE" = 1,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_WORD" = 2,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_DWORD" = 4,
                        "GRANULARITY_ODT_ENTRY_SIZE_STIM_DLONG" = 8
                      };  /* Granularity for size of ODT entry direction STIM*/
                      uchar;  /* MAX_ODT_ENTRY_SIZE_STIM Maximum size of ODT entry (DIRECTION = STIM)*/
                      taggedstruct {
                        "BIT_STIM_SUPPORTED" ;  /*The flag indicates  whether  bitwise  data  stimulation  through BIT_OFFSET in WRITE_DAQ is supported.*/
                      };
                    };
                    block "TIMESTAMP_SUPPORTED" struct {
                      uint;  /*The timestamp will increment by TIMESTAMP_TICKS per unit and wrap around if an overflow occurs. */
                      enum {
                        "NO_TIME_STAMP" = 0,
                        "SIZE_BYTE" = 1,
                        "SIZE_WORD" = 2,
                        "SIZE_DWORD" = 4
                      };  /*Timestamp size in bytes*/
                      enum {
                        "UNIT_1NS" = 0,
                        "UNIT_10NS" = 1,
                        "UNIT_100NS" = 2,
                        "UNIT_1US" = 3,
                        "UNIT_10US" = 4,
                        "UNIT_100US" = 5,
                        "UNIT_1MS" = 6,
                        "UNIT_10MS" = 7,
                        "UNIT_100MS" = 8,
                        "UNIT_1S" = 9
                      };  /*Ticks per unit*/
                      taggedstruct {
                        "TIMESTAMP_FIXED" ;
                      };  /* TIMESTAMP_FIXED flag indicates that the Slave always will send DTO Packets in time stamped mode. */
                    };
                    "PID_OFF_SUPPORTED" ;  /*Flag in DAQ_PROPERTIES indicates that transfer of DTO Packets without Identification Field is possible. */
                    (block "DAQ_LIST" struct {
                      uint;  /* DAQ_LIST_NUMBER  is in the range [0,1,..MIN_DAQ-1]. */
                      taggedstruct {
                        "DAQ_LIST_TYPE" enum {
                          "DAQ" = 1,
                          "STIM" = 2,
                          "DAQ_STIM" = 3
                        };  /* DAQ: DIRECTION = DAQ only 
 STIM: DIRECTION = STIM only 
 DAQ_STIM: both directions are possible */
                        "MAX_ODT" uchar;  /*Number of ODTs in this DAQ list */
                        "MAX_ODT_ENTRIES" uchar;  /*Maximum number of entries in an ODT*/
                        "FIRST_PID" uchar;  /*FIRST_PID: Is the PID in the DTO Packet of the first ODT transferred by this DAQ list.*/
                        "EVENT_FIXED" uint;  /*The flag indicates that the Event Channel for this DAQ list can not be changed. */
                        block "PREDEFINED" taggedstruct {
                          (block "ODT" struct {
                            uchar;  /* ODT number */
                            taggedstruct {
                              ("ODT_ENTRY" struct {
                                uchar;  /* ODT_ENTRY number */
                                ulong;  /* address of element */
                                uchar;  /* address extension of element */
                                uchar;  /* size of element [AG] */
                                uchar;  /* BIT_OFFSET */
                              })*;
                            };
                          })*;
                        };  /*PREDEFINED;The DAQ list is predefined and fixed in the slave devices memory.*/
                      };
                    })*;
                    (block "EVENT" struct {
                      char[101];  /* EVENT_CHANNEL_NAME */
                      char[9];  /* EVENT_CHANNEL_SHORT_NAME */
                      uint;  /* EVENT_CHANNEL_NUMBER*/
                      enum {
                        "DAQ" = 1,
                        "STIM" = 2,
                        "DAQ_STIM" = 3
                      };  /* DAQ: only DAQ_LISTs with DIRECTION = DAQ 
 STIM: only DAQ_LISTs with DIRECTION = STIM 
 DAQ_STIM both kind of DAQ_LISTs*/
                      uchar;  /* MAX_DAQ_LIST:Maximum number of DAQ lists in this event channel */
                      uchar;  /* TIME_CYCLE: Event channel time cycle */
                      uchar;  /* TIME_UNIT: Event channel time unit*/
                      uchar;  /* PRIORITY:The event channel with event channel priority = FF has the highest priority */
                    })*;
                  };
                };
                block "PAG" struct Pag {
                  uchar;  /* MAX_SEGMENTS: Is the total number of segments in the slave device*/
                  taggedstruct {
                    "FREEZE_SUPPORTED" ;  /*This flag indicates that all SEGMENTS can be put in FREEZE */
                  };
                };
                block "PGM" struct Pgm {
                  enum {
                    "PGM_MODE_ABSOLUTE" = 1,
                    "PGM_MODE_FUNCTIONAL" = 2,
                    "PGM_MODE_ABSOLUTE_AND_FUNCTIONAL" = 3
                  };  /*The  ABSOLUTE_MODE  and  FUNCTIONAL_MODE  flags  indicate  the  clear/programming mode that can be used */
                  uchar;  /* MAX_SECTORS: Total number of available sectors */
                  uchar;  /* MAX_CTO_PGM: Maximum CTO size for PGM */
                  taggedstruct {
                    (block "SECTOR" struct {
                      char[101];  /* SECTOR_NAME */
                      uchar;  /* SECTOR_NUMBER*/
                      ulong;  /* Start address for this SECTOR */
                      ulong;  /* Length of this SECTOR [AG] */
                      uchar;  /* CLEAR_SEQUENCE_NUMBER: The Clear Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
                      uchar;  /* PROGRAM_SEQUENCE_NUMBER: The Program Sequence Number describe, in which subsequential order the master has to clear and program flash memory sectors.*/
                      uchar;  /* PROGRAM_METHOD: The work flow depends on mode  absolute access or functional access*/
                    })*;
                    "COMMUNICATION_MODE_SUPPORTED" taggedunion {
                      "BLOCK" taggedstruct {
                        "SLAVE" ;  /*This flag indicates whether the Slave Block Mode is available during Programming. */
                        "MASTER" struct {
                          uchar;  /* MAX_BS_PGM:MAX_BS: indicates the maximum allowed block size as the number of consecutive command packets in a block sequence*/
                          uchar;  /* MIN_ST_PGM ndicates the required minimum separation time between the packets of a block transfer from the master device to the slave device in units of 100 ms*/
                        };  /*This flag indicates whether the Master Block Mode is available */
                      };
                      "INTERLEAVED" uchar;  /* QUEUE_SIZE_PGM: This value describe the total count of bytes for this queue*/
                    };
                  };
                };
                block "DAQ_EVENT" taggedunion Daq_Event {
                  "FIXED_EVENT_LIST" taggedstruct {
                    ("EVENT" uint)*;
                  };
                  "VARIABLE" taggedstruct {
                    block "AVAILABLE_EVENT_LIST" taggedstruct {
                      ("EVENT" uint)*;
                    };
                    block "DEFAULT_EVENT_LIST" taggedstruct {
                      ("EVENT" uint)*;
                    };
                  };
                };
              };  /* overruling of default */
            };
          };
        };
      };
    /end A2ML

    /begin MOD_PAR ""
      NO_OF_INTERFACES 1
      /begin MEMORY_SEGMENT
        CALRAM "" DATA FLASH INTERN 0x30028 0xD88 -1 -1 -1 -1 -1
        /begin IF_DATA XCP
          /begin SEGMENT
            0x00
            0x01
            0x00
            0x00
            0x00
            /begin PAGE
              0x00
              ECU_ACCESS_DONT_CARE
              XCP_READ_ACCESS_DONT_CARE
              XCP_WRITE_ACCESS_NOT_ALLOWED
            /end PAGE
            /begin ADDRESS_MAPPING
              0x03001C
              0x03001C
              0x01D0
            /end ADDRESS_MAPPING
          /end SEGMENT
        /end IF_DATA
      /end MEMORY_SEGMENT
    /end MOD_PAR

    /begin MOD_COMMON ""
      DEPOSIT ABSOLUTE
      ALIGNMENT_BYTE 1
      ALIGNMENT_WORD 1
      ALIGNMENT_LONG 1
      ALIGNMENT_FLOAT16_IEEE 2
      ALIGNMENT_FLOAT32_IEEE 1
      ALIGNMENT_FLOAT64_IEEE 1
      ALIGNMENT_INT64 1
    /end MOD_COMMON

    /begin IF_DATA XCP
      /begin PROTOCOL_LAYER
        0x0104
        0x09C4
        0xC8
        0x00
        0x00
        0x00
        0x00
        0x00
        0xFA
        0xFA
        BYTE_ORDER_MSB_LAST
        ADDRESS_GRANULARITY_BYTE
        OPTIONAL_CMD PROGRAM_PREPARE
        OPTIONAL_CMD PROGRAM_RESET
        OPTIONAL_CMD PROGRAM
        OPTIONAL_CMD PROGRAM_CLEAR
        OPTIONAL_CMD PROGRAM_START
        OPTIONAL_CMD ALLOC_ODT_ENTRY
        OPTIONAL_CMD ALLOC_ODT
        OPTIONAL_CMD ALLOC_DAQ
        OPTIONAL_CMD FREE_DAQ
        OPTIONAL_CMD GET_DAQ_EVENT_INFO
        OPTIONAL_CMD GET_DAQ_RESOLUTION_INFO
        OPTIONAL_CMD GET_DAQ_PROCESSOR_INFO
        OPTIONAL_CMD GET_DAQ_CLOCK
        OPTIONAL_CMD START_STOP_SYNCH
        OPTIONAL_CMD START_STOP_DAQ_LIST
        OPTIONAL_CMD GET_DAQ_LIST_MODE
        OPTIONAL_CMD SET_DAQ_LIST_MODE
        OPTIONAL_CMD WRITE_DAQ
        OPTIONAL_CMD SET_DAQ_PTR
        OPTIONAL_CMD CLEAR_DAQ_LIST
        OPTIONAL_CMD SHORT_DOWNLOAD
        OPTIONAL_CMD DOWNLOAD_MAX
        OPTIONAL_CMD DOWNLOAD
        OPTIONAL_CMD SHORT_UPLOAD
        OPTIONAL_CMD UPLOAD
        OPTIONAL_CMD SET_MTA
        OPTIONAL_CMD GET_COMM_MODE_INFO
      /end PROTOCOL_LAYER
      /begin DAQ
        DYNAMIC
        0x00
        0x1B
        0x00
        OPTIMISATION_TYPE_DEFAULT
        ADDRESS_EXTENSION_FREE
        IDENTIFICATION_FIELD_TYPE_RELATIVE_BYTE
        GRANULARITY_ODT_ENTRY_SIZE_DAQ_BYTE
        0xF8
        OVERLOAD_INDICATION_PID
        /begin STIM
          GRANULARITY_ODT_ENTRY_SIZE_STIM_BYTE
          0xF8
        /end STIM
        /begin TIMESTAMP_SUPPORTED
          0x01
          SIZE_DWORD
          UNIT_1US
        /end TIMESTAMP_SUPPORTED
        /begin EVENT
          "core0_t10"
          "core0_t10"
          0x01
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core0_t20"
          "core0_t20"
          0x02
          DAQ
          0xFF
          0x02
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core0_bg"
          "core0_bg"
          0x04
          DAQ
          0xFF
          0x05
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core0_t100"
          "core0_t10"
          0x03
          DAQ
          0xFF
          0x01
          0x08
          0x00
        /end EVENT
        /begin EVENT
          "core1_t10"
          "core1_t10"
          0x05
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core1_t20"
          "core1_t20"
          0x06
          DAQ
          0xFF
          0x02
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core1_bg"
          "core1_bg"
          0x08
          DAQ
          0xFF
          0x05
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core1_t100"
          "core1_t10"
          0x07
          DAQ
          0xFF
          0x01
          0x08
          0x00
        /end EVENT
        /begin EVENT
          "core2_t10"
          "core2_t10"
          0x09
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core2_t20"
          "core2_t20"
          0x0A
          DAQ
          0xFF
          0x02
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core2_bg"
          "core2_bg"
          0x0C
          DAQ
          0xFF
          0x05
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core2_t100"
          "core2_t10"
          0x0B
          DAQ
          0xFF
          0x01
          0x08
          0x00
        /end EVENT
        /begin EVENT
          "core3_t10"
          "core3_t10"
          0x0D
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core3_t20"
          "core3_t20"
          0x0E
          DAQ
          0xFF
          0x02
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core3_bg"
          "core3_bg"
          0x10
          DAQ
          0xFF
          0x05
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core3_t100"
          "core3_t10"
          0x0F
          DAQ
          0xFF
          0x01
          0x08
          0x00
        /end EVENT
        /begin EVENT
          "core4_t10"
          "core4_t10"
          0x11
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core4_t20"
          "core4_t20"
          0x12
          DAQ
          0xFF
          0x02
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core4_t100"
          "core4_t10"
          0x13
          DAQ
          0xFF
          0x01
          0x08
          0x00
        /end EVENT
        /begin EVENT
          "core4_bg"
          "core4_bg"
          0x14
          DAQ
          0xFF
          0x05
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core5_t10"
          "core5_t10"
          0x15
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core5_t20"
          "core5_t20"
          0x16
          DAQ
          0xFF
          0x02
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core5_t100"
          "core5_t10"
          0x17
          DAQ
          0xFF
          0x01
          0x08
          0x00
        /end EVENT
        /begin EVENT
          "core5_bg"
          "core5_bg"
          0x18
          DAQ
          0xFF
          0x05
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "VX113x.mon.xcpTlasy.freeTLBsSocket0"
          "VX113x.mo"
          0x8000
          DAQ
          0xFF
          0x01
          0x09
          0x00
        /end EVENT
        /begin EVENT
          "VX14xx.mon.aurix.aurora.phyDvCnt"
          "VX14xx.mo"
          0x8001
          DAQ
          0xFF
          0x01
          0x09
          0x00
        /end EVENT
        /begin EVENT
          "MEAS_OBJ_HIL_BYPASS_EV"
          "MEAS_OBJ_"
          0x1B
          DAQ
          0xFF
          0x05
          0x07
          0xFE
        /end EVENT
        /begin EVENT
          "STIM_OBJ_HIL_BYPASS_EV"
          "STIM_OBJ_"
          0x1C
          STIM
          0xFF
          0x05
          0x07
          0xFF
        /end EVENT
        /begin EVENT
          "core2_t50"
          "core2_t50"
          0x28
          DAQ
          0xFF
          0x05
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "core0_t50"
          "core0_t50"
          0x22
          DAQ
          0xFF
          0x05
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m7A341E75"
          "m7A341E75"
          0x60
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mF994493E"
          "mF994493E"
          0x61
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m8A9C8EBA"
          "m8A9C8EBA"
          0x62
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m15AB8D21"
          "m15AB8D21"
          0x63
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m6BEF78C0"
          "m6BEF78C0"
          0x64
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m37705A84"
          "m37705A84"
          0x65
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m35D9B1FF"
          "m35D9B1FF"
          0x66
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m8C5BDE2F"
          "m8C5BDE2F"
          0x67
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m5A94F4A1"
          "m5A94F4A1"
          0x68
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mAC17F8D1"
          "mAC17F8D1"
          0x69
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m84734F54"
          "m84734F54"
          0x6A
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mAA240047"
          "mAA240047"
          0x6B
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mA644C047"
          "mA644C047"
          0x6C
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m72A9680D"
          "m72A9680D"
          0x6D
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mEB21CDB8"
          "mEB21CDB8"
          0x6E
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m2D2E5609"
          "m2D2E5609"
          0x6F
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m3325390A"
          "m3325390A"
          0x70
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mA7A578A4"
          "mA7A578A4"
          0x71
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mD656D311"
          "mD656D311"
          0x72
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m7DDF19E6"
          "m7DDF19E6"
          0x73
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m650E30C0"
          "m650E30C0"
          0x74
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m68B1F925"
          "m68B1F925"
          0x75
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m9D9130A9"
          "m9D9130A9"
          0x76
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mD83B3204"
          "mD83B3204"
          0x77
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mE092094C"
          "mE092094C"
          0x78
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m3CA37603"
          "m3CA37603"
          0x79
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mDF571799"
          "mDF571799"
          0x7A
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m50D5DC26"
          "m50D5DC26"
          0x7B
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m89513841"
          "m89513841"
          0x7C
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mA5705C7D"
          "mA5705C7D"
          0x7D
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m1929C53A"
          "m1929C53A"
          0x7E
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mE5EA5DE3"
          "mE5EA5DE3"
          0x7F
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m57CE1E6D"
          "m57CE1E6D"
          0x80
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mA1E13654"
          "mA1E13654"
          0x81
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m05C7F6F4"
          "m05C7F6F4"
          0x82
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mFE89DA5C"
          "mFE89DA5C"
          0x83
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m07541D48"
          "m07541D48"
          0x84
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mA428B7EB"
          "mA428B7EB"
          0x85
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mE09DD5B2"
          "mE09DD5B2"
          0x86
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m9B4FA009"
          "m9B4FA009"
          0x87
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m27101580"
          "m27101580"
          0x88
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m132AF404"
          "m132AF404"
          0x89
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m31AF6F9F"
          "m31AF6F9F"
          0x8A
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mA7B93784"
          "mA7B93784"
          0x8B
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m0C03FF5E"
          "m0C03FF5E"
          0x8C
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mC341E42F"
          "mC341E42F"
          0x8D
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mFF777528"
          "mFF777528"
          0x8E
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mFDC80AFA"
          "mFDC80AFA"
          0x8F
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m14A55962"
          "m14A55962"
          0x90
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m9A5B2459"
          "m9A5B2459"
          0x91
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m6886390F"
          "m6886390F"
          0x92
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m784BD868"
          "m784BD868"
          0x93
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m7188F585"
          "m7188F585"
          0x94
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m790D3990"
          "m790D3990"
          0x95
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m2ABD273E"
          "m2ABD273E"
          0x96
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mEB8C65C2"
          "mEB8C65C2"
          0x97
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m8371D769"
          "m8371D769"
          0x98
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mB7DA73A2"
          "mB7DA73A2"
          0x99
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m5A19A22E"
          "m5A19A22E"
          0x9A
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mCFD4284D"
          "mCFD4284D"
          0x9B
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mDFDE97C7"
          "mDFDE97C7"
          0x9C
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mCB77E5D0"
          "mCB77E5D0"
          0x9D
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mF88C047E"
          "mF88C047E"
          0x9E
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m1B5BADD4"
          "m1B5BADD4"
          0x9F
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mDFBB62BE"
          "mDFBB62BE"
          0xA0
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m5D79D6C3"
          "m5D79D6C3"
          0xA1
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m855CCA98"
          "m855CCA98"
          0xA2
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mB9560014"
          "mB9560014"
          0xA3
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mBA3C92F5"
          "mBA3C92F5"
          0xA4
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mB29A7DE5"
          "mB29A7DE5"
          0xA5
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mF4A6B352"
          "mF4A6B352"
          0xA6
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mA9B93C39"
          "mA9B93C39"
          0xA7
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m34427138"
          "m34427138"
          0xA8
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mBCCD3E1F"
          "mBCCD3E1F"
          0xA9
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m5EA8D950"
          "m5EA8D950"
          0xAA
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m89797748"
          "m89797748"
          0xAB
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m92A80A8B"
          "m92A80A8B"
          0xAC
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m399DE383"
          "m399DE383"
          0xAD
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m1EF9BA4A"
          "m1EF9BA4A"
          0xAE
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m9FE0939F"
          "m9FE0939F"
          0xAF
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m981A6E69"
          "m981A6E69"
          0xB0
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m6A84EDC4"
          "m6A84EDC4"
          0xB1
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mA35AE844"
          "mA35AE844"
          0xB2
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mCDB1CC50"
          "mCDB1CC50"
          0xB3
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mFCFC6D76"
          "mFCFC6D76"
          0xB4
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m78FD6076"
          "m78FD6076"
          0xB5
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m04403CBF"
          "m04403CBF"
          0xB6
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m7E11BF38"
          "m7E11BF38"
          0xB7
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "mC8602CFC"
          "mC8602CFC"
          0xB8
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m164B1F3F"
          "m164B1F3F"
          0xB9
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m6CDCA8EC"
          "m6CDCA8EC"
          0xBA
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
        /begin EVENT
          "m74E3924E"
          "m74E3924E"
          0xBB
          DAQ
          0xFF
          0x01
          0x07
          0x00
        /end EVENT
      /end DAQ
      /begin PAG
        0x02
      /end PAG
      /begin PGM
        PGM_MODE_ABSOLUTE
        0xB0
        0x00
        /begin SECTOR
          ""
          0x00
          0x00
          0x01000000
          0x00
          0x00
          0x00
        /end SECTOR
      /end PGM
      /begin XCP_ON_TCP_IP
        0x0104
        0x15B3
        ADDRESS "192.168.0.2"
      /end XCP_ON_TCP_IP
    /end IF_DATA

    /begin IF_DATA CANAPE_ADDRESS_UPDATE
    /end IF_DATA

    /begin MEASUREMENT _FepMainDataPacket_st._OpMode ""
      UBYTE NO_COMPU_METHOD 0 0 0 255
      ECU_ADDRESS 0x5000E1B4
      ECU_ADDRESS_EXTENSION 0x0
      FORMAT "%.15"
      SYMBOL_LINK "_FepMainDataPacket_st._OpMode" 0
    /end MEASUREMENT
    /begin GROUP Aurix "Measurements when using Infineon Aurix"
      /begin REF_MEASUREMENT
        VX1000.POD.mon.aurix.aurora.rxFreqKHz VX1000.POD.mon.aurix.dapFreqkHz VX1000.POD.mon.aurix.errorMsgCnt VX1000.POD.mon.aurix.lastAddrBeforeEcuOverrun VX1000.POD.mon.aurix.retransmitCnt
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP BaseModule "VX1060, VX113x, VX1161.3x internal Measurements"
      /begin REF_MEASUREMENT
        VX1000.BM.mon.bmTemperature VX1000.BM.mon.monEvtCntDword VX1000.BM.mon.te.tfifo.extRamMaxByte VX1000.BM.mon.xcpSocket0.freeTLBs VX1000.BM.mon.xcpSocket1.freeTLBs VX1000.BM.mon.xcpSocket2.freeTLBs VX1000.BM.mon.xcpSocket3.freeTLBs
        VX1000.BM.mon.xcpe.evtFifoMax
      /end REF_MEASUREMENT
      /begin SUB_GROUP
        HSSL Serial
      /end SUB_GROUP
    /end GROUP

    /begin GROUP HSSL ""
      /begin REF_MEASUREMENT
        VX1000.BM.mon.hssl.TxFreqKHz VX1000.BM.mon.hssl.pipe0RxCnt VX1000.BM.mon.hssl.pipe1RxCnt VX1000.BM.mon.hssl.pipe2RxCnt VX1000.BM.mon.hssl.retransDLCnt VX1000.BM.mon.hssl.retransULCnt
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP Nexus "Measurements when using Nexus AUX Trace Interface of PowerPC MCUs"
      /begin REF_MEASUREMENT
        VX1000.POD.mon.nexus.aurora.rxFreqKHz VX1000.POD.mon.nexus.aux.freqKHz VX1000.POD.mon.nexus.ecuOverrunCnt VX1000.POD.mon.nexus.ecuStallCnt VX1000.POD.mon.nexus.lastAddrBeforeEcuOverrun
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP POD "VX14xx POD internal Measurements"
      /begin REF_MEASUREMENT
        VX1000.POD.mon.aurora.fifo.bufferUtilByte VX1000.POD.mon.aurora.fifo.din_fifo_usedw VX1000.POD.mon.aurora.fifo.dout_fifo_usedw VX1000.POD.mon.monEvtCntDword VX1000.POD.mon.pcie.overloadCnt VX1000.POD.mon.pod.temperature VX1000.POD.mon.trace.adconInputCnt
        VX1000.POD.mon.trace.adfilOutputCnt VX1000.POD.mon.traceBuffer.externalMax VX1000.POD.mon.traceBuffer.outMax
      /end REF_MEASUREMENT
      /begin SUB_GROUP
        Aurix Nexus RH850 RIF RTPDMM
      /end SUB_GROUP
    /end GROUP

    /begin GROUP RH850 "Measurements when using Renesas RH850 Data Trace"
      /begin REF_MEASUREMENT
        VX1000.POD.mon.rh850.aud.audFifoMax VX1000.POD.mon.rh850.aurora.rxFreqKHz VX1000.POD.mon.rh850.ecuOverrunCnt VX1000.POD.mon.rh850.lastAddrBeforeEcuOverrun VX1000.POD.mon.rh850.lastErrorMsgInfo
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP RIF "Measurements when using the Radar RAW Data Interface"
      /begin REF_MEASUREMENT
        VX1000.POD.mon.rif1.crcErrorCnt
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP RTPDMM "Measurements when using the TI TMS570 RTP/DMM Data Trace Interface"
      /begin REF_MEASUREMENT
        VX1000.POD.mon.rtpdmm.dmmFreqKHz VX1000.POD.mon.rtpdmm.dmmStopCnt VX1000.POD.mon.rtpdmm.rtpFreqKHz VX1000.POD.mon.rtpdmm.rtpStopCnt
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP Serial ""
      /begin REF_MEASUREMENT
        VX1000.BM.mon.serial.niosMaxDapLoad VX1000.BM.mon.serial.niosOldaOverruns VX1000.BM.mon.serial.targetIfRetryCounter
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP SystemInfo "VX1060, VX113x, VX1621, VX1161.3x internal Measurements"
      /begin REF_CHARACTERISTIC
        VX1000.sys.usrCustomer VX1000.sys.usrPosition VX1000.sys.usrProject VX1000.sys.usrSample
      /end REF_CHARACTERISTIC
      /begin REF_MEASUREMENT
        VX1000.sys.ecuEdJtagId VX1000.sys.ecuJtagId VX1000.sys.ecuProcName VX1000.sys.ecuProcNameLen VX1000.sys.fpgaLeftVer VX1000.sys.fpgaLeftVer.build VX1000.sys.fpgaLeftVer.major
        VX1000.sys.fpgaLeftVer.minor VX1000.sys.fwVer VX1000.sys.fwVer.build VX1000.sys.fwVer.major VX1000.sys.fwVer.minor VX1000.sys.parentArticleNumber VX1000.sys.parentSerialNumber VX1000.sys.podECUIdMiscNumber
        VX1000.sys.podECUIdMuster VX1000.sys.podECUIdPosition VX1000.sys.podECUIdProject VX1000.sys.podFpgaVer VX1000.sys.podFpgaVer.build VX1000.sys.podFpgaVer.major VX1000.sys.podFpgaVer.minor VX1000.sys.podFwVer
        VX1000.sys.podFwVer.build VX1000.sys.podFwVer.major VX1000.sys.podFwVer.minor VX1000.sys.podHwTypeRev VX1000.sys.podTemp VX1000.sys.podVX1902HwTypeRev VX1000.sys.podVX1902VectorSerNo VX1000.sys.podVectorArtNo
        VX1000.sys.podVectorSerNo VX1000.sys.upTimeS VX1000.sys.vectorArtNo VX1000.sys.vectorSerNo VX1000.sys.vx1161SlotNumber
      /end REF_MEASUREMENT
    /end GROUP

    /begin GROUP VX1000 "VX1000 Internal Signals"
      ROOT
      /begin SUB_GROUP
        BaseModule POD SystemInfo XPOD
      /end SUB_GROUP
    /end GROUP

    /begin GROUP XPOD "VX1621 internal Measurements"
      /begin REF_MEASUREMENT
        VX1000.xpod.ECU_IF_voltage VX1000.xpod.EMEM_voltage VX1000.xpod.Temperature VX1000.xpod.monEvtCntDword
      /end REF_MEASUREMENT
    /end GROUP

  /end MODULE

/end PROJECT
