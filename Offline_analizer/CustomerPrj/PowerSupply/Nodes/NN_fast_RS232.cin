/*@!Encoding:1252*/
/**
 * @file NN_fast_RS232.cin
 * @author ADAS_HIL_TEAM
 * @date 02-22-2023
 * @brief  Wrapper functions for RS232 access
 *
 * ################################################################
 * C O P Y R I G H T S
 * ----------------------------------------------------------------
 * Copyright (c) 2023 by Robert Bosch GmbH. All rights reserved.
 
 * The reproduction, distribution and utilization of this file as
 * well as the communication of its contents to others without express
 * authorization is prohibited. Offenders will be held liable for the
 * payment of damages. All rights reserved in the event of the grant
 * of a patent, utility model or design.
 *
 * ################################################################
*/

/**
 * @author       Manfred Rast (XC-DX/EET4)
 * @date         07.06.2022
 * @version      0.2
 *
 * @author       Manfred Rast (XC-DX/EET4)
 * @date         01.12.2022
 * @version      0.3\n
 *               Set the wait time g_Waittime after sending a request to 30 ms because of timing problems.\n
 *               New function dword cFX_rs232_Send(dword p_SerialPort, byte p_ByteBuffer[]).\n
 *               Debug output reduced.
 *
 * @brief Wrapper functions for RS232 access
 *
 * @details This module is using RS232 functions from Vector. The wrapper functions are adding test verdicts.
 *
 * @attention THIS IS A COMMON LIBRARY FILE AND MAY ONLY BE EDITED BY THOSE RESPONSIBLE FOR THE LIBRARY.
 */

includes
{
  #include "fast_Definitions.cin"
}

variables
{
  //! Maximum buffer size of the receive buffer
  const int g_rs232_BufferSize = 256;

  //! Maximum number of possible ports, this is the maximum number of COM ports in Windows OS
  const int g_rs232_MaxNoOfPorts = 256;

  //! Possible states of the RS232 state machine
  enum g_rs232_States
  {
    state_closed,
    state_opened,
    state_configured
  };

  struct g_s_SerialPort
  {
    //! Size of the last received data
    int receivedBufferSize;
    
    //! Contains the last data received.
    byte receiveBuffer[g_rs232_BufferSize];
  
    //! Contains the last data received from the ECU as a string.
    char receiveBufferString[g_rs232_BufferSize+1];
  
    //! Flag if data were received by function RS232OnReceive
    enum def_truefalse dataReceived;
    
    //! Flag if a carriage return has to be send after the previous send operation
    enum def_truefalse sendCR;
  
    //! Current state of the RS232 state machine per port, initialized with "state_closed"
    enum g_rs232_States state;
  };
  
  //! Array of serial ports
  struct g_s_SerialPort g_s_SerialPorts[g_rs232_MaxNoOfPorts];
  
  //! Encodings
  const dword CP_SHIFT_JIS = 932;
  const dword CP_UTF8 = 65001;
  const dword CP_UTF16 = 1200;
  const dword CP_LATIN1 = 1252;
  
  //! Wait time in ms after sending a request to the RS232 interface
  const byte g_Waittime = 50;
  msTimer genericWait;
  long rnd_flag;
  
  //added by TRP1SF / 13.02.2023
  const int out_arr_size = 256;
  
}

on preStart
{
  int i;
  
  /* Initialize the states of all ports
   */
  for(i=0; i<g_rs232_MaxNoOfPorts; i++)
  {
    g_s_SerialPorts[i].state              = state_closed;
    g_s_SerialPorts[i].receivedBufferSize = 0;
    g_s_SerialPorts[i].sendCR             = def_FALSE;
    g_s_SerialPorts[i].dataReceived       = def_FALSE;
  }
  
    
}

on timer genericWait
{
  
  //setTimer(genericWait, g_Waittime);
  
}

/**
 * Wrapper function for RS232Open().
 * For a description please see the Vector documentation.
 */
//dword cFX_rs232_Open(dword p_SerialPort)
//{
//  dword rc;

//  rc = RS232Open(p_SerialPort);
  
//  if(0!=rc)
//  {
//    g_s_SerialPorts[p_SerialPort].state = state_opened;
//    write("cFX_rs232_Open RS232 connection opened on port %d", p_SerialPort);
//    // call rs232_Receive() to start the receiption via RS232OnReceive()
//    cFX_rs232_Receive(p_SerialPort);
//  }
//  else
//  {
//    write("cFX_rs232_Open RS232 connection not opened on port %d, return code: %d", p_SerialPort, rc);
//  }
  
//  return rc;
//}


///**
// * Wrapper function for RS232Close().
// * For a description please see the Vector documentation.
// */
//dword cFX_rs232_Close(dword p_SerialPort)
//{
//  dword rc;

//  rc = RS232Close(p_SerialPort);
//  if(0!=rc)
//  {
//    g_s_SerialPorts[p_SerialPort].state = state_closed;
//    write("cFX_rs232_Close RS232 connection closed on port %d", p_SerialPort);
//  }
//  else
//  {
//    write("cFX_rs232_Close RS232 connection not closed on port %d, return code: %d", p_SerialPort, rc);
//  }

//  return rc;
//}


/**
 * Wrapper function for rs232_Configure().
 * For a description please see the Vector documentation.
 */
dword cFX_rs232_Configure(dword p_SerialPort, dword p_Baudrate, dword p_NumberOfDataBits, dword p_NumberOfStopBits, dword p_Parity)
{
  dword rc;

  write("cFX_rs232_Configure port: %d, baudrate: %d, numberOfDataBits: %d, numberOfStopBits: %d, parity: %d",
            p_SerialPort,
            p_Baudrate,
            p_NumberOfDataBits,
            p_NumberOfStopBits,
            p_Parity);

  rc = RS232Configure(p_SerialPort, p_Baudrate, p_NumberOfDataBits, p_NumberOfStopBits, p_Parity);
  if(0!=rc)
  {
    g_s_SerialPorts[p_SerialPort].state = state_configured;
    write("cFX_rs232_Configure RS232 connection configured on port %d", p_SerialPort);
  }
  else
  {
    write("cFX_rs232_Configure RS232 connection not configured on port %d, return code: %d", p_SerialPort, rc);
  }

  return rc;
}


/**
 * Wrapper function for rs232_Configure().
 * For a description please see the Vector documentation.
 */
dword cFX_rs232_Configure(dword p_SerialPort, dword p_Baudrate, dword p_NumberOfDataBits, dword p_NumberOfStopBits, dword p_Parity, dword p_EnableParityCheck)
{
  dword rc;
  
  write("cFX_rs232_Configure port: %d, baudrate: %d, numberOfDataBits: %d, numberOfStopBits: %d, parity: %d, enableParityCheck: %d",
            p_SerialPort,
            p_Baudrate,
            p_NumberOfDataBits,
            p_NumberOfStopBits,
            p_Parity,
            p_EnableParityCheck);

  rc = RS232Configure(p_SerialPort, p_Baudrate, p_NumberOfDataBits, p_NumberOfStopBits, p_Parity, p_EnableParityCheck);
  if(0!=rc)
  {
    g_s_SerialPorts[p_SerialPort].state = state_configured;
    write("cFX_rs232_Configure RS232 connection configured on port %d", p_SerialPort);
  }
  else
  {
    write("cFX_rs232_Configure RS232 connection not configured on port %d, return code: %d", p_SerialPort, rc);
  }

  return rc;
}


/**
 * Wrapper function for rs232_SetHandshake().
 * For a description please see the Vector documentation.
 */
dword cFX_rs232_SetHandshake(dword p_SerialPort, dword p_Handshake, dword p_XonLimit, dword p_XoffLimit, dword p_XonChar, dword p_XoffChar)
{
  dword rc;
  
  write("cFX_rs232_SetHandshake port: %d, handshake: %d, XonLimit: %d, XoffLimit: %d, XonChar: %d, XoffChar: %d",
            p_SerialPort,
            p_Handshake,
            p_XonLimit,
            p_XoffLimit,
            p_XonChar,
            p_XoffChar);

  rc =  RS232SetHandshake(p_SerialPort, p_Handshake, p_XonLimit, p_XoffLimit, p_XonChar, p_XoffChar);
  if(0!=rc)
  {
    write("cFX_rs232_SetHandshake Handshake parameters set on port %d", p_SerialPort);
  }
  else
  {
    write("cFX_rs232_SetHandshake Handshake parameters not set on port %d, return code: %d", p_SerialPort, rc);
  }

  return rc;
}


/**
 * Wrapper function for rs232_Send().
 * For a description please see the Vector documentation.
 */
//dword cFX_rs232_Send(dword p_SerialPort, char p_Text[])
//{
//  dword rc;
//  dword number;
//  byte  buffer[g_rs232_BufferSize];
//  int   i;

//  g_s_SerialPorts[p_SerialPort].dataReceived = def_FALSE;
  
//  number = strlen(p_Text);
//  if(number > g_rs232_BufferSize)
//  {
//    write("cFX_rs232_Send Size of input parameter \"p_Text\" is greater then %d", g_rs232_BufferSize);
//    rc = -1;
//  }
//  else
//  {
//    for (i=0;i<number;i++)
//    {
//      buffer[i]=p_Text[i];
//    }

////    //write("cFX_rs232_Send Sending on port %d: %s", p_SerialPort, p_Text);
//    rc = RS232Send(p_SerialPort, buffer, number);
//    if(1!=rc)
//    {
//      write("cFX_rs232_Send Send operation could not be started on port %d, return code: %d", p_SerialPort, rc);
//    }
//  }
//  write("DEBUG_____waiting");
//  setTimer(genericWait, g_Waittime);  
//  cFX_rs232_Receive(p_SerialPort);
//  return rc;
//}


/**
 * Wrapper function for rs232_Send().
 * For a description please see the Vector documentation.
 */
dword cFX_rs232_Send(dword p_SerialPort, byte p_ByteBuffer[])
{
  dword rc;
  int   i;
  char  bytesAsHexString[g_rs232_BufferSize*6];
  char  byteAsHex[10];

  g_s_SerialPorts[p_SerialPort].dataReceived = def_FALSE;

  bytesAsHexString[0] = '\0';
  
  // Only for debugging
  /*
  for(i=0; i<elCount(p_ByteBuffer); i++)
  {
    snprintf(byteAsHex, elcount(byteAsHex), "0x%X, ", p_ByteBuffer[i]);
    strncat(bytesAsHexString, byteAsHex, elcount(bytesAsHexString));
  }
  write("cFX_rs232_Send Sending byte array on port %d: %s", p_SerialPort, bytesAsHexString);
  */

  rc = RS232Send(p_SerialPort, p_ByteBuffer, elcount(p_ByteBuffer));
  if(1!=rc)
  {
    write("cFX_rs232_Send Send operation could not be started on port %d, return code: %d", p_SerialPort, rc);
  }
  write("DEBUG_____waiting");
  setTimer(genericWait, g_Waittime);
  cFX_rs232_Receive(p_SerialPort);
  return rc;
}


/** Check whether data were received from the COM port.
 *
 * @param[in] p_SerialPort The COM port to be checked.
 * @return def_TRUE if data were received, otherwise def_FALSE
 */
enum def_truefalse cFX_rs232_CheckDataReception(int p_SerialPort)
{
  return g_s_SerialPorts[p_SerialPort].dataReceived;
}


/**
 * Wrapper function for rs232_Send().
 * For a description please see the Vector documentation.
 */
//dword cFX_rs232_Send(dword p_SerialPort, byte p_Buffer[], dword p_Number)
//{
//  dword rc;
//  int   i;
//  char  bytesAsHexString[g_rs232_BufferSize*6];
//  char  byteAsHex[10];
  
//  g_s_SerialPorts[p_SerialPort].dataReceived = def_FALSE;

//  bytesAsHexString[0] = '\0';

//  // Only for debugging
//  /*
//  for(i=0; i<p_Number; i++)
//  {
//    snprintf(byteAsHex, 10, "0x%X, ", p_Buffer[i]);
//    strncat(bytesAsHexString, byteAsHex, elcount(bytesAsHexString));
//  }
//  write("cFX_rs232_Send Sending on port %d: %s", p_SerialPort, bytesAsHexString);
//  */

//  rc = RS232Send(p_SerialPort, p_Buffer, p_Number);
//  if(1!=rc)
//  {
//    write("cFX_rs232_Send Send operation could not be started on port %d, return code: %d", p_SerialPort, rc);
//  }
//  write("DEBUG_____waiting");
//  setTimer(genericWait, g_Waittime);
//  cFX_rs232_Receive(p_SerialPort);
//  return rc;
//}

/**
 * Wrapper function for rs232_Receive().
 * For a description please see the Vector documentation.
 */
//dword cFX_rs232_Receive(dword p_SerialPort)
//{
//  dword rc;
  
//  rc = RS232Receive(p_SerialPort, g_s_SerialPorts[p_SerialPort].receiveBuffer, elcount(g_s_SerialPorts[p_SerialPort].receiveBuffer));  
//  write("rc in RECEIVE: %d", rc);
//  write("HARD DEBUG in RECEIVE_________cFX_rscFX_rs232_GetLastReceivedDataAsStris = %s", ea_ps9040.received_data);
//  if(1!=rc)
//  {
//    write("rs232_Receive Receive operation could not be started on port %d, return code: %d", p_SerialPort, rc);
//  }
  
//  return rc;
//}


/**
 * Return the last received response from the power supply as a string.
 *
 * @param[in]  p_SerialPort  The serial port
 * @param[out] p_DataBuffer  The ast received response from the power supply as a string
 */
void cFX_rs232_GetLastReceivedDataAsString(int p_SerialPort, char p_DataBuffer[])
{
  write("HARD DEBUG _________cFX_rscFX_rs232_GetLastReceivedDataAsStris", p_SerialPort, ea_ps9040.received_data);
  //added by TRP1SF
  
  if(strlen(ea_ps9040.received_data)>0)
  {
    if(elcount(p_DataBuffer) < strlen(ea_ps9040.received_data)+1)
    {
      write("cFX_rs232_GetLastReceivedDataAsString p_DataBuffer is not big enough to hold all received data, truncated to %d characters",
                      elcount(p_DataBuffer));
    }
    snprintf(p_DataBuffer, elcount(p_DataBuffer), ea_ps9040.received_data);
  }
  else
  {
      write("cFX_rs232_GetLastReceivedDataAsString No data received on COM port %d", p_SerialPort);
  }
//  if(def_TRUE == g_s_SerialPorts[p_SerialPort].dataReceived)
//  {
//    if(elcount(p_DataBuffer) < strlen(g_s_SerialPorts[p_SerialPort].receiveBufferString)+1)
//    {
//      write("cFX_rs232_GetLastReceivedDataAsString p_DataBuffer is not big enough to hold all received data, truncated to %d characters",
//                      elcount(p_DataBuffer));
//    }
//    snprintf(p_DataBuffer, elcount(p_DataBuffer), g_s_SerialPorts[p_SerialPort].receiveBufferString);
//  }
//  else
//  {
//      write("cFX_rs232_GetLastReceivedDataAsString No data received on COM port %d", p_SerialPort);
//  }
}


/**
 * Return the last received response from the power supply as a byte array.
 *
 * @param[in]  p_SerialPort  The serial port
 * @param[out] p_ByteBuffer  The last received response from the power supply as a byte array
 */
void cFX_rs232_GetLastReceivedDataAsByteArray(int p_SerialPort, byte p_ByteBuffer[])
{
  int i;
  
  if(def_TRUE == g_s_SerialPorts[p_SerialPort].dataReceived)
  {
    if(elcount(p_ByteBuffer) < g_s_SerialPorts[p_SerialPort].receivedBufferSize)
    {
      write("cFX_rs232_GetLastReceivedDataAsByteArray p_ByteBuffer is not big enough to hold all received data, truncated to %d bytes",
                      g_s_SerialPorts[p_SerialPort].receivedBufferSize);
    }

    for(i=0; i<g_s_SerialPorts[p_SerialPort].receivedBufferSize; i++)
    {
      p_ByteBuffer[i] = g_s_SerialPorts[p_SerialPort].receiveBuffer[i];
    }
  }
  else
  {
      write("cFX_rs232_GetLastReceivedDataAsByteArray No data received on COM port %d", p_SerialPort);
  }
}


/**
 * Return the last received response from the power supply as a float value.
 *
 * @param[in]  p_SerialPort  The serial port
 * @param[out] p_FloatValue  The lsast received response from the power supply as a float value
 */
void cFX_rs232_GetLastReceivedDataAsFloat(int p_SerialPort, float &p_FloatValue)
{
  int rc;
  
  if(def_TRUE == g_s_SerialPorts[p_SerialPort].dataReceived)
  {
    rc = strtod(g_s_SerialPorts[p_SerialPort].receiveBufferString, p_FloatValue);
    
    if(rc<1)
    {
      write("cFX_rs232_GetLastReceivedDataAsFloat Could not convert response on COM port %d to float value: %s", p_SerialPort, g_s_SerialPorts[p_SerialPort].receiveBufferString);
    }
  }
  else
  {
      write("cFX_rs232_GetLastReceivedDataAsFloat No data received on COM port %d", p_SerialPort);
  }
}


/**
 * Return the last received response from the power supply as a float value.
 *
 * @param[in]  p_SerialPort  The serial port
 * @return     The last received response from the power supply as a float value
 */
float cFX_rs232_ReturnLastReceivedDataAsFloat(int p_SerialPort)
{
  int rc;
  float value;
  
  if(def_TRUE == g_s_SerialPorts[p_SerialPort].dataReceived)
  {
    rc = strtod(g_s_SerialPorts[p_SerialPort].receiveBufferString, value);
    
    if(rc<1)
    {
      write("cFX_rs232_GetLastReceivedDataAsFloat Could not convert response on COM port %d to float value: %s", p_SerialPort, g_s_SerialPorts[p_SerialPort].receiveBufferString);
    }
  }
  else
  {
      write("cFX_rs232_GetLastReceivedDataAsFloat No data received on COM port %d", p_SerialPort);
  }
  
  return value;
}


///**
// * Callback handler for completion of send operation to a serial port.
// * For a description please see the Vector documentation.
// *
// * @verdict @b Passed The handler will only be called for success. For errors RS232OnError will be called.
// */
//RS232OnSend(dword port, byte buffer[], dword number)
//{
//  dword rc;
//  byte CR[1];
  
//  CR[0] = 0x0D; // Carriage return
  
//  // Only for debugging
//  // write("RS232OnSend Sending was successful on port: %d", port);
  
//  if(def_TRUE == g_s_SerialPorts[port].sendCR)
//  {
//    rc = RS232Send(port, CR, 1);
//    if(1==rc)
//    {
//      write("rs232_Send Send operation of carriage return started properly on port %d", port);
//    }
//    else
//    {
//      write("rs232_Send Send operation of carriage return could not be started on port %d, return code: %d", port, rc);
//    }
//    // reset the global flag
//    g_s_SerialPorts[port].sendCR = def_FALSE;
//  }
//}

///**
// * Callback handler for reception of data at a serial port.
// * For a description please see the Vector documentation.
// *
// * The data of the buffer is copied into the global variable rs232_ReceiveBuffer.
// */
//RS232OnReceive(dword port, byte buffer[], dword number)
//{
//  char bytesAsHexString[g_rs232_BufferSize*6];
//  char byteAsHex[10];
//  int i;
//  long rc, rc2;
  
//  g_s_SerialPorts[port].receivedBufferSize = number;

//  bytesAsHexString[0] = '\0';
//  for(i=0; i<number; i++)
//  {
//    g_s_SerialPorts[port].receiveBuffer[i] = buffer[i];
    
//    // prepare for test report
//    snprintf(byteAsHex, elcount(byteAsHex), "0x%X, ", buffer[i]);
//    strncat(bytesAsHexString, byteAsHex, elcount(bytesAsHexString));
//  }
//  g_s_SerialPorts[port].dataReceived = def_TRUE;

//  // Only for debugging
//  write("RS232OnReceive Received data from port %d, length: %d: %s", port, number, bytesAsHexString);
  
//  rc = DecodeString(g_s_SerialPorts[port].receiveBufferString, number+1, buffer, number, CP_UTF8);
//  rc2 = DecodeString(ea_ps9040.received_data, number+1, buffer, number, CP_UTF8);
//  write("HARD_DEBUG_______ ea_ps9040.received_data resp?: %s", ea_ps9040.received_data);
  
//  if(0==rc)
//  {
//    // Only for debugging
//    write("RS232OnReceive Received data as string: %s", g_s_SerialPorts[port].receiveBufferString);
//  }
//  else
//  {
//    // Only for debugging
//    write("RS232OnReceive Output string not decoded from byte array, return code: %d", rc);
//  }
//}


///**
// * Callback handler for reception of errors at a serial port.
// * For a description please see the Vector documentation.
// *
// * @verdict @b Failed This function will be called only for errors.
// */
//RS232OnError(dword port, dword errorFlags)
//{
//  write("RS232OnError Sending or receiving was NOT successful on port: %d, errorFlags: 0x%X", port, errorFlags);
//}

