/*@!Encoding:1252*/
/**
 * @file voltage_control_generic.can
 * @author ADAS_HIL_TEAM
 * @date 09-12-2023
 * @brief 
 *
 * ################################################################
 * C O P Y R I G H T S
 * ----------------------------------------------------------------
 * Copyright (c) 2023 by Robert Bosch GmbH. All rights reserved.
 
 * The reproduction, distribution and utilization of this file as
 * well as the communication of its contents to others without express
 * authorization is prohibited. Offenders will be held liable for the
 * payment of damages. All rights reserved in the event of the grant
 * of a patent, utility model or design.
 *
 * ################################################################
*/

includes
{
	#include "TOE_PS_functions.cin" 
	#include "GW_PS_functions.cin" 
	#include "EA_PS_functions.cin" 
}
variables
{
  int voltage_off = 0;
  double voltage_on;
  timer klemme15_timer_sec;
  int ps_number;
  int previous_pm;
  int actual_pm;
  int previous_pm_cooldown_flag = 0;
  
  mstimer calculation_PowerMode_voltage_timer;
  msTimer ps_init;
  int calculation_PowerMode_voltage_timer_duration = 100;  
  int set_voltage_ongoing = 0;
  
   byte TextoutByte[100];
   byte TextinByte[100];
   char TextoutChar[100];      
   char TextinChar[100];
   int receiveKind = 0;
   char VoltValue[10];
   char CurrentValue[10];
   
  dword port;
  int voltage;
  int channel;
  int PS_Type = 2;
  // PS_Type = 0 if TOE
			// 1 if GW
			// 2 if EA
  
  dword RS232_comport = 3;
  dword RS232_handshake = 0;
  dword RS232_baudrate = 115200;
  dword RS232_databits = 8;
  dword RE232_stopbits = 1; 
  dword RS232_parity = 0;
  
  long lsend, lrecieve;
  int voltage_page_id;
  byte receiveBuffer[1000];

  double current_voltage, current_strom;
  msTimer display_voltage_Ch1_timer, display_voltage_Ch2_timer;
  msTimer display_current_Ch1_timer, display_current_Ch2_timer;
  
  int ECU_channel_1 = 1;
  int VX_channel_2 = 2;
   
  int CornerFL_ecu, FrontRadar_ecu, CornerFR_ecu, CornerRL_ecu, CornerRR_ecu,DASy_ecu,Camera_ecu;


}

on preStart
{

}

on start
{
  setTimer(ps_init, 500);
  //setTimer(calculation_PowerMode_voltage_timer,calculation_PowerMode_voltage_timer_duration);

  setTimer(display_voltage_Ch1_timer,500);
  setTimer(display_voltage_Ch2_timer,1000);  
  setTimer(display_current_Ch1_timer,750);
  setTimer(display_current_Ch2_timer,1250);  
}

on timer ps_init{
    PowerMode_Init();
}

////////////////////////////////////////////////////////
//read current status of the PS

on timer display_voltage_Ch1_timer
{
    channel = 1;
    receiveKind = 2;
    if (PS_Type == 0)
	{
		TOE_PS_select_channel(1);
		TOE_VoltageStatus(); 
	}
	else if (PS_Type == 1)
	{
		GW_VoltageStatus(1);
	}
	else if (PS_Type == 2)
	{
		EA_PS_DeviceStatus(0);
	}
  RS232Receive(RS232_comport,TextinByte,10 );
  setTimer(display_voltage_Ch1_timer,1000);
}

on timer display_voltage_Ch2_timer
{
   channel = 2;
   receiveKind = 2;
   if (PS_Type == 0)
	{
		TOE_PS_select_channel(2);
		TOE_VoltageStatus(); 
	}
	else if (PS_Type == 1)
	{
		GW_VoltageStatus(2);
	}
	else if (PS_Type == 2)
	{
		EA_PS_DeviceStatus(1);
	}
  RS232Receive(RS232_comport,TextinByte,10 );
  setTimer(display_voltage_Ch2_timer,1000);
}

on timer display_current_Ch1_timer
{
    channel = 1;
    receiveKind = 1;
    if (PS_Type == 0)
	{
		TOE_PS_select_channel(1);
		TOE_CurrentStatus();
	}
	else if (PS_Type == 1)
	{
		GW_CurrentStatus(1);
	}
  RS232Receive(RS232_comport,TextinByte,10 );
  setTimer(display_current_Ch1_timer,1000);
}

on timer display_current_Ch2_timer
{
   channel = 2;
   receiveKind = 1;
   if (PS_Type == 0)
	{
		TOE_PS_select_channel(2);
		TOE_CurrentStatus();
	}
	else if (PS_Type == 1)
	{
		GW_CurrentStatus(2);
	}
  RS232Receive(RS232_comport,TextinByte,10 );
  setTimer(display_current_Ch2_timer,1000);
}

// RS232OnSend(dword port, byte buffer[], dword number)
// {
	// lrecieve= RS232Receive(RS232_comport,receiveBuffer,11); 
	// if (receiveBuffer[1] == 0)
	// {
	// current_voltage= receiveBuffer[5]*256+receiveBuffer[6];
	// current_voltage = current_voltage*42/(256*100);
	// @PS::voltage_display_Ch1 = current_voltage;

	// current_strom = receiveBuffer[7]*256+receiveBuffer[8];
	// current_strom = current_strom*10/(256*100);
	// @PS::current_display_Ch1 = current_strom;
	// }

	// if (receiveBuffer[1] == 1)
	// {
	// current_voltage= receiveBuffer[5]*256+receiveBuffer[6];
	// current_voltage = current_voltage*42/(256*100);
	// @PS::voltage_display_Ch2 = current_voltage;

	// current_strom = receiveBuffer[7]*256+receiveBuffer[8];
	// current_strom = current_strom*10/(256*100);
	// @PS::current_display_Ch2 = current_strom;
	// setTimer(display_voltage_Ch2_timer,1000);
	// }

// }
  
///////////////////////////////////////////////////////////////////////////////////////////////////


/////////////// voltage panel /////////////////////////
////// initialization of voltage shown on panel
void PowerMode_Init(){
  @PS::EA_COM_port_open = 1;
  @PS::EA_PS_remote_control_Ch1 = 1;
  @PS::EA_PS_remote_control_Ch2 = 1;
  @PS::EA_PS_voltage_on_off_Ch1 = 1;
  @PS::EA_PS_voltage_on_off_Ch2 = 1;
  @PS::EA_PS_voltage_Ch1 = 14;
  @PS::EA_PS_voltage_Ch2 = 14;
    
  //DASy_ecu = Vehicle_Model::DASy_sim


//add here the initialisation of the ECU state (if real, simulated or off)
//example see below
  //Corner FL
  CornerFL_ecu = @Vehicle_Model::CRadarFL_sim;
  write("Corner FL %d",CornerFL_ecu);
  if (CornerFL_ecu == 0 || CornerFL_ecu == 1){
    @DS2824::Ch_24_Switch = 0;
  }
  if (CornerFL_ecu == 2){
    @DS2824::Ch_24_Switch = 1;
  }
}
  

////// setting voltage on the panel depending on the PowerMode
//add here the powermode systemvariable and the values
on timer calculation_PowerMode_voltage_timer{
   actual_pm = @sysvar::FD3_DAT_VSM_35D::ETAT_GMP_HAB_Rv;
   write("PM : %x",actual_pm);
  
 if ((actual_pm >= 1) && ( previous_pm < 1)){
     write("Klemme15 ECU will turned on");
     Klemme15_PowerSupply(voltage_on);
     previous_pm = @sysvar::FD3_DAT_VSM_35D::ETAT_GMP_HAB_Rv;
     previous_pm_cooldown_flag = 0;
     cancelTimer(klemme15_timer_sec);
     }
 if ((actual_pm <1) && (previous_pm >= 1)){
     write("Klemme15 ECU will turned off after 45 sec");
     setTimer(klemme15_timer_sec, 45);
     previous_pm = @sysvar::FD3_DAT_VSM_35D::ETAT_GMP_HAB_Rv;
     previous_pm_cooldown_flag = 1;
    }
 if ((actual_pm <1) && previous_pm_cooldown_flag == 0){
     Klemme15_PowerSupply(voltage_off);
     cancelTimer(klemme15_timer_sec);
    }
 if ((actual_pm >=1) && previous_pm_cooldown_flag == 0){
     Klemme15_PowerSupply(voltage_on);
     cancelTimer(klemme15_timer_sec);
    }
}


////// Voltage Control for EA PS
on sysvar sysvar::FD3_DAT_VSM_35D::ETAT_GMP_HAB_Rv //add here the powermode systemvariable
{
  setTimer(calculation_PowerMode_voltage_timer,calculation_PowerMode_voltage_timer_duration);
}

on timer klemme15_timer_sec
{
  write("PowerKlemme15 will shut off now (45 sec elapsed");
  Klemme15_PowerSupply(voltage_off);
  previous_pm_cooldown_flag = 0;
}

void Klemme15_PowerSupply(int voltage)
{
  
// add here the ECUs which needs to be set off if Kl15 is on or off
// use relaycard switches for this. 
//input is "voltage_on" ==14 or "voltage_off" == 0

}

on sysvar sysvar::PS::EA_COM_port_open{
  if (@this==1){
  
  connect_powersupply(@sysvar::PS::EA_COM_port); // itt módosítani ha nem jó
  rs232_Configure(@sysvar::PS::EA_COM_port);
  }
}

on sysvar sysvar::PS::EA_COM_port_close{
  if (@this==1){
  rs232_close_comport(@sysvar::PS::EA_COM_port);
  }
}

on sysvar_update sysvar::PS::EA_PS_voltage_Ch1{
	if (PS_Type == 0)
	{
		TOE_PS_select_channel(1);
		TOE_PS_set_voltage( @sysvar::PS::EA_PS_voltage_Ch1);
	}
	else if (PS_Type == 1)
	{
		GW_PS_set_voltage( @sysvar::PS::EA_PS_voltage_Ch1, 1);
	}
	else if (PS_Type == 2)
	{
		EA_PS_set_voltage( @sysvar::PS::EA_PS_voltage_Ch1, @sysvar::PS::EA_COM_port,ECU_channel_1);
	}
}

on sysvar_update sysvar::PS::EA_PS_voltage_Ch2{
	if (PS_Type == 0)
	{
		TOE_PS_select_channel(2);
		TOE_PS_set_voltage( @sysvar::PS::EA_PS_voltage_Ch2);
	}
	else if (PS_Type == 1)
	{
		GW_PS_set_voltage( @sysvar::PS::EA_PS_voltage_Ch2, 2);
	}
	else if (PS_Type == 2)
	{
		EA_PS_set_voltage( @sysvar::PS::EA_PS_voltage_Ch2, @sysvar::PS::EA_COM_port,VX_channel_2);
	}
}

on sysvar sysvar::PS::EA_PS_voltage_on_off_Ch1{
  if (@this == 0){
	if (PS_Type == 0)
	{
		TOE_PS_VoltageOFF();
	}
	else if (PS_Type == 1)
	{
		GW_PS_VoltageOFF();
	}
	else if (PS_Type == 2)
	{
		EA_PS_VoltageOFF(@sysvar::PS::EA_COM_port,ECU_channel_1);
	} 
  }
  else{
	if (PS_Type == 0)
	{
		TOE_PS_VoltageON();
	}
	else if (PS_Type == 1)
	{
		GW_PS_VoltageON();
	}
	else if (PS_Type == 2)
	{
		EA_PS_VoltageON(@sysvar::PS::EA_COM_port,ECU_channel_1);
	}  
  }
  if (PS_Type == 0 || PS_Type == 1) @sysvar::PS::EA_PS_voltage_on_off_Ch2 = @sysvar::PS::EA_PS_voltage_on_off_Ch1;
}

on sysvar sysvar::PS::EA_PS_voltage_on_off_Ch2{
  if (@this == 0){
	if (PS_Type == 0)
	{
		TOE_PS_VoltageOFF();
	}
	else if (PS_Type == 1)
	{
		GW_PS_VoltageOFF();
	}
	else if (PS_Type == 2)
	{
		EA_PS_VoltageOFF(@sysvar::PS::EA_COM_port,VX_channel_2);
	}  
  }
  else{
	if (PS_Type == 0)
	{
		TOE_PS_VoltageON();
	}
	else if (PS_Type == 1)
	{
		GW_PS_VoltageON();
	}
	else if (PS_Type == 2)
	{
		EA_PS_VoltageON(@sysvar::PS::EA_COM_port,VX_channel_2);
	}    
  }
  if (PS_Type == 0 || PS_Type == 1) @sysvar::PS::EA_PS_voltage_on_off_Ch1 = @sysvar::PS::EA_PS_voltage_on_off_Ch2;
}

on sysvar sysvar::PS::EA_PS_remote_control_Ch1{
  if (@this == 0){
	if (PS_Type == 0)
	{
		TOE_PS_ManualControl();
	}
	else if (PS_Type == 1)
	{
		GW_PS_ManualControl();
	}
	else if (PS_Type == 2)
	{
		EA_PS_ManualControl(@sysvar::PS::EA_COM_port,ECU_channel_1);
	}    
  }
  else{
	if (PS_Type == 0)
	{
		TOE_PS_RemoteControl();
	}
	else if (PS_Type == 1)
	{
		GW_PS_RemoteControl();
	}
	else if (PS_Type == 2)
	{
		EA_PS_RemoteControl(@sysvar::PS::EA_COM_port,ECU_channel_1);
	} 
  }
  if (PS_Type == 0 || PS_Type == 1) @sysvar::PS::EA_PS_remote_control_Ch2 = @sysvar::PS::EA_PS_remote_control_Ch1;
}

on sysvar sysvar::PS::EA_PS_remote_control_Ch2{
  if (@this == 0){
	if (PS_Type == 0)
	{
		TOE_PS_ManualControl();
	}
	else if (PS_Type == 1)
	{
		GW_PS_ManualControl();
	}
	else if (PS_Type == 2)
	{
		EA_PS_ManualControl(@sysvar::PS::EA_COM_port,VX_channel_2);
	}    
  }
  else{
	if (PS_Type == 0)
	{
		TOE_PS_RemoteControl();
	}
	else if (PS_Type == 1)
	{
		GW_PS_RemoteControl();
	}
	else if (PS_Type == 2)
	{
		EA_PS_RemoteControl(@sysvar::PS::EA_COM_port,VX_channel_2);
	} 
  }
  if (PS_Type == 0 || PS_Type == 1) @sysvar::PS::EA_PS_remote_control_Ch1 = @sysvar::PS::EA_PS_remote_control_Ch2;
}

/////// relaiscard control 
// add here the mapping between the switches and the current state of the ECU (if real, simulated or off)
// example see below

on sysvar_update Vehicle_Model::CRadarFL_sim{
  if (@this == 0 || @this == 1){
    @DS2824::Ch_24_Switch = 0;
  }
  if (@this == 2){
    @DS2824::Ch_24_Switch = 1;
  }
}

////////////supporting functions

void connect_powersupply(int RS232_comport)
{
  long lRes=1;
  lRes= RS232Open(RS232_comport);
  if ( 0 == lRes)
  {                         
    write("RS232:: An error occurred during opening of the serial port %d.", RS232_comport);
  }
  else
  {                    
     write("RS232:: Serial port %d successfully opened.", RS232_comport);
  }
}

void rs232_close_comport(dword RS232_comport)
{
  long lRes=1;
  if (RS232_comport != 20) {
    lRes= RS232Close(RS232_comport);
    if ( 0 == lRes)
    {                         
      write("RS232::An error occurred during closing of the serial port %d", RS232_comport);
    }
    else
    {                    
      write("RS232:: Serial port %d successfully closed.", RS232_comport);
    }
  }
}

void rs232_Configure(dword port)
{
  long lRes=1;
  lRes = RS232Configure(    port,
                            RS232_baudrate,
                            RS232_databits,
                            RE232_stopbits,
                            RS232_parity) ;
}

SendToCOM (char f_message[])
{
    int j, result;
    
    //convert command string to byte[]
    for(j=0;f_message[j]>0;j++)            
    {
        TextoutByte[j]=f_message[j];
    }

    //end character 0x0a
    TextoutByte[j]=10;
    
    //send to COM port        
    result = RS232Send(RS232_comport,TextoutByte,strlen(f_message)+1);
    
    
    //write report to write window
    if (1!=result)
    {   
        write("Message %s not sent, error code> %d",f_message,result);
    } 
    //else write("%s was sent",f_message);
}

//Callback function to receive the answer of the voltage supply.
RS232OnReceive( dword port, byte buffer[],  dword receiveBufferLength )
{
  	int i;
  	int j;
  	float measValue_f;
    int pos;
    char temp[10];
  
    pos=0;
    j=0;
    snprintf(temp,elcount(temp),"");
		
		for (i=0; i<receiveBufferLength; i++)
		{
  			TextinChar[i] = buffer[i];
  			buffer[i] = 0;
		}
		
		switch (receiveKind)
		{
  			// '1'= read out actual current
  			case 1:
          strncat(CurrentValue,TextinChar,elcount(CurrentValue));
		  //write("CURR_PART:%s", CurrentValue);
		  if(PS_Type == 1)
		  {
			  if(strstr(CurrentValue,"A") != -1) 
			  {
				  measValue_f = atodbl(CurrentValue);
				  //write("CURR: %f", measValue_f);
				  if(channel == 1) @PS::current_display_Ch1 = measValue_f;
				  else if(channel == 2) @PS::current_display_Ch2 = measValue_f;
						  
				  for(i=0; CurrentValue[i]!='\0'; ++i)
				  {
					CurrentValue[i] = '\0';
				  }
			  }
		  }
		  else
		  {
			  pos=strstr(CurrentValue,".");
			  if(pos != -1)
			  {
				  substr_cpy(temp, CurrentValue, 2, -1, elcount(temp));
				  while(temp[j]) j++;
				  if(j > 2)
				  {
					  measValue_f = atodbl(CurrentValue);	
					  if(measValue_f < 6 )
					  {
						  //write("CURR: %f", measValue_f);
						  if(channel == 1) @PS::current_display_Ch1 = measValue_f;
						  else if(channel == 2) @PS::current_display_Ch2 = measValue_f;
						  
						  for(i=0; CurrentValue[i]!='\0'; ++i)
						  {
							CurrentValue[i] = '\0';
						  }
					  }
				  }
			  }
		  }
  				break;

  			// '2'= read out actual voltage
  			case 2:
          strncat(VoltValue,TextinChar,elcount(VoltValue));
		  //write("VOLT_PART:%s", VoltValue);
		  if(PS_Type == 1)
		  {
			  if(strstr(VoltValue,"V") != -1) 
			  {
				  measValue_f = atodbl(VoltValue);
				  //write("VOLT: %f", measValue_f);
				  if(channel == 1) @PS::voltage_display_Ch1 = measValue_f;
				  else if(channel == 2) @PS::voltage_display_Ch2 = measValue_f;
						  
				  for(i=0; VoltValue[i]!='\0'; ++i)
				  {
					VoltValue[i] = '\0';
				  }
			  }
		  }
		  else if(PS_Type == 2)
		  {
			  if (TextinChar[1] == 0)
				{
				current_voltage= TextinChar[5]*256+TextinChar[6];
				current_voltage = current_voltage*42/(256*100);
				@PS::voltage_display_Ch1 = current_voltage;

				current_strom = TextinChar[7]*256+TextinChar[8];
				current_strom = current_strom*10/(256*100);
				@PS::current_display_Ch1 = current_strom;
				}

				if (TextinChar[1] == 1)
				{
				current_voltage= TextinChar[5]*256+TextinChar[6];
				current_voltage = current_voltage*42/(256*100);
				@PS::voltage_display_Ch2 = current_voltage;

				current_strom = TextinChar[7]*256+TextinChar[8];
				current_strom = current_strom*10/(256*100);
				@PS::current_display_Ch2 = current_strom;
				// setTimer(display_voltage_Ch2_timer,1000);
				}
		  }
		  else
		  {
			  pos=strstr(VoltValue,".");
			  if(pos != -1)
			  {
				  substr_cpy(temp, VoltValue, 2, -1, elcount(temp));
				  while(temp[j]) j++;
				  if(j > 2)
				  {
					  measValue_f = atodbl(VoltValue);	
					  if(measValue_f < 60 && measValue_f > 2 || measValue_f == 0)
					  {
						  //write("VOLT: %f", measValue_f);
						  if(channel == 1) @PS::voltage_display_Ch1 = measValue_f;
						  else if(channel == 2) @PS::voltage_display_Ch2 = measValue_f;
						  
						  for(i=0; VoltValue[i]!='\0'; ++i)
						  {
							VoltValue[i] = '\0';
						  }
					  }
				  }
			  }
          }
          break;
          
		}

		for (i=0; i<100; i++)
		{
			  TextinChar[i] = '\0';
		}
}