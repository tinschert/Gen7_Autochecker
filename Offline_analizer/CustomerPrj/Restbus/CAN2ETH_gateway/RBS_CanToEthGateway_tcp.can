/*@!Encoding:1252*/
/**
 * @file RBS_CanToEthGateway_tcp.can
 * @author ADAS_HIL_TEAM
 * @date 11-16-2023
 * @brief 
 *
 * ################################################################
 * C O P Y R I G H T S
 * ----------------------------------------------------------------
 * Copyright (c) 2023 by Robert Bosch GmbH. All rights reserved.
 
 * The reproduction, distribution and utilization of this file as
 * well as the communication of its contents to others without express
 * authorization is prohibited. Offenders will be held liable for the
 * payment of damages. All rights reserved in the event of the grant
 * of a patent, utility model or design.
 *
 * ################################################################
*/

variables
{
  TcpSocket gClientSocket;//RBS
  TcpSocket gServerSocket;//Ecu
  
  dword gClientTcpPort = 0x76C0; // Client/RBS port
  dword gServerTcpPort = 0x76C6; // Server/ECu port
  
  dword gClientTcpAddress = 0;   // Client/RBS IP address 
  dword gServerTcpAddress = 0;   // Server/ECu IP address 
  
  msTimer test;
  int test_cnt;
  
  char      gRxBuffer[1500];
}

on preStart
{
  gClientTcpAddress=ipGetAddressAsNumber("192.168.100.80");// Client/RBS IP address
  gServerTcpAddress=ipGetAddressAsNumber("192.168.100.70");// Server/ECu IP address 
  
  gClientTcpPort = 0x76C0; // Client/RBS port
  gServerTcpPort = 0x76C6; // Server/ECu port
  
  RemoveClientInterfaceAddresses();
}

on start
{
  AddClientInterfaceAddresses();
  OpenClientSocket();
}

on preStop
{
  gClientSocket.Close();
  gServerSocket.Close();
  RemoveClientInterfaceAddresses();
}


void OpenClientSocket()
{
  CHAR errorText[200];
 
  // Create TCP socket and listen
  gClientSocket = TcpSocket::Open( gClientTcpAddress, gClientTcpPort); // RBS IP address with Port
  
  if (gClientSocket.GetLastSocketError() != 0)
  {
    gClientSocket.GetLastSocketErrorAsString( errorText, elcount(errorText) );
    write( "Client[CAN-Eth gateway] :: TcpSocket :: Open failed, %s (Result %d)", errorText, gClientSocket.GetLastSocketError() );
    return;
  }
  
//  gClientSocket.Connect( gServerTcpAddress, gServerTcpPort);// Connect to server/Ecu
    
//  if ((gClientSocket.GetLastSocketError() != 0) && (gClientSocket.GetLastSocketError() != 10035))
//  {
//     char errorString[100];
      
//     // if ReceiveFrom fails, we print a message to the write window
//     gClientSocket.GetLastSocketErrorAsString( errorString, elcount(errorString) );
//     write( "<%BASE_FILE_NAME%> TCPSocket::Connect failed with result %d (%s)", gClientSocket.GetLastSocketError(), errorString );
//  }
  
  gClientSocket.Listen();// Begin listening on TCP port.
}

//void OnTcpConnect( dword socket, long result)// Callback is called, when the client as successfully connect to server
//{
//  if (result == 0)
//  {
    
//    gClientSocket.Receive( gRxBuffer, elcount(gRxBuffer) );// To receive data with the created socket, we have to call ReceiveFrom.
    
//    if ((gClientSocket.GetLastSocketError() != 0) && (gClientSocket.GetLastSocketError() != 997))
//    {
//      char errorString[100];
      
//      // if ReceiveFrom fails, we print a message to the write window
//      gClientSocket.GetLastSocketErrorAsString( errorString, elcount(errorString) );
//      write( "<%BASE_FILE_NAME%> Receive failed with result %d (%s)", gClientSocket.GetLastSocketError(), errorString );
//    }
//  }
//}

void OnTcpListen( dword socket, long result)// Callback OnTcpListen is called on incomming connect request.
{
  if (result == 0)
  {
    if (gServerSocket)
    {
      dword socket;
      socket = TcpAccept( socket );// if there is already a client connected, close immediatelly.
      TcpClose( socket );
    }
    else
    {
      gServerSocket = TcpSocket::Accept(gClientSocket);// Accept connection request and setup gServerSocket
      gServerSocket.Receive( gRxBuffer, elcount(gRxBuffer) ); // to recieve data from the socket, we have to call TCPReceive.
      
      // if ReceiveFrom does not immediatelly copy to to gRxBuffer, it returns 997 to
      // indicate it will call the callback function OnUdpReceiveFrom later.
      if ((gServerSocket.GetLastSocketError() != 0) && (gServerSocket.GetLastSocketError() != 997))
      {
        char errorString[100];
        // if ReceiveFrom fails, we print a message to the write window
        gServerSocket.GetLastSocketErrorAsString( errorString, elcount(errorString) );
        write( "<%BASE_FILE_NAME%> ReceiveFrom failed with result %d (%s)", gServerSocket.GetLastSocketError(), errorString );
      }
    }
  }
}
void OnTcpReceive( TcpSocket socket, long result, dword address, dword port, byte buffer[], dword size)// Callback function, which is called if a TCP packet was received
{
  message * msg; 
  int i,k;
  k=i=0;
  if (result == 0)
  {
      msg.id=toDwordBigEndian(buffer,0);
      k=k+4;
      msg.dlc = buffer[k++];//dlc
      msg.msgChannel = buffer[k++];//channel
      for(i=0;i<size-6;i++)
      {
        msg.byte(i)=buffer[k++];
      }
      output(msg);
  }
  
//  if(socket == gClientSocket)
//  {
//    gClientSocket.Receive( gRxBuffer, elcount(gRxBuffer) );// To receive data with the socket via Connect, we have to call ReceiveFrom.
//  }
  if(socket == gServerSocket)
  {
    gServerSocket.Receive( gRxBuffer, elcount(gRxBuffer) );// To receive data with the socket via Listen, we have to call ReceiveFrom..
  }
  
}

void OnTcpClose( dword socket, long result)// OnTcpClose is called, when the server close the connection.
{
  if (result == 0)
  {
    gServerSocket.Close();// Client has close the socket, so we can relase our gServerSocket object.
  }
}

void AddClientInterfaceAddresses()
{
  dword result;
  dword interfaceIndex;
  dword ipv4Address;
  dword netmask;
  char ipv4AddrStr[16];  // an IPv4Addr string buffer

  ipv4Address=gClientTcpAddress;
  //ipv4Address=ipGetAddressAsNumber("192.168.40.2");
  
  interfaceIndex =  1;
  
  netmask = ipGetAddressAsNumber("255.0.0.0");
  //netmask = ipGetAddressAsNumber("255.255.255.0");
  
  result= ipAddAdapterAddress(interfaceIndex, ipv4Address, netmask);
  if( result != 0 )
  {
    write( "Client[CAN-Eth gateway] :: IpAddAdapterAddress failed, error code %d, last error %d", result, IpGetLastError());
  }else{
        result = IpGetAddressAsString( ipv4Address, ipv4AddrStr, elcount(ipv4AddrStr) );
        write( "Client[CAN-Eth gateway] :: Interface Added with IP:%s",  ipv4AddrStr);
  }
}

void RemoveClientInterfaceAddresses()
{
  dword result;
  dword interfaceIndex;
  dword ipv4Address;
  dword netmask;
  char ipv4AddrStr[16];  // an IPv4Addr string buffer

  ipv4Address=gClientTcpAddress;
  //ipv4Address=ipGetAddressAsNumber("192.168.40.2");
    
  interfaceIndex =  1;

  netmask = ipGetAddressAsNumber("255.0.0.0");
  //netmask = ipGetAddressAsNumber("255.255.255.0");
  
  result= ipRemoveAdapterAddress(interfaceIndex, ipv4Address, netmask);
  if( result != 0 )
  {
      write( "Client[CAN-Eth gateway] :: IpRemoveAdapterAddress failed, error code %d, last error %d",result, IpGetLastError());
  }else{
          result = IpGetAddressAsString( ipv4Address, ipv4AddrStr, elcount(ipv4AddrStr) );
          write( "Client[CAN-Eth gateway] :: Interface Removed with IP:%s", ipv4AddrStr);
  }
}


on message *
{
  byte Data[70];//
  dword dword_value;
  int64 i,k;
  
  k=i=0;
  dword_value=0;
  if(this.dir == rx)//Simulated
  {
    if(this.id!=0x1FF)
    {
      dword_value=this.id;
   
      Data[k++]=dword_value>>24;//Big-Endian
      Data[k++]=dword_value>>16;//Big-Endian
      Data[k++]=dword_value>>8; //Big-Endian
      Data[k++]=dword_value;    //Big-Endian
    
      //write("%x %x,channel %d",dword_value,this.id,this.MsgChannel);
      //write("On Message ::%x %x %x %x",Data[0],Data[1],Data[2],Data[3]);    
      Data[k++]=this.dlc;
    
      Data[k++]=this.MsgChannel;
      
      for(i=0;i<this.DataLength;i++)
      {
        Data[k++]=this.byte(i);
      }
      TriggerTcpData(Data,this.DataLength+6);
    }
  }
}
on key '1'
{
//  int i;
//  byte Data[10]={1,2,3,4,5,6,7,8,9,10};
//  for(i=0;i<10;i++)
//  {
//    Data[0]=i;
//    TriggerTcpData(Data,10);
//  }
  test_cnt=0;
  setTimer(test,10);
}

on timer test
{
  /*
  byte Data[10]={1,2,3,4,5,6,7,8,9,10};
  if(test_cnt<10)
  {
    Data[0]=test_cnt;
    TriggerTcpData(Data,10);
    test_cnt++;
    setTimer(test,10);
  }
  */
}
void TriggerTcpData(byte Data[],word DataLength)
{
 
  CHAR errorText[200];
   
  if (gServerSocket)
  {
    if(gServerSocket.Send(Data, DataLength)!=-1 ) 
    {
      if (gServerSocket.GetLastSocketError() != 0)
      {
        if(gServerSocket.GetLastSocketError()!=997)
        {  
          gServerSocket.GetLastSocketErrorAsString( errorText, elcount(errorText) );
          write( "RBS-Client[CAN-Eth gateway] TcpSend failed, %s (Result %d)", errorText, gServerSocket.GetLastSocketError() );
        }
      }else{ 
             write("TriggerTcpData Message id : %X",toDwordBigEndian(Data,0)); 
            //write("RBS-Client[CAN-Eth gateway]: sent Request");
           }
    }else{
          //write("Client[CAN-Eth gateway]: not sent Request");
          }
  }else{
          write("Client[CAN-Eth gateway]: Invalid Tcp Socket");
       }
}
//ToDword
qword toDwordLittleEndian(byte buffer[],int64 index)//Input 4 bytes 
{
  dword dw;
  int i;
  
  dw=0;
  for(i=0;i<4;i++){
  dw=(dw|(buffer[index+i]<<(8*i)));//Little Endian
  }
  return dw;
}

dword toDwordBigEndian(byte buffer[],int64 index)//Input 4 bytes 
{
  dword dw;
  int i;
  
  dw=0;
  for(i=3;i>=0;i--){
  dw=(dw|(buffer[index+3-i]<<(8*i)));//Big Endian
  }
  return dw;
}