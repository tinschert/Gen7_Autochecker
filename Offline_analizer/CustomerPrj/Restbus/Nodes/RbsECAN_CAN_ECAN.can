/*@!Encoding:1252*/
/**
 * @file RbsECAN_CAN_ECAN.can
 * @author ADAS_HIL_TEAM
 * @date 03-16-2023
 * @brief 
 *
 * ################################################################
 * C O P Y R I G H T S
 * ----------------------------------------------------------------
 * Copyright (c) 2023 by Robert Bosch GmbH. All rights reserved.
 
 * The reproduction, distribution and utilization of this file as
 * well as the communication of its contents to others without express
 * authorization is prohibited. Offenders will be held liable for the
 * payment of damages. All rights reserved in the event of the grant
 * of a patent, utility model or design.
 *
 * ################################################################
*/

// Autogenerated by -> Platform\Classe\Scripts\Rbs_Scripts\create_nodes.py
includes
{
  #pragma library ("C:\ProgramData\Vector\AddOn Packages\Vector AddOn\vModules\CANoeILNLVector.vmodule")
  #include "CAPL\DataHandling.cin" /*DataHandling for IL*/
  #include "CAPL\E2E.cin" /*OD Specific for CRC calculation */
}

variables {
  message ESP_02 Msg_ESP_02;
  message EPB_01 Msg_EPB_01;
  message ESP_05 Msg_ESP_05;
  message ESP_10 Msg_ESP_10;
  message Motor_20 Msg_Motor_20;
  message Gateway_72 Msg_Gateway_72;
  message LWI_01 Msg_LWI_01;
  message Getriebe_11 Msg_Getriebe_11;
  message ESP_19 Msg_ESP_19;
  message ESP_21 Msg_ESP_21;

  word counter_ESP_02_ESP_02_BZ;
  word counter_EPB_01_EPB_01_BZ;
  word counter_ESP_05_ESP_05_BZ;
  word counter_ESP_10_ESP_10_BZ;
  word counter_Motor_20_Motor_20_BZ;
  word counter_LWI_01_LWI_01_BZ;
  word counter_Getriebe_11_Getriebe_11_BZ;
  word counter_ESP_21_ESP_21_BZ;

  byte crc_ESP_02_ESP_02_CRC;
  byte crc_EPB_01_EPB_01_CRC;
  byte crc_ESP_05_ESP_05_CRC;
  byte crc_ESP_10_ESP_10_CRC;
  byte crc_Motor_20_Motor_20_CRC;
  byte crc_LWI_01_LWI_01_CRC;
  byte crc_Getriebe_11_Getriebe_11_CRC;
  byte crc_ESP_21_ESP_21_CRC;

}

on preStart {
  long result;
  result=ILControlInit ();//Initialization of CANoe IL,to prevent the IL autostart function.
  switch(result)
  {
    case  0   : write("ILControlInit :: RbsECAN :: No error."); break;
    case -1   : write("ILControlInit :: RbsECAN :: Momentary state of the IL does not permit this query."); break;
    case -50  : write("ILControlInit :: RbsECAN :: Nodelayer is inactive - possibly deactivated in the nodes configuration dialog.");  break;
   }

  RbsECAN_sim_Disable();
  RbsECAN_sim_SetCycleTimeOffset();
}

on start {

  ILControlSimulationOn();//Starts the simulation of the IL.
  RbsECAN_sim_SetCANFDParameter();
  ILControlStart ();//Cyclical sending starts; setting signals is now possible.
  RbsECAN_sim_Reset();
}

on stopMeasurement {

  RbsECAN_sim_DisableMsg();
  RbsECAN_sim_Disable();
  ILControlStop();//Cyclical sending is stopped; setting signals is now no longer possible.
  ILControlSimulationOff();//Stops the simulation of the IL. After that no other function to control the IL has an effect to the IL.

}

on sysvar_update hil_ctrl::ecan_sim
{
  RbsECAN_sim_Reset();
}

on sysvar_update hil_ctrl::variant
{
  RbsECAN_sim_Reset();
}

on sysvar_update Cus_bus::bus_CAN_ECAN_ON_OFF
{
  RbsECAN_sim_Reset();
}

void RbsECAN_sim_Reset()
{

  RbsECAN_sim_DisableMsg();
  RbsECAN_sim_Disable();

  if ((@Cus_bus::bus_CAN_ECAN_ON_OFF == 1) && (@hil_ctrl::ecan_sim == 1))
  {
    switch(@hil_ctrl::variant)
    {
      case a_variant:RbsECAN_sim_start_a_variant();break;
      case b_variant:RbsECAN_sim_start_b_variant();break;
    }
    if (@hil_ctrl::hil_mode == @hil_ctrl::hil_mode::Restbus) 
    {
       RbsECAN_sim_EnableEventMsg();
    }
    else
    {
       RbsECAN_sim_DisableEventMsg();
    }
  }
}

void RbsECAN_sim_start_a_variant()
{
  @CAN_ECAN::ESP_02::ESP_02_ON_OFF = 1;
  @CAN_ECAN::EPB_01::EPB_01_ON_OFF = 1;
  @CAN_ECAN::ESP_05::ESP_05_ON_OFF = 1;
  @CAN_ECAN::ESP_10::ESP_10_ON_OFF = 1;
  @CAN_ECAN::Motor_20::Motor_20_ON_OFF = 1;
  @CAN_ECAN::Gateway_72::Gateway_72_ON_OFF = 1;
  @CAN_ECAN::LWI_01::LWI_01_ON_OFF = 1;
  @CAN_ECAN::Getriebe_11::Getriebe_11_ON_OFF = 1;
  @CAN_ECAN::ESP_19::ESP_19_ON_OFF = 1;
  @CAN_ECAN::ESP_21::ESP_21_ON_OFF = 1;
}

void RbsECAN_sim_start_b_variant()
{
  @CAN_ECAN::ESP_02::ESP_02_ON_OFF = 1;
  @CAN_ECAN::EPB_01::EPB_01_ON_OFF = 1;
  @CAN_ECAN::ESP_05::ESP_05_ON_OFF = 1;
  @CAN_ECAN::ESP_10::ESP_10_ON_OFF = 1;
  @CAN_ECAN::Motor_20::Motor_20_ON_OFF = 1;
  @CAN_ECAN::Gateway_72::Gateway_72_ON_OFF = 1;
  @CAN_ECAN::LWI_01::LWI_01_ON_OFF = 1;
  @CAN_ECAN::Getriebe_11::Getriebe_11_ON_OFF = 1;
  @CAN_ECAN::ESP_19::ESP_19_ON_OFF = 1;
  @CAN_ECAN::ESP_21::ESP_21_ON_OFF = 1;
}

void RbsECAN_sim_Disable()
{
  @CAN_ECAN::ESP_02::ESP_02_ON_OFF = 0;
  @CAN_ECAN::EPB_01::EPB_01_ON_OFF = 0;
  @CAN_ECAN::ESP_05::ESP_05_ON_OFF = 0;
  @CAN_ECAN::ESP_10::ESP_10_ON_OFF = 0;
  @CAN_ECAN::Motor_20::Motor_20_ON_OFF = 0;
  @CAN_ECAN::Gateway_72::Gateway_72_ON_OFF = 0;
  @CAN_ECAN::LWI_01::LWI_01_ON_OFF = 0;
  @CAN_ECAN::Getriebe_11::Getriebe_11_ON_OFF = 0;
  @CAN_ECAN::ESP_19::ESP_19_ON_OFF = 0;
  @CAN_ECAN::ESP_21::ESP_21_ON_OFF = 0;
}

void RbsECAN_sim_DisableMsg()
{
   ILFaultInjectionDisableMsg(ESP_02);
   ILFaultInjectionDisableMsg(EPB_01);
   ILFaultInjectionDisableMsg(ESP_05);
   ILFaultInjectionDisableMsg(ESP_10);
   ILFaultInjectionDisableMsg(Motor_20);
   ILFaultInjectionDisableMsg(TimeSync);
   ILFaultInjectionDisableMsg(Gateway_72);
   ILFaultInjectionDisableMsg(LWI_01);
   ILFaultInjectionDisableMsg(Getriebe_11);
   ILFaultInjectionDisableMsg(ESP_19);
   ILFaultInjectionDisableMsg(ESP_21);
}
on sysvar hil_ctrl::hil_mode
{
  RbsECAN_sim_Reset();
}

void RbsECAN_sim_DisableEventMsg()
{

}

void RbsECAN_sim_EnableEventMsg()
{

}
void RbsECAN_sim_SetCANParameter()
{
  //For future purpose
  //ILFaultInjectionSetMsgDlc(dbMsg msg, dword dlc)
  //ILFaultInjectionSetMsgLength(dbMsg msg, dword msgLength)
  //ILFaultInjectionResetMsgDlc(dbMsg msg)
  //ILFaultInjectionResetMsgLength (dbMsg msg)
}

void RbsECAN_sim_SetCANFDParameter()
{
   //CAN FD Parameter Setting
   int FDF =1;
   int BRS =1;
   ILSetCANFDParam(ESP_02,FDF,BRS,ESP_02.dlc);
   ILSetCANFDParam(EPB_01,FDF,BRS,EPB_01.dlc);
   ILSetCANFDParam(ESP_05,FDF,BRS,ESP_05.dlc);
   ILSetCANFDParam(ESP_10,FDF,BRS,ESP_10.dlc);
   ILSetCANFDParam(Motor_20,FDF,BRS,Motor_20.dlc);
   ILSetCANFDParam(Gateway_72,FDF,BRS,Gateway_72.dlc);
   ILSetCANFDParam(LWI_01,FDF,BRS,LWI_01.dlc);
   ILSetCANFDParam(Getriebe_11,FDF,BRS,Getriebe_11.dlc);
   ILSetCANFDParam(ESP_19,FDF,BRS,ESP_19.dlc);
   ILSetCANFDParam(ESP_21,FDF,BRS,ESP_21.dlc);
}

dword applILTxPending (long aId, dword aDlc, byte data[])//This callback is being called before the IL sends a message to the bus
{
  switch(aId)
  {
    case ESP_02.id:cfg_Msg_ESP_02(aDlc, data);break;
    case EPB_01.id:cfg_Msg_EPB_01(aDlc, data);break;
    case ESP_05.id:cfg_Msg_ESP_05(aDlc, data);break;
    case ESP_10.id:cfg_Msg_ESP_10(aDlc, data);break;
    case Motor_20.id:cfg_Msg_Motor_20(aDlc, data);break;
    case Gateway_72.id:cfg_Msg_Gateway_72(aDlc, data);break;
    case LWI_01.id:cfg_Msg_LWI_01(aDlc, data);break;
    case Getriebe_11.id:cfg_Msg_Getriebe_11(aDlc, data);break;
    case ESP_19.id:cfg_Msg_ESP_19(aDlc, data);break;
    case ESP_21.id:cfg_Msg_ESP_21(aDlc, data);break;
    default :;//write("Node:RbsECAN ::No Cyclic event");
           break;
  }
  return 1; // don't prevent sending of the message
}

on sysvar CAN_ECAN::EPB_01::EPB_01_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(EPB_01);
  }
  else{
         ILFaultInjectionDisableMsg(EPB_01);
      }
}

void cfg_Msg_EPB_01(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_EPB_01.DataLength;//Message Data Length
   Msg_id  = Msg_EPB_01.id;//Message ID
   
    if (@CAN_ECAN::EPB_01::EPB_01_BZ_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_ECAN::EPB_01::EPB_01_BZ_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_EPB_01_EPB_01_BZ;
      counter_EPB_01_EPB_01_BZ %=15;

      copyBitsToByteArrayLE(counter_EPB_01_EPB_01_BZ,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ECAN::EPB_01::EPB_01_BZ_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ECAN::EPB_01::EPB_01_BZ_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_EPB_01_EPB_01_BZ,data,8,4); //Intel / little-endian;
    }
    if (@CAN_ECAN::EPB_01::EPB_01_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_ECAN::EPB_01::EPB_01_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      crc_EPB_01_EPB_01_CRC = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(crc_EPB_01_EPB_01_CRC,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ECAN::EPB_01::EPB_01_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ECAN::EPB_01::EPB_01_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_EPB_01_EPB_01_CRC,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_ECAN::ESP_02::ESP_02_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(ESP_02);
  }
  else{
         ILFaultInjectionDisableMsg(ESP_02);
      }
}

void cfg_Msg_ESP_02(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ESP_02.DataLength;//Message Data Length
   Msg_id  = Msg_ESP_02.id;//Message ID
   
    if (@CAN_ECAN::ESP_02::ESP_02_BZ_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_ECAN::ESP_02::ESP_02_BZ_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_ESP_02_ESP_02_BZ;
      counter_ESP_02_ESP_02_BZ %=15;

      copyBitsToByteArrayLE(counter_ESP_02_ESP_02_BZ,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ECAN::ESP_02::ESP_02_BZ_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ECAN::ESP_02::ESP_02_BZ_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_ESP_02_ESP_02_BZ,data,8,4); //Intel / little-endian;
    }
    if (@CAN_ECAN::ESP_02::ESP_02_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_ECAN::ESP_02::ESP_02_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      crc_ESP_02_ESP_02_CRC = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(crc_ESP_02_ESP_02_CRC,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ECAN::ESP_02::ESP_02_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ECAN::ESP_02::ESP_02_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_ESP_02_ESP_02_CRC,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_ECAN::ESP_05::ESP_05_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(ESP_05);
  }
  else{
         ILFaultInjectionDisableMsg(ESP_05);
      }
}

void cfg_Msg_ESP_05(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ESP_05.DataLength;//Message Data Length
   Msg_id  = Msg_ESP_05.id;//Message ID
   
    if (@CAN_ECAN::ESP_05::ESP_05_BZ_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_ECAN::ESP_05::ESP_05_BZ_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_ESP_05_ESP_05_BZ;
      counter_ESP_05_ESP_05_BZ %=15;

      copyBitsToByteArrayLE(counter_ESP_05_ESP_05_BZ,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ECAN::ESP_05::ESP_05_BZ_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ECAN::ESP_05::ESP_05_BZ_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_ESP_05_ESP_05_BZ,data,8,4); //Intel / little-endian;
    }
    if (@CAN_ECAN::ESP_05::ESP_05_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_ECAN::ESP_05::ESP_05_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      crc_ESP_05_ESP_05_CRC = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(crc_ESP_05_ESP_05_CRC,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ECAN::ESP_05::ESP_05_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ECAN::ESP_05::ESP_05_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_ESP_05_ESP_05_CRC,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_ECAN::ESP_10::ESP_10_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(ESP_10);
  }
  else{
         ILFaultInjectionDisableMsg(ESP_10);
      }
}

void cfg_Msg_ESP_10(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ESP_10.DataLength;//Message Data Length
   Msg_id  = Msg_ESP_10.id;//Message ID
   
    if (@CAN_ECAN::ESP_10::ESP_10_BZ_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_ECAN::ESP_10::ESP_10_BZ_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_ESP_10_ESP_10_BZ;
      counter_ESP_10_ESP_10_BZ %=15;

      copyBitsToByteArrayLE(counter_ESP_10_ESP_10_BZ,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ECAN::ESP_10::ESP_10_BZ_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ECAN::ESP_10::ESP_10_BZ_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_ESP_10_ESP_10_BZ,data,8,4); //Intel / little-endian;
    }
    if (@CAN_ECAN::ESP_10::ESP_10_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_ECAN::ESP_10::ESP_10_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      crc_ESP_10_ESP_10_CRC = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(crc_ESP_10_ESP_10_CRC,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ECAN::ESP_10::ESP_10_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ECAN::ESP_10::ESP_10_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_ESP_10_ESP_10_CRC,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_ECAN::ESP_19::ESP_19_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(ESP_19);
  }
  else{
         ILFaultInjectionDisableMsg(ESP_19);
      }
}

void cfg_Msg_ESP_19(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ESP_19.DataLength;//Message Data Length
   Msg_id  = Msg_ESP_19.id;//Message ID
   
}


on sysvar CAN_ECAN::ESP_21::ESP_21_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(ESP_21);
  }
  else{
         ILFaultInjectionDisableMsg(ESP_21);
      }
}

void cfg_Msg_ESP_21(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ESP_21.DataLength;//Message Data Length
   Msg_id  = Msg_ESP_21.id;//Message ID
   
    if (@CAN_ECAN::ESP_21::ESP_21_BZ_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_ECAN::ESP_21::ESP_21_BZ_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_ESP_21_ESP_21_BZ;
      counter_ESP_21_ESP_21_BZ %=15;

      copyBitsToByteArrayLE(counter_ESP_21_ESP_21_BZ,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ECAN::ESP_21::ESP_21_BZ_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ECAN::ESP_21::ESP_21_BZ_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_ESP_21_ESP_21_BZ,data,8,4); //Intel / little-endian;
    }
    if (@CAN_ECAN::ESP_21::ESP_21_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_ECAN::ESP_21::ESP_21_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      crc_ESP_21_ESP_21_CRC = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(crc_ESP_21_ESP_21_CRC,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ECAN::ESP_21::ESP_21_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ECAN::ESP_21::ESP_21_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_ESP_21_ESP_21_CRC,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_ECAN::Gateway_72::Gateway_72_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(Gateway_72);
  }
  else{
         ILFaultInjectionDisableMsg(Gateway_72);
      }
}

void cfg_Msg_Gateway_72(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_Gateway_72.DataLength;//Message Data Length
   Msg_id  = Msg_Gateway_72.id;//Message ID
   
}


on sysvar CAN_ECAN::Getriebe_11::Getriebe_11_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(Getriebe_11);
  }
  else{
         ILFaultInjectionDisableMsg(Getriebe_11);
      }
}

void cfg_Msg_Getriebe_11(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_Getriebe_11.DataLength;//Message Data Length
   Msg_id  = Msg_Getriebe_11.id;//Message ID
   
    if (@CAN_ECAN::Getriebe_11::Getriebe_11_BZ_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_ECAN::Getriebe_11::Getriebe_11_BZ_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_Getriebe_11_Getriebe_11_BZ;
      counter_Getriebe_11_Getriebe_11_BZ %=15;

      copyBitsToByteArrayLE(counter_Getriebe_11_Getriebe_11_BZ,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ECAN::Getriebe_11::Getriebe_11_BZ_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ECAN::Getriebe_11::Getriebe_11_BZ_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_Getriebe_11_Getriebe_11_BZ,data,8,4); //Intel / little-endian;
    }
    if (@CAN_ECAN::Getriebe_11::Getriebe_11_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_ECAN::Getriebe_11::Getriebe_11_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      crc_Getriebe_11_Getriebe_11_CRC = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(crc_Getriebe_11_Getriebe_11_CRC,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ECAN::Getriebe_11::Getriebe_11_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ECAN::Getriebe_11::Getriebe_11_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_Getriebe_11_Getriebe_11_CRC,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_ECAN::LWI_01::LWI_01_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(LWI_01);
  }
  else{
         ILFaultInjectionDisableMsg(LWI_01);
      }
}

void cfg_Msg_LWI_01(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_LWI_01.DataLength;//Message Data Length
   Msg_id  = Msg_LWI_01.id;//Message ID
   
    if (@CAN_ECAN::LWI_01::LWI_01_BZ_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_ECAN::LWI_01::LWI_01_BZ_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_LWI_01_LWI_01_BZ;
      counter_LWI_01_LWI_01_BZ %=15;

      copyBitsToByteArrayLE(counter_LWI_01_LWI_01_BZ,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ECAN::LWI_01::LWI_01_BZ_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ECAN::LWI_01::LWI_01_BZ_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_LWI_01_LWI_01_BZ,data,8,4); //Intel / little-endian;
    }
    if (@CAN_ECAN::LWI_01::LWI_01_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_ECAN::LWI_01::LWI_01_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      crc_LWI_01_LWI_01_CRC = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(crc_LWI_01_LWI_01_CRC,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ECAN::LWI_01::LWI_01_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ECAN::LWI_01::LWI_01_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_LWI_01_LWI_01_CRC,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_ECAN::Motor_20::Motor_20_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(Motor_20);
  }
  else{
         ILFaultInjectionDisableMsg(Motor_20);
      }
}

void cfg_Msg_Motor_20(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_Motor_20.DataLength;//Message Data Length
   Msg_id  = Msg_Motor_20.id;//Message ID
   
    if (@CAN_ECAN::Motor_20::Motor_20_BZ_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_ECAN::Motor_20::Motor_20_BZ_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_Motor_20_Motor_20_BZ;
      counter_Motor_20_Motor_20_BZ %=15;

      copyBitsToByteArrayLE(counter_Motor_20_Motor_20_BZ,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ECAN::Motor_20::Motor_20_BZ_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ECAN::Motor_20::Motor_20_BZ_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_Motor_20_Motor_20_BZ,data,8,4); //Intel / little-endian;
    }
    if (@CAN_ECAN::Motor_20::Motor_20_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_ECAN::Motor_20::Motor_20_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      crc_Motor_20_Motor_20_CRC = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(crc_Motor_20_Motor_20_CRC,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ECAN::Motor_20::Motor_20_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ECAN::Motor_20::Motor_20_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_Motor_20_Motor_20_CRC,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_ECAN::ESP_02::ESP_02_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(ESP_02,@this);
  //ILFaultInjectionResetMsgCycleTime(ESP_02);
}

on sysvar CAN_ECAN::EPB_01::EPB_01_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(EPB_01,@this);
  //ILFaultInjectionResetMsgCycleTime(EPB_01);
}

on sysvar CAN_ECAN::ESP_05::ESP_05_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(ESP_05,@this);
  //ILFaultInjectionResetMsgCycleTime(ESP_05);
}

on sysvar CAN_ECAN::ESP_10::ESP_10_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(ESP_10,@this);
  //ILFaultInjectionResetMsgCycleTime(ESP_10);
}

on sysvar CAN_ECAN::Motor_20::Motor_20_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(Motor_20,@this);
  //ILFaultInjectionResetMsgCycleTime(Motor_20);
}

on sysvar CAN_ECAN::Gateway_72::Gateway_72_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(Gateway_72,@this);
  //ILFaultInjectionResetMsgCycleTime(Gateway_72);
}

on sysvar CAN_ECAN::LWI_01::LWI_01_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(LWI_01,@this);
  //ILFaultInjectionResetMsgCycleTime(LWI_01);
}

on sysvar CAN_ECAN::Getriebe_11::Getriebe_11_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(Getriebe_11,@this);
  //ILFaultInjectionResetMsgCycleTime(Getriebe_11);
}

on sysvar CAN_ECAN::ESP_19::ESP_19_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(ESP_19,@this);
  //ILFaultInjectionResetMsgCycleTime(ESP_19);
}

on sysvar CAN_ECAN::ESP_21::ESP_21_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(ESP_21,@this);
  //ILFaultInjectionResetMsgCycleTime(ESP_21);
}

void RbsECAN_sim_SetCycleTimeOffset()
{

//  ILNodeSetPDUTimingCyclic (dbMsg dbMessage, long TrueOrFalse, long offset, long period, long disturbanceCount, long flags);
//  TrueOrFalse ; 0: denotes the False timing; 1: denotes the True timing; 3: denotes the True and the False timing.
//  offset :Defines the delay in [ms] from now when the first cyclic transmission will start.
//  period :Defines the period in [ms] for the cyclic transmission.
//  disturbanceCount :Reserved/unused; should be set to -1 (infinite).
//  flags :Reserved; should be set to 0.

}