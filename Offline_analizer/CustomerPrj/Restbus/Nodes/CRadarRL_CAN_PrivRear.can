/*@!Encoding:1252*/
/**
 * @file CRadarRL_CAN_PrivRear.can
 * @author ADAS_HIL_TEAM
 * @date 10-04-2022
 * @brief 
 *
 * ################################################################
 * C O P Y R I G H T S
 * ----------------------------------------------------------------
 * Copyright (c) 2022-2023 by Robert Bosch GmbH. All rights reserved.
 
 * The reproduction, distribution and utilization of this file as
 * well as the communication of its contents to others without express
 * authorization is prohibited. Offenders will be held liable for the
 * payment of damages. All rights reserved in the event of the grant
 * of a patent, utility model or design.
 *
 * ################################################################
*/

// Autogenerated by -> Platform\Classe\Scripts\Rbs_Scripts\create_nodes.py
includes
{
  #pragma library ("C:\ProgramData\Vector\AddOn Packages\Vector AddOn\vModules\CANoeILNLVector.vmodule")
  #include "CAPL\DataHandling.cin" /*DataHandling for IL*/
  #include "CAPL\E2E.cin" /*OD Specific for CRC calculation */
}

variables {
  message RRL_AEB_Request Msg_RRL_AEB_Request;
  message RRL_Status Msg_RRL_Status;
  message RRL_ObjHdr Msg_RRL_ObjHdr;
  message RRL_Obj00A Msg_RRL_Obj00A;
  message RRL_Obj00B Msg_RRL_Obj00B;
  message RRL_Obj01A Msg_RRL_Obj01A;
  message RRL_Obj01B Msg_RRL_Obj01B;
  message RRL_Obj02A Msg_RRL_Obj02A;
  message RRL_Obj02B Msg_RRL_Obj02B;
  message RRL_Obj03A Msg_RRL_Obj03A;
  message RRL_Obj03B Msg_RRL_Obj03B;
  message RRL_Obj04A Msg_RRL_Obj04A;
  message RRL_Obj04B Msg_RRL_Obj04B;
  message RRL_Obj05A Msg_RRL_Obj05A;
  message RRL_Obj05B Msg_RRL_Obj05B;
  message RRL_Obj06A Msg_RRL_Obj06A;
  message RRL_Obj06B Msg_RRL_Obj06B;
  message RRL_Obj07A Msg_RRL_Obj07A;
  message RRL_Obj07B Msg_RRL_Obj07B;
  message RRL_Obj08A Msg_RRL_Obj08A;
  message RRL_Obj08B Msg_RRL_Obj08B;
  message RRL_Obj09A Msg_RRL_Obj09A;
  message RRL_Obj09B Msg_RRL_Obj09B;

  word counter_RRL_AEB_Request_RRL_AEB_AC;
  word counter_RRL_Status_RRL_Status_AliveCtr;
  word counter_RRL_ObjHdr_RRL_ObjHdr_AliveCtr;
  word counter_RRL_Obj00A_RRL_Obj00A_AliveCtr;
  word counter_RRL_Obj00B_RRL_Obj00B_AliveCtr;
  word counter_RRL_Obj01A_RRL_Obj01A_AliveCtr;
  word counter_RRL_Obj01B_RRL_Obj01B_AliveCtr;
  word counter_RRL_Obj02A_RRL_Obj02A_AliveCtr;
  word counter_RRL_Obj02B_RRL_Obj02B_AliveCtr;
  word counter_RRL_Obj03A_RRL_Obj03A_AliveCtr;
  word counter_RRL_Obj03B_RRL_Obj03B_AliveCtr;
  word counter_RRL_Obj04A_RRL_Obj04A_AliveCtr;
  word counter_RRL_Obj04B_RRL_Obj04B_AliveCtr;
  word counter_RRL_Obj05A_RRL_Obj05A_AliveCtr;
  word counter_RRL_Obj05B_RRL_Obj05B_AliveCtr;
  word counter_RRL_Obj06A_RRL_Obj06A_AliveCtr;
  word counter_RRL_Obj06B_RRL_Obj06B_AliveCtr;
  word counter_RRL_Obj07A_RRL_Obj07A_AliveCtr;
  word counter_RRL_Obj07B_RRL_Obj07B_AliveCtr;
  word counter_RRL_Obj08A_RRL_Obj08A_AliveCtr;
  word counter_RRL_Obj08B_RRL_Obj08B_AliveCtr;
  word counter_RRL_Obj09A_RRL_Obj09A_AliveCtr;
  word counter_RRL_Obj09B_RRL_Obj09B_AliveCtr;

  dword bc_RRL_ObjHdr_RRL_ObjHdr_ProtBlockCtr;
  dword bc_RRL_Object_ProtBlockCtr;
  dword bc_RRL_Obj00A_RRL_Obj00A_ProtBlockCtr;
  dword bc_RRL_Obj00B_RRL_Obj00B_ProtBlockCtr;
  dword bc_RRL_Obj01A_RRL_Obj01A_ProtBlockCtr;
  dword bc_RRL_Obj01B_RRL_Obj01B_ProtBlockCtr;
  dword bc_RRL_Obj02A_RRL_Obj02A_ProtBlockCtr;
  dword bc_RRL_Obj02B_RRL_Obj02B_ProtBlockCtr;
  dword bc_RRL_Obj03A_RRL_Obj03A_ProtBlockCtr;
  dword bc_RRL_Obj03B_RRL_Obj03B_ProtBlockCtr;
  dword bc_RRL_Obj04A_RRL_Obj04A_ProtBlockCtr;
  dword bc_RRL_Obj04B_RRL_Obj04B_ProtBlockCtr;
  dword bc_RRL_Obj05A_RRL_Obj05A_ProtBlockCtr;
  dword bc_RRL_Obj05B_RRL_Obj05B_ProtBlockCtr;
  dword bc_RRL_Obj06A_RRL_Obj06A_ProtBlockCtr;
  dword bc_RRL_Obj06B_RRL_Obj06B_ProtBlockCtr;
  dword bc_RRL_Obj07A_RRL_Obj07A_ProtBlockCtr;
  dword bc_RRL_Obj07B_RRL_Obj07B_ProtBlockCtr;
  dword bc_RRL_Obj08A_RRL_Obj08A_ProtBlockCtr;
  dword bc_RRL_Obj08B_RRL_Obj08B_ProtBlockCtr;
  dword bc_RRL_Obj09A_RRL_Obj09A_ProtBlockCtr;
  dword bc_RRL_Obj09B_RRL_Obj09B_ProtBlockCtr;

  byte crc_RRL_AEB_Request_RRL_AEB_CRC;
  byte crc_RRL_Status_RRL_Status_CRC;
  dword crc_RRL_ObjHdr_RRL_ObjHdr_CRC;
  dword crc_RRL_Obj00A_RRL_Obj00A_CRC;
  dword crc_RRL_Obj00B_RRL_Obj00B_CRC;
  dword crc_RRL_Obj01A_RRL_Obj01A_CRC;
  dword crc_RRL_Obj01B_RRL_Obj01B_CRC;
  dword crc_RRL_Obj02A_RRL_Obj02A_CRC;
  dword crc_RRL_Obj02B_RRL_Obj02B_CRC;
  dword crc_RRL_Obj03A_RRL_Obj03A_CRC;
  dword crc_RRL_Obj03B_RRL_Obj03B_CRC;
  dword crc_RRL_Obj04A_RRL_Obj04A_CRC;
  dword crc_RRL_Obj04B_RRL_Obj04B_CRC;
  dword crc_RRL_Obj05A_RRL_Obj05A_CRC;
  dword crc_RRL_Obj05B_RRL_Obj05B_CRC;
  dword crc_RRL_Obj06A_RRL_Obj06A_CRC;
  dword crc_RRL_Obj06B_RRL_Obj06B_CRC;
  dword crc_RRL_Obj07A_RRL_Obj07A_CRC;
  dword crc_RRL_Obj07B_RRL_Obj07B_CRC;
  dword crc_RRL_Obj08A_RRL_Obj08A_CRC;
  dword crc_RRL_Obj08B_RRL_Obj08B_CRC;
  dword crc_RRL_Obj09A_RRL_Obj09A_CRC;
  dword crc_RRL_Obj09B_RRL_Obj09B_CRC;

}

on preStart {
  long result;
  result=ILControlInit ();//Initialization of CANoe IL,to prevent the IL autostart function.
  switch(result)
  {
    case  0   : write("ILControlInit :: CRadarRL :: No error."); break;
    case -1   : write("ILControlInit :: CRadarRL :: Momentary state of the IL does not permit this query."); break;
    case -50  : write("ILControlInit :: CRadarRL :: Nodelayer is inactive - possibly deactivated in the nodes configuration dialog.");  break;
   }

  CRadarRL_sim_Disable();
  CRadarRL_sim_SetCycleTimeOffset();
}

on start {

  ILControlSimulationOn();//Starts the simulation of the IL.
  CRadarRL_sim_SetCANFDParameter();
  ILControlStart ();//Cyclical sending starts; setting signals is now possible.
  CRadarRL_sim_Reset();
}

on stopMeasurement {

  CRadarRL_sim_DisableMsg();
  CRadarRL_sim_Disable();
  ILControlStop();//Cyclical sending is stopped; setting signals is now no longer possible.
  ILControlSimulationOff();//Stops the simulation of the IL. After that no other function to control the IL has an effect to the IL.

}

on sysvar_update hil_ctrl::radar_rl_sim
{
  CRadarRL_sim_Reset();
}

on sysvar_update hil_ctrl::variant
{
  CRadarRL_sim_Reset();
}

on sysvar_update Cus_bus::bus_CAN_PrivRear_ON_OFF
{
  CRadarRL_sim_Reset();
}

void CRadarRL_sim_Reset()
{

  CRadarRL_sim_DisableMsg();
  CRadarRL_sim_Disable();

  if ((@Cus_bus::bus_CAN_PrivRear_ON_OFF == 1) && (@hil_ctrl::radar_rl_sim == 1))
  {
    switch(@hil_ctrl::variant)
    {
      case a_variant:CRadarRL_sim_start_a_variant();break;
      case b_variant:CRadarRL_sim_start_b_variant();break;
    }
    if (@hil_ctrl::hil_mode == @hil_ctrl::hil_mode::Restbus) 
    {
       CRadarRL_sim_EnableEventMsg();
    }
    else
    {
       CRadarRL_sim_DisableEventMsg();
    }
  }
}

void CRadarRL_sim_start_a_variant()
{
  @CAN_PrivRear::RRL_Status::RRL_Status_ON_OFF = 1;
}

void CRadarRL_sim_start_b_variant()
{
  @CAN_PrivRear::RRL_Status::RRL_Status_ON_OFF = 1;
}

void CRadarRL_sim_Disable()
{
  @CAN_PrivRear::RRL_AEB_Request::RRL_AEB_Request_ON_OFF = 0;
  @CAN_PrivRear::RRL_Status::RRL_Status_ON_OFF = 0;
  @CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj00A::RRL_Obj00A_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj00B::RRL_Obj00B_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj01A::RRL_Obj01A_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj01B::RRL_Obj01B_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj02A::RRL_Obj02A_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj02B::RRL_Obj02B_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj03A::RRL_Obj03A_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj03B::RRL_Obj03B_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj04A::RRL_Obj04A_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj04B::RRL_Obj04B_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj05A::RRL_Obj05A_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj05B::RRL_Obj05B_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj06A::RRL_Obj06A_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj06B::RRL_Obj06B_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj07A::RRL_Obj07A_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj07B::RRL_Obj07B_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj08A::RRL_Obj08A_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj08B::RRL_Obj08B_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj09A::RRL_Obj09A_ON_OFF = 0;
  @CAN_PrivRear::RRL_Obj09B::RRL_Obj09B_ON_OFF = 0;
}

void CRadarRL_sim_DisableMsg()
{
   ILFaultInjectionDisableMsg(RRL_AEB_Request);
   ILFaultInjectionDisableMsg(RRL_Status);
   ILFaultInjectionDisableMsg(RRL_ObjHdr);
   ILFaultInjectionDisableMsg(RRL_Obj00A);
   ILFaultInjectionDisableMsg(RRL_Obj00B);
   ILFaultInjectionDisableMsg(RRL_Obj01A);
   ILFaultInjectionDisableMsg(RRL_Obj01B);
   ILFaultInjectionDisableMsg(RRL_Obj02A);
   ILFaultInjectionDisableMsg(RRL_Obj02B);
   ILFaultInjectionDisableMsg(RRL_Obj03A);
   ILFaultInjectionDisableMsg(RRL_Obj03B);
   ILFaultInjectionDisableMsg(RRL_Obj04A);
   ILFaultInjectionDisableMsg(RRL_Obj04B);
   ILFaultInjectionDisableMsg(RRL_Obj05A);
   ILFaultInjectionDisableMsg(RRL_Obj05B);
   ILFaultInjectionDisableMsg(RRL_Obj06A);
   ILFaultInjectionDisableMsg(RRL_Obj06B);
   ILFaultInjectionDisableMsg(RRL_Obj07A);
   ILFaultInjectionDisableMsg(RRL_Obj07B);
   ILFaultInjectionDisableMsg(RRL_Obj08A);
   ILFaultInjectionDisableMsg(RRL_Obj08B);
   ILFaultInjectionDisableMsg(RRL_Obj09A);
   ILFaultInjectionDisableMsg(RRL_Obj09B);
}
on sysvar hil_ctrl::hil_mode
{
  CRadarRL_sim_Reset();
}

void CRadarRL_sim_DisableEventMsg()
{
   ILFaultInjectionDisableMsg(RRL_AEB_Request);
   ILFaultInjectionDisableMsg(RRL_ObjHdr);
   ILFaultInjectionDisableMsg(RRL_Obj00A);
   ILFaultInjectionDisableMsg(RRL_Obj00B);
   ILFaultInjectionDisableMsg(RRL_Obj01A);
   ILFaultInjectionDisableMsg(RRL_Obj01B);
   ILFaultInjectionDisableMsg(RRL_Obj02A);
   ILFaultInjectionDisableMsg(RRL_Obj02B);
   ILFaultInjectionDisableMsg(RRL_Obj03A);
   ILFaultInjectionDisableMsg(RRL_Obj03B);
   ILFaultInjectionDisableMsg(RRL_Obj04A);
   ILFaultInjectionDisableMsg(RRL_Obj04B);
   ILFaultInjectionDisableMsg(RRL_Obj05A);
   ILFaultInjectionDisableMsg(RRL_Obj05B);
   ILFaultInjectionDisableMsg(RRL_Obj06A);
   ILFaultInjectionDisableMsg(RRL_Obj06B);
   ILFaultInjectionDisableMsg(RRL_Obj07A);
   ILFaultInjectionDisableMsg(RRL_Obj07B);
   ILFaultInjectionDisableMsg(RRL_Obj08A);
   ILFaultInjectionDisableMsg(RRL_Obj08B);
   ILFaultInjectionDisableMsg(RRL_Obj09A);
   ILFaultInjectionDisableMsg(RRL_Obj09B);

}

void CRadarRL_sim_EnableEventMsg()
{
   ILFaultInjectionEnableMsg(RRL_AEB_Request);
   ILFaultInjectionEnableMsg(RRL_ObjHdr);
   ILFaultInjectionEnableMsg(RRL_Obj00A);
   ILFaultInjectionEnableMsg(RRL_Obj00B);
   ILFaultInjectionEnableMsg(RRL_Obj01A);
   ILFaultInjectionEnableMsg(RRL_Obj01B);
   ILFaultInjectionEnableMsg(RRL_Obj02A);
   ILFaultInjectionEnableMsg(RRL_Obj02B);
   ILFaultInjectionEnableMsg(RRL_Obj03A);
   ILFaultInjectionEnableMsg(RRL_Obj03B);
   ILFaultInjectionEnableMsg(RRL_Obj04A);
   ILFaultInjectionEnableMsg(RRL_Obj04B);
   ILFaultInjectionEnableMsg(RRL_Obj05A);
   ILFaultInjectionEnableMsg(RRL_Obj05B);
   ILFaultInjectionEnableMsg(RRL_Obj06A);
   ILFaultInjectionEnableMsg(RRL_Obj06B);
   ILFaultInjectionEnableMsg(RRL_Obj07A);
   ILFaultInjectionEnableMsg(RRL_Obj07B);
   ILFaultInjectionEnableMsg(RRL_Obj08A);
   ILFaultInjectionEnableMsg(RRL_Obj08B);
   ILFaultInjectionEnableMsg(RRL_Obj09A);
   ILFaultInjectionEnableMsg(RRL_Obj09B);

}
void CRadarRL_sim_SetCANParameter()
{
  //For future purpose
  //ILFaultInjectionSetMsgDlc(dbMsg msg, dword dlc)
  //ILFaultInjectionSetMsgLength(dbMsg msg, dword msgLength)
  //ILFaultInjectionResetMsgDlc(dbMsg msg)
  //ILFaultInjectionResetMsgLength (dbMsg msg)
}

void CRadarRL_sim_SetCANFDParameter()
{
   //CAN FD Parameter Setting
   int FDF =1;
   int BRS =1;
   ILSetCANFDParam(RRL_AEB_Request,FDF,BRS,RRL_AEB_Request.dlc);
   ILSetCANFDParam(RRL_Status,FDF,BRS,RRL_Status.dlc);
   ILSetCANFDParam(RRL_ObjHdr,FDF,BRS,RRL_ObjHdr.dlc);
   ILSetCANFDParam(RRL_Obj00A,FDF,BRS,RRL_Obj00A.dlc);
   ILSetCANFDParam(RRL_Obj00B,FDF,BRS,RRL_Obj00B.dlc);
   ILSetCANFDParam(RRL_Obj01A,FDF,BRS,RRL_Obj01A.dlc);
   ILSetCANFDParam(RRL_Obj01B,FDF,BRS,RRL_Obj01B.dlc);
   ILSetCANFDParam(RRL_Obj02A,FDF,BRS,RRL_Obj02A.dlc);
   ILSetCANFDParam(RRL_Obj02B,FDF,BRS,RRL_Obj02B.dlc);
   ILSetCANFDParam(RRL_Obj03A,FDF,BRS,RRL_Obj03A.dlc);
   ILSetCANFDParam(RRL_Obj03B,FDF,BRS,RRL_Obj03B.dlc);
   ILSetCANFDParam(RRL_Obj04A,FDF,BRS,RRL_Obj04A.dlc);
   ILSetCANFDParam(RRL_Obj04B,FDF,BRS,RRL_Obj04B.dlc);
   ILSetCANFDParam(RRL_Obj05A,FDF,BRS,RRL_Obj05A.dlc);
   ILSetCANFDParam(RRL_Obj05B,FDF,BRS,RRL_Obj05B.dlc);
   ILSetCANFDParam(RRL_Obj06A,FDF,BRS,RRL_Obj06A.dlc);
   ILSetCANFDParam(RRL_Obj06B,FDF,BRS,RRL_Obj06B.dlc);
   ILSetCANFDParam(RRL_Obj07A,FDF,BRS,RRL_Obj07A.dlc);
   ILSetCANFDParam(RRL_Obj07B,FDF,BRS,RRL_Obj07B.dlc);
   ILSetCANFDParam(RRL_Obj08A,FDF,BRS,RRL_Obj08A.dlc);
   ILSetCANFDParam(RRL_Obj08B,FDF,BRS,RRL_Obj08B.dlc);
   ILSetCANFDParam(RRL_Obj09A,FDF,BRS,RRL_Obj09A.dlc);
   ILSetCANFDParam(RRL_Obj09B,FDF,BRS,RRL_Obj09B.dlc);
}

dword applILTxPending (long aId, dword aDlc, byte data[])//This callback is being called before the IL sends a message to the bus
{
  switch(aId)
  {
    case RRL_AEB_Request.id:cfg_Msg_RRL_AEB_Request(aDlc, data);break;
    case RRL_Status.id:cfg_Msg_RRL_Status(aDlc, data);break;
    case RRL_ObjHdr.id:cfg_Msg_RRL_ObjHdr(aDlc, data);break;
    case RRL_Obj00A.id:cfg_Msg_RRL_Obj00A(aDlc, data);break;
    case RRL_Obj00B.id:cfg_Msg_RRL_Obj00B(aDlc, data);break;
    case RRL_Obj01A.id:cfg_Msg_RRL_Obj01A(aDlc, data);break;
    case RRL_Obj01B.id:cfg_Msg_RRL_Obj01B(aDlc, data);break;
    case RRL_Obj02A.id:cfg_Msg_RRL_Obj02A(aDlc, data);break;
    case RRL_Obj02B.id:cfg_Msg_RRL_Obj02B(aDlc, data);break;
    case RRL_Obj03A.id:cfg_Msg_RRL_Obj03A(aDlc, data);break;
    case RRL_Obj03B.id:cfg_Msg_RRL_Obj03B(aDlc, data);break;
    case RRL_Obj04A.id:cfg_Msg_RRL_Obj04A(aDlc, data);break;
    case RRL_Obj04B.id:cfg_Msg_RRL_Obj04B(aDlc, data);break;
    case RRL_Obj05A.id:cfg_Msg_RRL_Obj05A(aDlc, data);break;
    case RRL_Obj05B.id:cfg_Msg_RRL_Obj05B(aDlc, data);break;
    case RRL_Obj06A.id:cfg_Msg_RRL_Obj06A(aDlc, data);break;
    case RRL_Obj06B.id:cfg_Msg_RRL_Obj06B(aDlc, data);break;
    case RRL_Obj07A.id:cfg_Msg_RRL_Obj07A(aDlc, data);break;
    case RRL_Obj07B.id:cfg_Msg_RRL_Obj07B(aDlc, data);break;
    case RRL_Obj08A.id:cfg_Msg_RRL_Obj08A(aDlc, data);break;
    case RRL_Obj08B.id:cfg_Msg_RRL_Obj08B(aDlc, data);break;
    case RRL_Obj09A.id:cfg_Msg_RRL_Obj09A(aDlc, data);break;
    case RRL_Obj09B.id:cfg_Msg_RRL_Obj09B(aDlc, data);break;
    default :;//write("Node:CRadarRL ::No Cyclic event");
           break;
  }
  return 1; // don't prevent sending of the message
}

on sysvar CAN_PrivRear::RRL_AEB_Request::RRL_AEB_Request_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_AEB_Request);
     @CAN_PrivRear::RRL_AEB_Request::RRL_AEB_Request_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_AEB_Request(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_AEB_Request.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_AEB_Request.id;//Message ID
   
    if (@CAN_PrivRear::RRL_AEB_Request::RRL_AEB_AC_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_AEB_Request::RRL_AEB_AC_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_AEB_Request_RRL_AEB_AC;
      counter_RRL_AEB_Request_RRL_AEB_AC %=16;

      copyBitsToByteArrayLE(counter_RRL_AEB_Request_RRL_AEB_AC,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_AEB_Request::RRL_AEB_AC_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_AEB_Request::RRL_AEB_AC_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_AEB_Request_RRL_AEB_AC,data,8,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_AEB_Request::RRL_AEB_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_AEB_Request::RRL_AEB_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup_PRIVATE(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      crc_RRL_AEB_Request_RRL_AEB_CRC = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(crc_RRL_AEB_Request_RRL_AEB_CRC,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_AEB_Request::RRL_AEB_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_AEB_Request::RRL_AEB_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_AEB_Request_RRL_AEB_CRC,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj00A::RRL_Obj00A_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj00A);
     @CAN_PrivRear::RRL_Obj00A::RRL_Obj00A_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj00A(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj00A.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj00A.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj00A::RRL_Obj00A_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj00A::RRL_Obj00A_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj00A_RRL_Obj00A_AliveCtr;
      counter_RRL_Obj00A_RRL_Obj00A_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj00A_RRL_Obj00A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj00A::RRL_Obj00A_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj00A::RRL_Obj00A_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj00A_RRL_Obj00A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj00A::RRL_Obj00A_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj00A::RRL_Obj00A_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj00A_RRL_Obj00A_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj00A_RRL_Obj00A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj00A::RRL_Obj00A_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj00A::RRL_Obj00A_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj00A_RRL_Obj00A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj00A::RRL_Obj00A_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj00A::RRL_Obj00A_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj00A_RRL_Obj00A_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj00A_RRL_Obj00A_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj00A::RRL_Obj00A_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj00A::RRL_Obj00A_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj00A_RRL_Obj00A_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj00B::RRL_Obj00B_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj00B);
     @CAN_PrivRear::RRL_Obj00B::RRL_Obj00B_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj00B(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj00B.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj00B.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj00B::RRL_Obj00B_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj00B::RRL_Obj00B_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj00B_RRL_Obj00B_AliveCtr;
      counter_RRL_Obj00B_RRL_Obj00B_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj00B_RRL_Obj00B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj00B::RRL_Obj00B_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj00B::RRL_Obj00B_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj00B_RRL_Obj00B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj00B::RRL_Obj00B_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj00B::RRL_Obj00B_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj00B_RRL_Obj00B_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj00B_RRL_Obj00B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj00B::RRL_Obj00B_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj00B::RRL_Obj00B_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj00B_RRL_Obj00B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj00B::RRL_Obj00B_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj00B::RRL_Obj00B_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj00B_RRL_Obj00B_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj00B_RRL_Obj00B_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj00B::RRL_Obj00B_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj00B::RRL_Obj00B_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj00B_RRL_Obj00B_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj01A::RRL_Obj01A_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj01A);
     @CAN_PrivRear::RRL_Obj01A::RRL_Obj01A_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj01A(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj01A.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj01A.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj01A::RRL_Obj01A_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj01A::RRL_Obj01A_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj01A_RRL_Obj01A_AliveCtr;
      counter_RRL_Obj01A_RRL_Obj01A_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj01A_RRL_Obj01A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj01A::RRL_Obj01A_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj01A::RRL_Obj01A_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj01A_RRL_Obj01A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj01A::RRL_Obj01A_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj01A::RRL_Obj01A_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj01A_RRL_Obj01A_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj01A_RRL_Obj01A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj01A::RRL_Obj01A_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj01A::RRL_Obj01A_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj01A_RRL_Obj01A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj01A::RRL_Obj01A_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj01A::RRL_Obj01A_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj01A_RRL_Obj01A_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj01A_RRL_Obj01A_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj01A::RRL_Obj01A_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj01A::RRL_Obj01A_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj01A_RRL_Obj01A_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj01B::RRL_Obj01B_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj01B);
     @CAN_PrivRear::RRL_Obj01B::RRL_Obj01B_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj01B(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj01B.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj01B.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj01B::RRL_Obj01B_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj01B::RRL_Obj01B_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj01B_RRL_Obj01B_AliveCtr;
      counter_RRL_Obj01B_RRL_Obj01B_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj01B_RRL_Obj01B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj01B::RRL_Obj01B_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj01B::RRL_Obj01B_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj01B_RRL_Obj01B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj01B::RRL_Obj01B_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj01B::RRL_Obj01B_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj01B_RRL_Obj01B_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj01B_RRL_Obj01B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj01B::RRL_Obj01B_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj01B::RRL_Obj01B_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj01B_RRL_Obj01B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj01B::RRL_Obj01B_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj01B::RRL_Obj01B_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj01B_RRL_Obj01B_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj01B_RRL_Obj01B_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj01B::RRL_Obj01B_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj01B::RRL_Obj01B_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj01B_RRL_Obj01B_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj02A::RRL_Obj02A_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj02A);
     @CAN_PrivRear::RRL_Obj02A::RRL_Obj02A_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj02A(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj02A.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj02A.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj02A::RRL_Obj02A_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj02A::RRL_Obj02A_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj02A_RRL_Obj02A_AliveCtr;
      counter_RRL_Obj02A_RRL_Obj02A_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj02A_RRL_Obj02A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj02A::RRL_Obj02A_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj02A::RRL_Obj02A_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj02A_RRL_Obj02A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj02A::RRL_Obj02A_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj02A::RRL_Obj02A_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj02A_RRL_Obj02A_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj02A_RRL_Obj02A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj02A::RRL_Obj02A_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj02A::RRL_Obj02A_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj02A_RRL_Obj02A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj02A::RRL_Obj02A_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj02A::RRL_Obj02A_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj02A_RRL_Obj02A_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj02A_RRL_Obj02A_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj02A::RRL_Obj02A_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj02A::RRL_Obj02A_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj02A_RRL_Obj02A_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj02B::RRL_Obj02B_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj02B);
     @CAN_PrivRear::RRL_Obj02B::RRL_Obj02B_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj02B(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj02B.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj02B.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj02B::RRL_Obj02B_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj02B::RRL_Obj02B_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj02B_RRL_Obj02B_AliveCtr;
      counter_RRL_Obj02B_RRL_Obj02B_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj02B_RRL_Obj02B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj02B::RRL_Obj02B_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj02B::RRL_Obj02B_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj02B_RRL_Obj02B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj02B::RRL_Obj02B_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj02B::RRL_Obj02B_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj02B_RRL_Obj02B_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj02B_RRL_Obj02B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj02B::RRL_Obj02B_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj02B::RRL_Obj02B_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj02B_RRL_Obj02B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj02B::RRL_Obj02B_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj02B::RRL_Obj02B_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj02B_RRL_Obj02B_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj02B_RRL_Obj02B_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj02B::RRL_Obj02B_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj02B::RRL_Obj02B_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj02B_RRL_Obj02B_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj03A::RRL_Obj03A_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj03A);
     @CAN_PrivRear::RRL_Obj03A::RRL_Obj03A_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj03A(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj03A.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj03A.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj03A::RRL_Obj03A_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj03A::RRL_Obj03A_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj03A_RRL_Obj03A_AliveCtr;
      counter_RRL_Obj03A_RRL_Obj03A_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj03A_RRL_Obj03A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj03A::RRL_Obj03A_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj03A::RRL_Obj03A_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj03A_RRL_Obj03A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj03A::RRL_Obj03A_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj03A::RRL_Obj03A_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj03A_RRL_Obj03A_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj03A_RRL_Obj03A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj03A::RRL_Obj03A_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj03A::RRL_Obj03A_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj03A_RRL_Obj03A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj03A::RRL_Obj03A_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj03A::RRL_Obj03A_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj03A_RRL_Obj03A_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj03A_RRL_Obj03A_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj03A::RRL_Obj03A_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj03A::RRL_Obj03A_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj03A_RRL_Obj03A_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj03B::RRL_Obj03B_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj03B);
     @CAN_PrivRear::RRL_Obj03B::RRL_Obj03B_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj03B(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj03B.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj03B.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj03B::RRL_Obj03B_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj03B::RRL_Obj03B_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj03B_RRL_Obj03B_AliveCtr;
      counter_RRL_Obj03B_RRL_Obj03B_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj03B_RRL_Obj03B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj03B::RRL_Obj03B_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj03B::RRL_Obj03B_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj03B_RRL_Obj03B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj03B::RRL_Obj03B_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj03B::RRL_Obj03B_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj03B_RRL_Obj03B_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj03B_RRL_Obj03B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj03B::RRL_Obj03B_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj03B::RRL_Obj03B_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj03B_RRL_Obj03B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj03B::RRL_Obj03B_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj03B::RRL_Obj03B_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj03B_RRL_Obj03B_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj03B_RRL_Obj03B_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj03B::RRL_Obj03B_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj03B::RRL_Obj03B_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj03B_RRL_Obj03B_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj04A::RRL_Obj04A_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj04A);
     @CAN_PrivRear::RRL_Obj04A::RRL_Obj04A_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj04A(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj04A.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj04A.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj04A::RRL_Obj04A_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj04A::RRL_Obj04A_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj04A_RRL_Obj04A_AliveCtr;
      counter_RRL_Obj04A_RRL_Obj04A_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj04A_RRL_Obj04A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj04A::RRL_Obj04A_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj04A::RRL_Obj04A_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj04A_RRL_Obj04A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj04A::RRL_Obj04A_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj04A::RRL_Obj04A_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj04A_RRL_Obj04A_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj04A_RRL_Obj04A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj04A::RRL_Obj04A_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj04A::RRL_Obj04A_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj04A_RRL_Obj04A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj04A::RRL_Obj04A_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj04A::RRL_Obj04A_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj04A_RRL_Obj04A_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj04A_RRL_Obj04A_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj04A::RRL_Obj04A_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj04A::RRL_Obj04A_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj04A_RRL_Obj04A_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj04B::RRL_Obj04B_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj04B);
     @CAN_PrivRear::RRL_Obj04B::RRL_Obj04B_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj04B(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj04B.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj04B.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj04B::RRL_Obj04B_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj04B::RRL_Obj04B_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj04B_RRL_Obj04B_AliveCtr;
      counter_RRL_Obj04B_RRL_Obj04B_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj04B_RRL_Obj04B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj04B::RRL_Obj04B_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj04B::RRL_Obj04B_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj04B_RRL_Obj04B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj04B::RRL_Obj04B_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj04B::RRL_Obj04B_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj04B_RRL_Obj04B_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj04B_RRL_Obj04B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj04B::RRL_Obj04B_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj04B::RRL_Obj04B_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj04B_RRL_Obj04B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj04B::RRL_Obj04B_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj04B::RRL_Obj04B_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj04B_RRL_Obj04B_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj04B_RRL_Obj04B_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj04B::RRL_Obj04B_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj04B::RRL_Obj04B_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj04B_RRL_Obj04B_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj05A::RRL_Obj05A_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj05A);
     @CAN_PrivRear::RRL_Obj05A::RRL_Obj05A_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj05A(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj05A.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj05A.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj05A::RRL_Obj05A_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj05A::RRL_Obj05A_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj05A_RRL_Obj05A_AliveCtr;
      counter_RRL_Obj05A_RRL_Obj05A_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj05A_RRL_Obj05A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj05A::RRL_Obj05A_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj05A::RRL_Obj05A_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj05A_RRL_Obj05A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj05A::RRL_Obj05A_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj05A::RRL_Obj05A_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj05A_RRL_Obj05A_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj05A_RRL_Obj05A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj05A::RRL_Obj05A_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj05A::RRL_Obj05A_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj05A_RRL_Obj05A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj05A::RRL_Obj05A_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj05A::RRL_Obj05A_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj05A_RRL_Obj05A_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj05A_RRL_Obj05A_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj05A::RRL_Obj05A_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj05A::RRL_Obj05A_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj05A_RRL_Obj05A_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj05B::RRL_Obj05B_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj05B);
     @CAN_PrivRear::RRL_Obj05B::RRL_Obj05B_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj05B(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj05B.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj05B.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj05B::RRL_Obj05B_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj05B::RRL_Obj05B_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj05B_RRL_Obj05B_AliveCtr;
      counter_RRL_Obj05B_RRL_Obj05B_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj05B_RRL_Obj05B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj05B::RRL_Obj05B_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj05B::RRL_Obj05B_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj05B_RRL_Obj05B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj05B::RRL_Obj05B_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj05B::RRL_Obj05B_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj05B_RRL_Obj05B_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj05B_RRL_Obj05B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj05B::RRL_Obj05B_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj05B::RRL_Obj05B_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj05B_RRL_Obj05B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj05B::RRL_Obj05B_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj05B::RRL_Obj05B_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj05B_RRL_Obj05B_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj05B_RRL_Obj05B_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj05B::RRL_Obj05B_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj05B::RRL_Obj05B_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj05B_RRL_Obj05B_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj06A::RRL_Obj06A_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj06A);
     @CAN_PrivRear::RRL_Obj06A::RRL_Obj06A_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj06A(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj06A.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj06A.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj06A::RRL_Obj06A_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj06A::RRL_Obj06A_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj06A_RRL_Obj06A_AliveCtr;
      counter_RRL_Obj06A_RRL_Obj06A_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj06A_RRL_Obj06A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj06A::RRL_Obj06A_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj06A::RRL_Obj06A_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj06A_RRL_Obj06A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj06A::RRL_Obj06A_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj06A::RRL_Obj06A_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj06A_RRL_Obj06A_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj06A_RRL_Obj06A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj06A::RRL_Obj06A_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj06A::RRL_Obj06A_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj06A_RRL_Obj06A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj06A::RRL_Obj06A_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj06A::RRL_Obj06A_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj06A_RRL_Obj06A_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj06A_RRL_Obj06A_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj06A::RRL_Obj06A_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj06A::RRL_Obj06A_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj06A_RRL_Obj06A_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj06B::RRL_Obj06B_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj06B);
     @CAN_PrivRear::RRL_Obj06B::RRL_Obj06B_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj06B(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj06B.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj06B.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj06B::RRL_Obj06B_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj06B::RRL_Obj06B_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj06B_RRL_Obj06B_AliveCtr;
      counter_RRL_Obj06B_RRL_Obj06B_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj06B_RRL_Obj06B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj06B::RRL_Obj06B_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj06B::RRL_Obj06B_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj06B_RRL_Obj06B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj06B::RRL_Obj06B_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj06B::RRL_Obj06B_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj06B_RRL_Obj06B_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj06B_RRL_Obj06B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj06B::RRL_Obj06B_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj06B::RRL_Obj06B_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj06B_RRL_Obj06B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj06B::RRL_Obj06B_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj06B::RRL_Obj06B_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj06B_RRL_Obj06B_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj06B_RRL_Obj06B_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj06B::RRL_Obj06B_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj06B::RRL_Obj06B_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj06B_RRL_Obj06B_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj07A::RRL_Obj07A_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj07A);
     @CAN_PrivRear::RRL_Obj07A::RRL_Obj07A_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj07A(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj07A.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj07A.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj07A::RRL_Obj07A_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj07A::RRL_Obj07A_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj07A_RRL_Obj07A_AliveCtr;
      counter_RRL_Obj07A_RRL_Obj07A_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj07A_RRL_Obj07A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj07A::RRL_Obj07A_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj07A::RRL_Obj07A_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj07A_RRL_Obj07A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj07A::RRL_Obj07A_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj07A::RRL_Obj07A_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj07A_RRL_Obj07A_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj07A_RRL_Obj07A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj07A::RRL_Obj07A_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj07A::RRL_Obj07A_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj07A_RRL_Obj07A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj07A::RRL_Obj07A_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj07A::RRL_Obj07A_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj07A_RRL_Obj07A_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj07A_RRL_Obj07A_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj07A::RRL_Obj07A_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj07A::RRL_Obj07A_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj07A_RRL_Obj07A_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj07B::RRL_Obj07B_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj07B);
     @CAN_PrivRear::RRL_Obj07B::RRL_Obj07B_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj07B(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj07B.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj07B.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj07B::RRL_Obj07B_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj07B::RRL_Obj07B_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj07B_RRL_Obj07B_AliveCtr;
      counter_RRL_Obj07B_RRL_Obj07B_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj07B_RRL_Obj07B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj07B::RRL_Obj07B_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj07B::RRL_Obj07B_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj07B_RRL_Obj07B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj07B::RRL_Obj07B_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj07B::RRL_Obj07B_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj07B_RRL_Obj07B_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj07B_RRL_Obj07B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj07B::RRL_Obj07B_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj07B::RRL_Obj07B_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj07B_RRL_Obj07B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj07B::RRL_Obj07B_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj07B::RRL_Obj07B_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj07B_RRL_Obj07B_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj07B_RRL_Obj07B_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj07B::RRL_Obj07B_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj07B::RRL_Obj07B_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj07B_RRL_Obj07B_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj08A::RRL_Obj08A_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj08A);
     @CAN_PrivRear::RRL_Obj08A::RRL_Obj08A_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj08A(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj08A.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj08A.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj08A::RRL_Obj08A_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj08A::RRL_Obj08A_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj08A_RRL_Obj08A_AliveCtr;
      counter_RRL_Obj08A_RRL_Obj08A_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj08A_RRL_Obj08A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj08A::RRL_Obj08A_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj08A::RRL_Obj08A_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj08A_RRL_Obj08A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj08A::RRL_Obj08A_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj08A::RRL_Obj08A_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj08A_RRL_Obj08A_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj08A_RRL_Obj08A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj08A::RRL_Obj08A_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj08A::RRL_Obj08A_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj08A_RRL_Obj08A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj08A::RRL_Obj08A_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj08A::RRL_Obj08A_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj08A_RRL_Obj08A_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj08A_RRL_Obj08A_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj08A::RRL_Obj08A_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj08A::RRL_Obj08A_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj08A_RRL_Obj08A_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj08B::RRL_Obj08B_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj08B);
     @CAN_PrivRear::RRL_Obj08B::RRL_Obj08B_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj08B(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj08B.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj08B.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj08B::RRL_Obj08B_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj08B::RRL_Obj08B_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj08B_RRL_Obj08B_AliveCtr;
      counter_RRL_Obj08B_RRL_Obj08B_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj08B_RRL_Obj08B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj08B::RRL_Obj08B_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj08B::RRL_Obj08B_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj08B_RRL_Obj08B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj08B::RRL_Obj08B_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj08B::RRL_Obj08B_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj08B_RRL_Obj08B_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj08B_RRL_Obj08B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj08B::RRL_Obj08B_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj08B::RRL_Obj08B_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj08B_RRL_Obj08B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj08B::RRL_Obj08B_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj08B::RRL_Obj08B_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj08B_RRL_Obj08B_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj08B_RRL_Obj08B_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj08B::RRL_Obj08B_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj08B::RRL_Obj08B_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj08B_RRL_Obj08B_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj09A::RRL_Obj09A_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj09A);
     @CAN_PrivRear::RRL_Obj09A::RRL_Obj09A_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj09A(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj09A.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj09A.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj09A::RRL_Obj09A_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj09A::RRL_Obj09A_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj09A_RRL_Obj09A_AliveCtr;
      counter_RRL_Obj09A_RRL_Obj09A_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj09A_RRL_Obj09A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj09A::RRL_Obj09A_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj09A::RRL_Obj09A_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj09A_RRL_Obj09A_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj09A::RRL_Obj09A_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj09A::RRL_Obj09A_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj09A_RRL_Obj09A_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj09A_RRL_Obj09A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj09A::RRL_Obj09A_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj09A::RRL_Obj09A_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj09A_RRL_Obj09A_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj09A::RRL_Obj09A_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj09A::RRL_Obj09A_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj09A_RRL_Obj09A_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj09A_RRL_Obj09A_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj09A::RRL_Obj09A_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj09A::RRL_Obj09A_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj09A_RRL_Obj09A_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Obj09B::RRL_Obj09B_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_Obj09B);
     @CAN_PrivRear::RRL_Obj09B::RRL_Obj09B_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_Obj09B(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Obj09B.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Obj09B.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Obj09B::RRL_Obj09B_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj09B::RRL_Obj09B_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Obj09B_RRL_Obj09B_AliveCtr;
      counter_RRL_Obj09B_RRL_Obj09B_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_Obj09B_RRL_Obj09B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj09B::RRL_Obj09B_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj09B::RRL_Obj09B_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Obj09B_RRL_Obj09B_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj09B::RRL_Obj09B_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Obj09B::RRL_Obj09B_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_RRL_Obj09B_RRL_Obj09B_ProtBlockCtr = bc_RRL_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_Obj09B_RRL_Obj09B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj09B::RRL_Obj09B_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Obj09B::RRL_Obj09B_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_Obj09B_RRL_Obj09B_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Obj09B::RRL_Obj09B_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Obj09B::RRL_Obj09B_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_Obj09B_RRL_Obj09B_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_Obj09B_RRL_Obj09B_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj09B::RRL_Obj09B_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Obj09B::RRL_Obj09B_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Obj09B_RRL_Obj09B_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(RRL_ObjHdr);
     @CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_ON_OFF = 0;
  }
}

void cfg_Msg_RRL_ObjHdr(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_ObjHdr.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_ObjHdr.id;//Message ID
   
    if (@CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_ObjHdr_RRL_ObjHdr_AliveCtr;
      counter_RRL_ObjHdr_RRL_ObjHdr_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_RRL_ObjHdr_RRL_ObjHdr_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_ObjHdr_RRL_ObjHdr_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      ++bc_RRL_ObjHdr_RRL_ObjHdr_ProtBlockCtr;
      bc_RRL_ObjHdr_RRL_ObjHdr_ProtBlockCtr %=16;
      bc_RRL_Object_ProtBlockCtr = bc_RRL_ObjHdr_RRL_ObjHdr_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_RRL_ObjHdr_RRL_ObjHdr_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_RRL_ObjHdr_RRL_ObjHdr_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }

    clearBitsInByteArrayLE(data,96,26); //Intel / little-endian

    //Msg_RRL_ObjHdr.RRL_ObjHdr_TimeStamp = @CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_TimeStamp_FaultInject +(timeNowNS()/1000000);

      copyBitsToByteArrayLE(@CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_TimeStamp_FaultInject +(timeNowNS()/1000000),data,96,26); //Intel / little-endian;
    if (@CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup_PRIVATE(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_RRL_ObjHdr_RRL_ObjHdr_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_RRL_ObjHdr_RRL_ObjHdr_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_ObjHdr::RRL_ObjHdr_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_ObjHdr_RRL_ObjHdr_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Status::RRL_Status_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(RRL_Status);
  }
  else{
         ILFaultInjectionDisableMsg(RRL_Status);
      }
}

void cfg_Msg_RRL_Status(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RRL_Status.DataLength;//Message Data Length
   Msg_id  = Msg_RRL_Status.id;//Message ID
   
    if (@CAN_PrivRear::RRL_Status::RRL_Status_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_PrivRear::RRL_Status::RRL_Status_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RRL_Status_RRL_Status_AliveCtr;
      counter_RRL_Status_RRL_Status_AliveCtr %=16;

      copyBitsToByteArrayLE(counter_RRL_Status_RRL_Status_AliveCtr,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Status::RRL_Status_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_PrivRear::RRL_Status::RRL_Status_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RRL_Status_RRL_Status_AliveCtr,data,8,4); //Intel / little-endian;
    }
    if (@CAN_PrivRear::RRL_Status::RRL_Status_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_PrivRear::RRL_Status::RRL_Status_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup_PRIVATE(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      crc_RRL_Status_RRL_Status_CRC = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(crc_RRL_Status_RRL_Status_CRC,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Status::RRL_Status_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_PrivRear::RRL_Status::RRL_Status_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_RRL_Status_RRL_Status_CRC,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_PrivRear::RRL_Status::RRL_Status_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(RRL_Status,@this);
  //ILFaultInjectionResetMsgCycleTime(RRL_Status);
}

void CRadarRL_sim_SetCycleTimeOffset()
{

//  ILNodeSetPDUTimingCyclic (dbMsg dbMessage, long TrueOrFalse, long offset, long period, long disturbanceCount, long flags);
//  TrueOrFalse ; 0: denotes the False timing; 1: denotes the True timing; 3: denotes the True and the False timing.
//  offset :Defines the delay in [ms] from now when the first cyclic transmission will start.
//  period :Defines the period in [ms] for the cyclic transmission.
//  disturbanceCount :Reserved/unused; should be set to -1 (infinite).
//  flags :Reserved; should be set to 0.

}