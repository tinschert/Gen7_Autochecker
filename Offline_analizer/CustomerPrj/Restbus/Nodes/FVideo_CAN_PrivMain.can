/*@!Encoding:1252*/
/**
 * @file FVideo_CAN_PrivMain.can
 * @author ADAS_HIL_TEAM
 * @date 10-04-2022
 * @brief 
 *
 * ################################################################
 * C O P Y R I G H T S
 * ----------------------------------------------------------------
 * Copyright (c) 2022-2023 by Robert Bosch GmbH. All rights reserved.
 
 * The reproduction, distribution and utilization of this file as
 * well as the communication of its contents to others without express
 * authorization is prohibited. Offenders will be held liable for the
 * payment of damages. All rights reserved in the event of the grant
 * of a patent, utility model or design.
 *
 * ################################################################
*/

// Autogenerated by -> Platform\Classe\Scripts\Rbs_Scripts\create_nodes.py
includes
{
  #pragma library ("C:\ProgramData\Vector\AddOn Packages\Vector AddOn\vModules\CANoeILNLVector.vmodule")
  #include "CAPL\DataHandling.cin" /*DataHandling for IL*/
  #include "CAPL\E2E.cin" /*OD Specific for CRC calculation */
}

variables {
  message VFC_AEB_Request Msg_VFC_AEB_Request;
  message VFC_Status Msg_VFC_Status;
  message VFC_ObjectHdr Msg_VFC_ObjectHdr;
  message VFC_Object00 Msg_VFC_Object00;
  message VFC_Object01 Msg_VFC_Object01;
  message VFC_Object02 Msg_VFC_Object02;
  message VFC_Object03 Msg_VFC_Object03;
  message VFC_Object04 Msg_VFC_Object04;
  message VFC_Object05 Msg_VFC_Object05;
  message VFC_Object06 Msg_VFC_Object06;
  message VFC_Object07 Msg_VFC_Object07;
  message VFC_Object08 Msg_VFC_Object08;
  message VFC_Object09 Msg_VFC_Object09;
  message VFC_Object10 Msg_VFC_Object10;
  message VFC_Object11 Msg_VFC_Object11;
  message VFC_Object12 Msg_VFC_Object12;
  message VFC_Object13 Msg_VFC_Object13;
  message VFC_Object14 Msg_VFC_Object14;
  message VFC_Object15 Msg_VFC_Object15;
  message VFC_Object16 Msg_VFC_Object16;
  message VFC_Object17 Msg_VFC_Object17;
  message VFC_Object18 Msg_VFC_Object18;
  message VFC_Object19 Msg_VFC_Object19;
  message VFC_Object20 Msg_VFC_Object20;
  message VFC_Object21 Msg_VFC_Object21;
  message VFC_Object22 Msg_VFC_Object22;
  message VFC_Object23 Msg_VFC_Object23;
  message VFC_OcaHdr Msg_VFC_OcaHdr;
  message VFC_Oca_000_017 Msg_VFC_Oca_000_017;
  message VFC_Oca_018_035 Msg_VFC_Oca_018_035;
  message VFC_Oca_036_053 Msg_VFC_Oca_036_053;
  message VFC_Oca_054_071 Msg_VFC_Oca_054_071;
  message VFC_RoadHdr Msg_VFC_RoadHdr;
  message VFC_RoadClothoid_00_02 Msg_VFC_RoadClothoid_00_02;
  message VFC_RoadClothoid_03_05 Msg_VFC_RoadClothoid_03_05;
  message VFC_RoadClothoid_06_08 Msg_VFC_RoadClothoid_06_08;
  message VFC_RoadClothoid_09_11 Msg_VFC_RoadClothoid_09_11;
  message VFC_RoadPolynomial_00_02 Msg_VFC_RoadPolynomial_00_02;
  message VFC_RoadPolynomial_03_05 Msg_VFC_RoadPolynomial_03_05;
  message VFC_RoadPolynomial_06_08 Msg_VFC_RoadPolynomial_06_08;
  message VFC_RoadPolynomial_09_11 Msg_VFC_RoadPolynomial_09_11;
  message VFC_RoadPolynomial_12_14 Msg_VFC_RoadPolynomial_12_14;
  message VFC_Road2DPolynomial_00_02 Msg_VFC_Road2DPolynomial_00_02;
  message VFC_Road2DPolynomial_03_05 Msg_VFC_Road2DPolynomial_03_05;
  message VFC_Road2DPolynomial_06_08 Msg_VFC_Road2DPolynomial_06_08;
  message VFC_Road2DPolynomial_09_11 Msg_VFC_Road2DPolynomial_09_11;
  message VFC_Road2DPolynomial_12_14 Msg_VFC_Road2DPolynomial_12_14;
  message VFC_RoadMarking_00_06 Msg_VFC_RoadMarking_00_06;
  message VFC_TrafficLightHdr Msg_VFC_TrafficLightHdr;
  message VFC_TrafficLight_00_04 Msg_VFC_TrafficLight_00_04;
  message VFC_TrafficLight_05_09 Msg_VFC_TrafficLight_05_09;
  message VFC_TrafficSignHdr Msg_VFC_TrafficSignHdr;
  message VFC_TrafficSign_00_01 Msg_VFC_TrafficSign_00_01;
  message VFC_TrafficSign_02_03 Msg_VFC_TrafficSign_02_03;
  message VFC_TrafficSign_04_05 Msg_VFC_TrafficSign_04_05;
  message VFC_TrafficSign_06_07 Msg_VFC_TrafficSign_06_07;
  message VFC_TrafficSign_08_09 Msg_VFC_TrafficSign_08_09;
  message VFC_TrafficSign_10_11 Msg_VFC_TrafficSign_10_11;
  message VFC_TrafficSign_12_13 Msg_VFC_TrafficSign_12_13;
  message VFC_TrafficSign_14_15 Msg_VFC_TrafficSign_14_15;

  word counter_VFC_AEB_Request_VFC_AEB_AC;
  word counter_VFC_Status_VFC_Status_AliveCtr;
  word counter_VFC_Status_VFC_Status_FrameNumber;
  word counter_VFC_ObjectHdr_VFC_ObjHdr_AliveCtr;
  word counter_VFC_Object00_VFC_Obj00_AliveCtr;
  word counter_VFC_Object01_VFC_Obj01_AliveCtr;
  word counter_VFC_Object02_VFC_Obj02_AliveCtr;
  word counter_VFC_Object03_VFC_Obj03_AliveCtr;
  word counter_VFC_Object04_VFC_Obj04_AliveCtr;
  word counter_VFC_Object05_VFC_Obj05_AliveCtr;
  word counter_VFC_Object06_VFC_Obj06_AliveCtr;
  word counter_VFC_Object07_VFC_Obj07_AliveCtr;
  word counter_VFC_Object08_VFC_Obj08_AliveCtr;
  word counter_VFC_Object09_VFC_Obj09_AliveCtr;
  word counter_VFC_Object10_VFC_Obj10_AliveCtr;
  word counter_VFC_Object11_VFC_Obj11_AliveCtr;
  word counter_VFC_Object12_VFC_Obj12_AliveCtr;
  word counter_VFC_Object13_VFC_Obj13_AliveCtr;
  word counter_VFC_Object14_VFC_Obj14_AliveCtr;
  word counter_VFC_Object15_VFC_Obj15_AliveCtr;
  word counter_VFC_Object16_VFC_Obj16_AliveCtr;
  word counter_VFC_Object17_VFC_Obj17_AliveCtr;
  word counter_VFC_Object18_VFC_Obj18_AliveCtr;
  word counter_VFC_Object19_VFC_Obj19_AliveCtr;
  word counter_VFC_Object20_VFC_Obj20_AliveCtr;
  word counter_VFC_Object21_VFC_Obj21_AliveCtr;
  word counter_VFC_Object22_VFC_Obj22_AliveCtr;
  word counter_VFC_Object23_VFC_Obj23_AliveCtr;
  word counter_VFC_OcaHdr_VFC_OcaHdr_AliveCtr;
  word counter_VFC_Oca_000_017_VFC_Oca_000_017_AliveCtr;
  word counter_VFC_Oca_018_035_VFC_Oca_018_035_AliveCtr;
  word counter_VFC_Oca_036_053_VFC_Oca_036_053_AliveCtr;
  word counter_VFC_Oca_054_071_VFC_Oca_054_071_AliveCtr;
  word counter_VFC_RoadHdr_VFC_RoadHdr_AliveCtr;
  word counter_VFC_RoadClothoid_00_02_VFC_Cloth_00_02_AliveCtr;
  word counter_VFC_RoadClothoid_03_05_VFC_Cloth_03_05_AliveCtr;
  word counter_VFC_RoadClothoid_06_08_VFC_Cloth_06_08_AliveCtr;
  word counter_VFC_RoadClothoid_09_11_VFC_Cloth_09_11_AliveCtr;
  word counter_VFC_RoadPolynomial_00_02_VFC_Poly_00_02_AliveCtr;
  word counter_VFC_RoadPolynomial_03_05_VFC_Poly_03_05_AliveCtr;
  word counter_VFC_RoadPolynomial_06_08_VFC_Poly_06_08_AliveCtr;
  word counter_VFC_RoadPolynomial_09_11_VFC_Poly_09_11_AliveCtr;
  word counter_VFC_RoadPolynomial_12_14_VFC_Poly_12_14_AliveCtr;
  word counter_VFC_Road2DPolynomial_00_02_VFC_2DPoly_00_02_AliveCtr;
  word counter_VFC_Road2DPolynomial_03_05_VFC_2DPoly_03_05_AliveCtr;
  word counter_VFC_Road2DPolynomial_06_08_VFC_2DPoly_06_08_AliveCtr;
  word counter_VFC_Road2DPolynomial_09_11_VFC_2DPoly_09_11_AliveCtr;
  word counter_VFC_Road2DPolynomial_12_14_VFC_2DPoly_12_14_AliveCtr;
  word counter_VFC_RoadMarking_00_06_VFC_RM_00_06_AliveCtr;
  word counter_VFC_TrafficLightHdr_VFC_TLHdr_AliveCtr;
  word counter_VFC_TrafficLight_00_04_VFC_TL00_04_AliveCtr;
  word counter_VFC_TrafficLight_05_09_VFC_TL05_09_AliveCtr;
  word counter_VFC_TrafficSignHdr_VFC_TSHdr_AliveCtr;
  word counter_VFC_TrafficSign_00_01_VFC_TS_00_01_AliveCtr;
  word counter_VFC_TrafficSign_02_03_VFC_TS_02_03_AliveCtr;
  word counter_VFC_TrafficSign_04_05_VFC_TS_04_05_AliveCtr;
  word counter_VFC_TrafficSign_06_07_VFC_TS_06_07_AliveCtr;
  word counter_VFC_TrafficSign_08_09_VFC_TS_08_09_AliveCtr;
  word counter_VFC_TrafficSign_10_11_VFC_TS_10_11_AliveCtr;
  word counter_VFC_TrafficSign_12_13_VFC_TS_12_13_AliveCtr;
  word counter_VFC_TrafficSign_14_15_VFC_TS_14_15_AliveCtr;

  dword bc_VFC_ObjectHdr_VFC_ObjHdr_ProtBlockCtr;
  dword bc_VFC_Object_ProtBlockCtr;
  dword bc_VFC_Object00_VFC_Obj00_ProtBlockCtr;
  dword bc_VFC_Object01_VFC_Obj01_ProtBlockCtr;
  dword bc_VFC_Object02_VFC_Obj02_ProtBlockCtr;
  dword bc_VFC_Object03_VFC_Obj03_ProtBlockCtr;
  dword bc_VFC_Object04_VFC_Obj04_ProtBlockCtr;
  dword bc_VFC_Object05_VFC_Obj05_ProtBlockCtr;
  dword bc_VFC_Object06_VFC_Obj06_ProtBlockCtr;
  dword bc_VFC_Object07_VFC_Obj07_ProtBlockCtr;
  dword bc_VFC_Object08_VFC_Obj08_ProtBlockCtr;
  dword bc_VFC_Object09_VFC_Obj09_ProtBlockCtr;
  dword bc_VFC_Object10_VFC_Obj10_ProtBlockCtr;
  dword bc_VFC_Object11_VFC_Obj11_ProtBlockCtr;
  dword bc_VFC_Object12_VFC_Obj12_ProtBlockCtr;
  dword bc_VFC_Object13_VFC_Obj13_ProtBlockCtr;
  dword bc_VFC_Object14_VFC_Obj14_ProtBlockCtr;
  dword bc_VFC_Object15_VFC_Obj15_ProtBlockCtr;
  dword bc_VFC_Object16_VFC_Obj16_ProtBlockCtr;
  dword bc_VFC_Object17_VFC_Obj17_ProtBlockCtr;
  dword bc_VFC_Object18_VFC_Obj18_ProtBlockCtr;
  dword bc_VFC_Object19_VFC_Obj19_ProtBlockCtr;
  dword bc_VFC_Object20_VFC_Obj20_ProtBlockCtr;
  dword bc_VFC_Object21_VFC_Obj21_ProtBlockCtr;
  dword bc_VFC_Object22_VFC_Obj22_ProtBlockCtr;
  dword bc_VFC_Object23_VFC_Obj23_ProtBlockCtr;
  dword bc_VFC_OcaHdr_VFC_OcaHdr_ProtBlockCtr;
  dword bc_None_ProtBlockCtr;
  dword bc_VFC_Oca_000_017_VFC_Oca_000_017_ProtBlockCtr;
  dword bc_VFC_Oca_018_035_VFC_Oca_018_035_ProtBlockCtr;
  dword bc_VFC_Oca_036_053_VFC_Oca_036_053_ProtBlockCtr;
  dword bc_VFC_Oca_054_071_VFC_Oca_054_071_ProtBlockCtr;
  dword bc_VFC_RoadHdr_VFC_RoadHdr_ProtBlockCtr;
  dword bc_VFC_Road_ProtBlockCtr;
  dword bc_VFC_RoadClothoid_00_02_VFC_Cloth_00_02_ProtBlockCtr;
  dword bc_VFC_RoadClothoid_03_05_VFC_Cloth_03_05_ProtBlockCtr;
  dword bc_VFC_RoadClothoid_06_08_VFC_Cloth_06_08_ProtBlockCtr;
  dword bc_VFC_RoadClothoid_09_11_VFC_Cloth_09_11_ProtBlockCtr;
  dword bc_VFC_RoadPolynomial_00_02_VFC_Poly_00_02_ProtBlockCtr;
  dword bc_VFC_RoadPolynomial_03_05_VFC_Poly_03_05_ProtBlockCtr;
  dword bc_VFC_RoadPolynomial_06_08_VFC_Poly_06_08_ProtBlockCtr;
  dword bc_VFC_RoadPolynomial_09_11_VFC_Poly_09_11_ProtBlockCtr;
  dword bc_VFC_RoadPolynomial_12_14_VFC_Poly_12_14_ProtBlockCtr;
  dword bc_VFC_Road2DPolynomial_00_02_VFC_2DPoly_00_02_ProtBlockCtr;
  dword bc_VFC_Road2DPolynomial_03_05_VFC_2DPoly_03_05_ProtBlockCtr;
  dword bc_VFC_Road2DPolynomial_06_08_VFC_2DPoly_06_08_ProtBlockCtr;
  dword bc_VFC_Road2DPolynomial_09_11_VFC_2DPoly_09_11_ProtBlockCtr;
  dword bc_VFC_Road2DPolynomial_12_14_VFC_2DPoly_12_14_ProtBlockCtr;
  dword bc_VFC_RoadMarking_00_06_VFC_RM_00_06_ProtBlockCtr;
  dword bc_VFC_TrafficLightHdr_VFC_TLHdr_ProtBlockCtr;
  dword bc_VFC_TrafficLight_ProtBlockCtr;
  dword bc_VFC_TrafficLight_00_04_VFC_TL00_04_ProtBlockCtr;
  dword bc_VFC_TrafficLight_05_09_VFC_TL05_09_ProtBlockCtr;
  dword bc_VFC_TrafficSignHdr_VFC_TSHdr_ProtBlockCtr;
  dword bc_VFC_TrafficSign_ProtBlockCtr;
  dword bc_VFC_TrafficSign_00_01_VFC_TS_00_01_ProtBlockCtr;
  dword bc_VFC_TrafficSign_02_03_VFC_TS_02_03_ProtBlockCtr;
  dword bc_VFC_TrafficSign_04_05_VFC_TS_04_05_ProtBlockCtr;
  dword bc_VFC_TrafficSign_06_07_VFC_TS_06_07_ProtBlockCtr;
  dword bc_VFC_TrafficSign_08_09_VFC_TS_08_09_ProtBlockCtr;
  dword bc_VFC_TrafficSign_10_11_VFC_TS_10_11_ProtBlockCtr;
  dword bc_VFC_TrafficSign_12_13_VFC_TS_12_13_ProtBlockCtr;
  dword bc_VFC_TrafficSign_14_15_VFC_TS_14_15_ProtBlockCtr;

  byte crc_VFC_AEB_Request_VFC_AEB_CRC;
  dword crc_VFC_Status_VFC_Status_CRC;
  dword crc_VFC_ObjectHdr_VFC_ObjHdr_CRC;
  dword crc_VFC_Object00_VFC_Obj00_CRC;
  dword crc_VFC_Object01_VFC_Obj01_CRC;
  dword crc_VFC_Object02_VFC_Obj02_CRC;
  dword crc_VFC_Object03_VFC_Obj03_CRC;
  dword crc_VFC_Object04_VFC_Obj04_CRC;
  dword crc_VFC_Object05_VFC_Obj05_CRC;
  dword crc_VFC_Object06_VFC_Obj06_CRC;
  dword crc_VFC_Object07_VFC_Obj07_CRC;
  dword crc_VFC_Object08_VFC_Obj08_CRC;
  dword crc_VFC_Object09_VFC_Obj09_CRC;
  dword crc_VFC_Object10_VFC_Obj10_CRC;
  dword crc_VFC_Object11_VFC_Obj11_CRC;
  dword crc_VFC_Object12_VFC_Obj12_CRC;
  dword crc_VFC_Object13_VFC_Obj13_CRC;
  dword crc_VFC_Object14_VFC_Obj14_CRC;
  dword crc_VFC_Object15_VFC_Obj15_CRC;
  dword crc_VFC_Object16_VFC_Obj16_CRC;
  dword crc_VFC_Object17_VFC_Obj17_CRC;
  dword crc_VFC_Object18_VFC_Obj18_CRC;
  dword crc_VFC_Object19_VFC_Obj19_CRC;
  dword crc_VFC_Object20_VFC_Obj20_CRC;
  dword crc_VFC_Object21_VFC_Obj21_CRC;
  dword crc_VFC_Object22_VFC_Obj22_CRC;
  dword crc_VFC_Object23_VFC_Obj23_CRC;
  dword crc_VFC_OcaHdr_VFC_OcaHdr_CRC;
  dword crc_VFC_Oca_000_017_VFC_Oca_000_017_CRC;
  dword crc_VFC_Oca_018_035_VFC_Oca_018_035_CRC;
  dword crc_VFC_Oca_036_053_VFC_Oca_036_053_CRC;
  dword crc_VFC_Oca_054_071_VFC_Oca_054_071_CRC;
  dword crc_VFC_RoadHdr_VFC_RoadHdr_CRC;
  dword crc_VFC_RoadClothoid_00_02_VFC_Cloth_00_02_CRC;
  dword crc_VFC_RoadClothoid_03_05_VFC_Cloth_03_05_CRC;
  dword crc_VFC_RoadClothoid_06_08_VFC_Cloth_06_08_CRC;
  dword crc_VFC_RoadClothoid_09_11_VFC_Cloth_09_11_CRC;
  dword crc_VFC_RoadPolynomial_00_02_VFC_Poly_00_02_CRC;
  dword crc_VFC_RoadPolynomial_03_05_VFC_Poly_03_05_CRC;
  dword crc_VFC_RoadPolynomial_06_08_VFC_Poly_06_08_CRC;
  dword crc_VFC_RoadPolynomial_09_11_VFC_Poly_09_11_CRC;
  dword crc_VFC_RoadPolynomial_12_14_VFC_Poly_12_14_CRC;
  dword crc_VFC_Road2DPolynomial_00_02_VFC_2DPoly_00_02_CRC;
  dword crc_VFC_Road2DPolynomial_03_05_VFC_2DPoly_03_05_CRC;
  dword crc_VFC_Road2DPolynomial_06_08_VFC_2DPoly_06_08_CRC;
  dword crc_VFC_Road2DPolynomial_09_11_VFC_2DPoly_09_11_CRC;
  dword crc_VFC_Road2DPolynomial_12_14_VFC_2DPoly_12_14_CRC;
  dword crc_VFC_RoadMarking_00_06_VFC_RM_00_06_CRC;
  dword crc_VFC_TrafficLightHdr_VFC_TLHdr_CRC;
  dword crc_VFC_TrafficLight_00_04_VFC_TL00_04_CRC;
  dword crc_VFC_TrafficLight_05_09_VFC_TL05_09_CRC;
  dword crc_VFC_TrafficSignHdr_VFC_TSHdr_CRC;
  dword crc_VFC_TrafficSign_00_01_VFC_TS_00_01_CRC;
  dword crc_VFC_TrafficSign_02_03_VFC_TS_02_03_CRC;
  dword crc_VFC_TrafficSign_04_05_VFC_TS_04_05_CRC;
  dword crc_VFC_TrafficSign_06_07_VFC_TS_06_07_CRC;
  dword crc_VFC_TrafficSign_08_09_VFC_TS_08_09_CRC;
  dword crc_VFC_TrafficSign_10_11_VFC_TS_10_11_CRC;
  dword crc_VFC_TrafficSign_12_13_VFC_TS_12_13_CRC;
  dword crc_VFC_TrafficSign_14_15_VFC_TS_14_15_CRC;

}

on preStart {
  long result;
  result=ILControlInit ();//Initialization of CANoe IL,to prevent the IL autostart function.
  switch(result)
  {
    case  0   : write("ILControlInit :: FVideo :: No error."); break;
    case -1   : write("ILControlInit :: FVideo :: Momentary state of the IL does not permit this query."); break;
    case -50  : write("ILControlInit :: FVideo :: Nodelayer is inactive - possibly deactivated in the nodes configuration dialog.");  break;
   }

  FVideo_sim_Disable();
  FVideo_sim_SetCycleTimeOffset();
}

on start {

  ILControlSimulationOn();//Starts the simulation of the IL.
  FVideo_sim_SetCANFDParameter();
  ILControlStart ();//Cyclical sending starts; setting signals is now possible.
  FVideo_sim_Reset();
}

on stopMeasurement {

  FVideo_sim_DisableMsg();
  FVideo_sim_Disable();
  ILControlStop();//Cyclical sending is stopped; setting signals is now no longer possible.
  ILControlSimulationOff();//Stops the simulation of the IL. After that no other function to control the IL has an effect to the IL.

}

on sysvar_update hil_ctrl::fvideo_sim
{
  FVideo_sim_Reset();
}

on sysvar_update hil_ctrl::variant
{
  FVideo_sim_Reset();
}

on sysvar_update Cus_bus::bus_CAN_PrivMain_ON_OFF
{
  FVideo_sim_Reset();
}

void FVideo_sim_Reset()
{

  FVideo_sim_DisableMsg();
  FVideo_sim_Disable();

  if ((@Cus_bus::bus_CAN_PrivMain_ON_OFF == 1) && (@hil_ctrl::fvideo_sim == 1))
  {
    switch(@hil_ctrl::variant)
    {
      case a_variant:FVideo_sim_start_a_variant();break;
      case b_variant:FVideo_sim_start_b_variant();break;
    }
    if (@hil_ctrl::hil_mode == @hil_ctrl::hil_mode::Restbus) 
    {
       FVideo_sim_EnableEventMsg();
    }
    else
    {
       FVideo_sim_DisableEventMsg();
    }
  }
}

void FVideo_sim_start_a_variant()
{
}

void FVideo_sim_start_b_variant()
{
}

void FVideo_sim_Disable()
{
  @CAN_PrivMain::VFC_AEB_Request::VFC_AEB_Request_ON_OFF = 0;
  @CAN_PrivMain::VFC_Status::VFC_Status_ON_OFF = 0;
  @CAN_PrivMain::VFC_ObjectHdr::VFC_ObjectHdr_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object00::VFC_Object00_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object01::VFC_Object01_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object02::VFC_Object02_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object03::VFC_Object03_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object04::VFC_Object04_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object05::VFC_Object05_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object06::VFC_Object06_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object07::VFC_Object07_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object08::VFC_Object08_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object09::VFC_Object09_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object10::VFC_Object10_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object11::VFC_Object11_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object12::VFC_Object12_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object13::VFC_Object13_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object14::VFC_Object14_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object15::VFC_Object15_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object16::VFC_Object16_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object17::VFC_Object17_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object18::VFC_Object18_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object19::VFC_Object19_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object20::VFC_Object20_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object21::VFC_Object21_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object22::VFC_Object22_ON_OFF = 0;
  @CAN_PrivMain::VFC_Object23::VFC_Object23_ON_OFF = 0;
  @CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_ON_OFF = 0;
  @CAN_PrivMain::VFC_Oca_000_017::VFC_Oca_000_017_ON_OFF = 0;
  @CAN_PrivMain::VFC_Oca_018_035::VFC_Oca_018_035_ON_OFF = 0;
  @CAN_PrivMain::VFC_Oca_036_053::VFC_Oca_036_053_ON_OFF = 0;
  @CAN_PrivMain::VFC_Oca_054_071::VFC_Oca_054_071_ON_OFF = 0;
  @CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_ON_OFF = 0;
  @CAN_PrivMain::VFC_RoadClothoid_00_02::VFC_RoadClothoid_00_02_ON_OFF = 0;
  @CAN_PrivMain::VFC_RoadClothoid_03_05::VFC_RoadClothoid_03_05_ON_OFF = 0;
  @CAN_PrivMain::VFC_RoadClothoid_06_08::VFC_RoadClothoid_06_08_ON_OFF = 0;
  @CAN_PrivMain::VFC_RoadClothoid_09_11::VFC_RoadClothoid_09_11_ON_OFF = 0;
  @CAN_PrivMain::VFC_RoadPolynomial_00_02::VFC_RoadPolynomial_00_02_ON_OFF = 0;
  @CAN_PrivMain::VFC_RoadPolynomial_03_05::VFC_RoadPolynomial_03_05_ON_OFF = 0;
  @CAN_PrivMain::VFC_RoadPolynomial_06_08::VFC_RoadPolynomial_06_08_ON_OFF = 0;
  @CAN_PrivMain::VFC_RoadPolynomial_09_11::VFC_RoadPolynomial_09_11_ON_OFF = 0;
  @CAN_PrivMain::VFC_RoadPolynomial_12_14::VFC_RoadPolynomial_12_14_ON_OFF = 0;
  @CAN_PrivMain::VFC_Road2DPolynomial_00_02::VFC_Road2DPolynomial_00_02_ON_OFF = 0;
  @CAN_PrivMain::VFC_Road2DPolynomial_03_05::VFC_Road2DPolynomial_03_05_ON_OFF = 0;
  @CAN_PrivMain::VFC_Road2DPolynomial_06_08::VFC_Road2DPolynomial_06_08_ON_OFF = 0;
  @CAN_PrivMain::VFC_Road2DPolynomial_09_11::VFC_Road2DPolynomial_09_11_ON_OFF = 0;
  @CAN_PrivMain::VFC_Road2DPolynomial_12_14::VFC_Road2DPolynomial_12_14_ON_OFF = 0;
  @CAN_PrivMain::VFC_RoadMarking_00_06::VFC_RoadMarking_00_06_ON_OFF = 0;
  @CAN_PrivMain::VFC_TrafficLightHdr::VFC_TrafficLightHdr_ON_OFF = 0;
  @CAN_PrivMain::VFC_TrafficLight_00_04::VFC_TrafficLight_00_04_ON_OFF = 0;
  @CAN_PrivMain::VFC_TrafficLight_05_09::VFC_TrafficLight_05_09_ON_OFF = 0;
  @CAN_PrivMain::VFC_TrafficSignHdr::VFC_TrafficSignHdr_ON_OFF = 0;
  @CAN_PrivMain::VFC_TrafficSign_00_01::VFC_TrafficSign_00_01_ON_OFF = 0;
  @CAN_PrivMain::VFC_TrafficSign_02_03::VFC_TrafficSign_02_03_ON_OFF = 0;
  @CAN_PrivMain::VFC_TrafficSign_04_05::VFC_TrafficSign_04_05_ON_OFF = 0;
  @CAN_PrivMain::VFC_TrafficSign_06_07::VFC_TrafficSign_06_07_ON_OFF = 0;
  @CAN_PrivMain::VFC_TrafficSign_08_09::VFC_TrafficSign_08_09_ON_OFF = 0;
  @CAN_PrivMain::VFC_TrafficSign_10_11::VFC_TrafficSign_10_11_ON_OFF = 0;
  @CAN_PrivMain::VFC_TrafficSign_12_13::VFC_TrafficSign_12_13_ON_OFF = 0;
  @CAN_PrivMain::VFC_TrafficSign_14_15::VFC_TrafficSign_14_15_ON_OFF = 0;
}

void FVideo_sim_DisableMsg()
{
   ILFaultInjectionDisableMsg(VFC_AEB_Request);
   ILFaultInjectionDisableMsg(VFC_Status);
   ILFaultInjectionDisableMsg(VFC_ObjectHdr);
   ILFaultInjectionDisableMsg(VFC_Object00);
   ILFaultInjectionDisableMsg(VFC_Object01);
   ILFaultInjectionDisableMsg(VFC_Object02);
   ILFaultInjectionDisableMsg(VFC_Object03);
   ILFaultInjectionDisableMsg(VFC_Object04);
   ILFaultInjectionDisableMsg(VFC_Object05);
   ILFaultInjectionDisableMsg(VFC_Object06);
   ILFaultInjectionDisableMsg(VFC_Object07);
   ILFaultInjectionDisableMsg(VFC_Object08);
   ILFaultInjectionDisableMsg(VFC_Object09);
   ILFaultInjectionDisableMsg(VFC_Object10);
   ILFaultInjectionDisableMsg(VFC_Object11);
   ILFaultInjectionDisableMsg(VFC_Object12);
   ILFaultInjectionDisableMsg(VFC_Object13);
   ILFaultInjectionDisableMsg(VFC_Object14);
   ILFaultInjectionDisableMsg(VFC_Object15);
   ILFaultInjectionDisableMsg(VFC_Object16);
   ILFaultInjectionDisableMsg(VFC_Object17);
   ILFaultInjectionDisableMsg(VFC_Object18);
   ILFaultInjectionDisableMsg(VFC_Object19);
   ILFaultInjectionDisableMsg(VFC_Object20);
   ILFaultInjectionDisableMsg(VFC_Object21);
   ILFaultInjectionDisableMsg(VFC_Object22);
   ILFaultInjectionDisableMsg(VFC_Object23);
   ILFaultInjectionDisableMsg(VFC_OcaHdr);
   ILFaultInjectionDisableMsg(VFC_Oca_000_017);
   ILFaultInjectionDisableMsg(VFC_Oca_018_035);
   ILFaultInjectionDisableMsg(VFC_Oca_036_053);
   ILFaultInjectionDisableMsg(VFC_Oca_054_071);
   ILFaultInjectionDisableMsg(VFC_RoadHdr);
   ILFaultInjectionDisableMsg(VFC_RoadClothoid_00_02);
   ILFaultInjectionDisableMsg(VFC_RoadClothoid_03_05);
   ILFaultInjectionDisableMsg(VFC_RoadClothoid_06_08);
   ILFaultInjectionDisableMsg(VFC_RoadClothoid_09_11);
   ILFaultInjectionDisableMsg(Dev_Video_SyncVisor_TX);
   ILFaultInjectionDisableMsg(VFC_RoadPolynomial_00_02);
   ILFaultInjectionDisableMsg(VFC_RoadPolynomial_03_05);
   ILFaultInjectionDisableMsg(VFC_RoadPolynomial_06_08);
   ILFaultInjectionDisableMsg(VFC_RoadPolynomial_09_11);
   ILFaultInjectionDisableMsg(VFC_RoadPolynomial_12_14);
   ILFaultInjectionDisableMsg(VFC_Road2DPolynomial_00_02);
   ILFaultInjectionDisableMsg(VFC_Road2DPolynomial_03_05);
   ILFaultInjectionDisableMsg(VFC_Road2DPolynomial_06_08);
   ILFaultInjectionDisableMsg(VFC_Road2DPolynomial_09_11);
   ILFaultInjectionDisableMsg(VFC_Road2DPolynomial_12_14);
   ILFaultInjectionDisableMsg(VFC_RoadMarking_00_06);
   ILFaultInjectionDisableMsg(VFC_TrafficLightHdr);
   ILFaultInjectionDisableMsg(VFC_TrafficLight_00_04);
   ILFaultInjectionDisableMsg(VFC_TrafficLight_05_09);
   ILFaultInjectionDisableMsg(VFC_TrafficSignHdr);
   ILFaultInjectionDisableMsg(VFC_TrafficSign_00_01);
   ILFaultInjectionDisableMsg(VFC_TrafficSign_02_03);
   ILFaultInjectionDisableMsg(VFC_TrafficSign_04_05);
   ILFaultInjectionDisableMsg(VFC_TrafficSign_06_07);
   ILFaultInjectionDisableMsg(VFC_TrafficSign_08_09);
   ILFaultInjectionDisableMsg(VFC_TrafficSign_10_11);
   ILFaultInjectionDisableMsg(VFC_TrafficSign_12_13);
   ILFaultInjectionDisableMsg(VFC_TrafficSign_14_15);
}
on sysvar hil_ctrl::hil_mode
{
  FVideo_sim_Reset();
}

void FVideo_sim_DisableEventMsg()
{
   ILFaultInjectionDisableMsg(VFC_AEB_Request);
   ILFaultInjectionDisableMsg(VFC_Status);
   ILFaultInjectionDisableMsg(VFC_ObjectHdr);
   ILFaultInjectionDisableMsg(VFC_Object00);
   ILFaultInjectionDisableMsg(VFC_Object01);
   ILFaultInjectionDisableMsg(VFC_Object02);
   ILFaultInjectionDisableMsg(VFC_Object03);
   ILFaultInjectionDisableMsg(VFC_Object04);
   ILFaultInjectionDisableMsg(VFC_Object05);
   ILFaultInjectionDisableMsg(VFC_Object06);
   ILFaultInjectionDisableMsg(VFC_Object07);
   ILFaultInjectionDisableMsg(VFC_Object08);
   ILFaultInjectionDisableMsg(VFC_Object09);
   ILFaultInjectionDisableMsg(VFC_Object10);
   ILFaultInjectionDisableMsg(VFC_Object11);
   ILFaultInjectionDisableMsg(VFC_Object12);
   ILFaultInjectionDisableMsg(VFC_Object13);
   ILFaultInjectionDisableMsg(VFC_Object14);
   ILFaultInjectionDisableMsg(VFC_Object15);
   ILFaultInjectionDisableMsg(VFC_Object16);
   ILFaultInjectionDisableMsg(VFC_Object17);
   ILFaultInjectionDisableMsg(VFC_Object18);
   ILFaultInjectionDisableMsg(VFC_Object19);
   ILFaultInjectionDisableMsg(VFC_Object20);
   ILFaultInjectionDisableMsg(VFC_Object21);
   ILFaultInjectionDisableMsg(VFC_Object22);
   ILFaultInjectionDisableMsg(VFC_Object23);
   ILFaultInjectionDisableMsg(VFC_OcaHdr);
   ILFaultInjectionDisableMsg(VFC_Oca_000_017);
   ILFaultInjectionDisableMsg(VFC_Oca_018_035);
   ILFaultInjectionDisableMsg(VFC_Oca_036_053);
   ILFaultInjectionDisableMsg(VFC_Oca_054_071);
   ILFaultInjectionDisableMsg(VFC_RoadHdr);
   ILFaultInjectionDisableMsg(VFC_RoadClothoid_00_02);
   ILFaultInjectionDisableMsg(VFC_RoadClothoid_03_05);
   ILFaultInjectionDisableMsg(VFC_RoadClothoid_06_08);
   ILFaultInjectionDisableMsg(VFC_RoadClothoid_09_11);
   ILFaultInjectionDisableMsg(VFC_RoadPolynomial_00_02);
   ILFaultInjectionDisableMsg(VFC_RoadPolynomial_03_05);
   ILFaultInjectionDisableMsg(VFC_RoadPolynomial_06_08);
   ILFaultInjectionDisableMsg(VFC_RoadPolynomial_09_11);
   ILFaultInjectionDisableMsg(VFC_RoadPolynomial_12_14);
   ILFaultInjectionDisableMsg(VFC_Road2DPolynomial_00_02);
   ILFaultInjectionDisableMsg(VFC_Road2DPolynomial_03_05);
   ILFaultInjectionDisableMsg(VFC_Road2DPolynomial_06_08);
   ILFaultInjectionDisableMsg(VFC_Road2DPolynomial_09_11);
   ILFaultInjectionDisableMsg(VFC_Road2DPolynomial_12_14);
   ILFaultInjectionDisableMsg(VFC_RoadMarking_00_06);
   ILFaultInjectionDisableMsg(VFC_TrafficLightHdr);
   ILFaultInjectionDisableMsg(VFC_TrafficLight_00_04);
   ILFaultInjectionDisableMsg(VFC_TrafficLight_05_09);
   ILFaultInjectionDisableMsg(VFC_TrafficSignHdr);
   ILFaultInjectionDisableMsg(VFC_TrafficSign_00_01);
   ILFaultInjectionDisableMsg(VFC_TrafficSign_02_03);
   ILFaultInjectionDisableMsg(VFC_TrafficSign_04_05);
   ILFaultInjectionDisableMsg(VFC_TrafficSign_06_07);
   ILFaultInjectionDisableMsg(VFC_TrafficSign_08_09);
   ILFaultInjectionDisableMsg(VFC_TrafficSign_10_11);
   ILFaultInjectionDisableMsg(VFC_TrafficSign_12_13);
   ILFaultInjectionDisableMsg(VFC_TrafficSign_14_15);

}

void FVideo_sim_EnableEventMsg()
{
   ILFaultInjectionEnableMsg(VFC_AEB_Request);
   ILFaultInjectionEnableMsg(VFC_Status);
   ILFaultInjectionEnableMsg(VFC_ObjectHdr);
   ILFaultInjectionEnableMsg(VFC_Object00);
   ILFaultInjectionEnableMsg(VFC_Object01);
   ILFaultInjectionEnableMsg(VFC_Object02);
   ILFaultInjectionEnableMsg(VFC_Object03);
   ILFaultInjectionEnableMsg(VFC_Object04);
   ILFaultInjectionEnableMsg(VFC_Object05);
   ILFaultInjectionEnableMsg(VFC_Object06);
   ILFaultInjectionEnableMsg(VFC_Object07);
   ILFaultInjectionEnableMsg(VFC_Object08);
   ILFaultInjectionEnableMsg(VFC_Object09);
   ILFaultInjectionEnableMsg(VFC_Object10);
   ILFaultInjectionEnableMsg(VFC_Object11);
   ILFaultInjectionEnableMsg(VFC_Object12);
   ILFaultInjectionEnableMsg(VFC_Object13);
   ILFaultInjectionEnableMsg(VFC_Object14);
   ILFaultInjectionEnableMsg(VFC_Object15);
   ILFaultInjectionEnableMsg(VFC_Object16);
   ILFaultInjectionEnableMsg(VFC_Object17);
   ILFaultInjectionEnableMsg(VFC_Object18);
   ILFaultInjectionEnableMsg(VFC_Object19);
   ILFaultInjectionEnableMsg(VFC_Object20);
   ILFaultInjectionEnableMsg(VFC_Object21);
   ILFaultInjectionEnableMsg(VFC_Object22);
   ILFaultInjectionEnableMsg(VFC_Object23);
   ILFaultInjectionEnableMsg(VFC_OcaHdr);
   ILFaultInjectionEnableMsg(VFC_Oca_000_017);
   ILFaultInjectionEnableMsg(VFC_Oca_018_035);
   ILFaultInjectionEnableMsg(VFC_Oca_036_053);
   ILFaultInjectionEnableMsg(VFC_Oca_054_071);
   ILFaultInjectionEnableMsg(VFC_RoadHdr);
   ILFaultInjectionEnableMsg(VFC_RoadClothoid_00_02);
   ILFaultInjectionEnableMsg(VFC_RoadClothoid_03_05);
   ILFaultInjectionEnableMsg(VFC_RoadClothoid_06_08);
   ILFaultInjectionEnableMsg(VFC_RoadClothoid_09_11);
   ILFaultInjectionEnableMsg(VFC_RoadPolynomial_00_02);
   ILFaultInjectionEnableMsg(VFC_RoadPolynomial_03_05);
   ILFaultInjectionEnableMsg(VFC_RoadPolynomial_06_08);
   ILFaultInjectionEnableMsg(VFC_RoadPolynomial_09_11);
   ILFaultInjectionEnableMsg(VFC_RoadPolynomial_12_14);
   ILFaultInjectionEnableMsg(VFC_Road2DPolynomial_00_02);
   ILFaultInjectionEnableMsg(VFC_Road2DPolynomial_03_05);
   ILFaultInjectionEnableMsg(VFC_Road2DPolynomial_06_08);
   ILFaultInjectionEnableMsg(VFC_Road2DPolynomial_09_11);
   ILFaultInjectionEnableMsg(VFC_Road2DPolynomial_12_14);
   ILFaultInjectionEnableMsg(VFC_RoadMarking_00_06);
   ILFaultInjectionEnableMsg(VFC_TrafficLightHdr);
   ILFaultInjectionEnableMsg(VFC_TrafficLight_00_04);
   ILFaultInjectionEnableMsg(VFC_TrafficLight_05_09);
   ILFaultInjectionEnableMsg(VFC_TrafficSignHdr);
   ILFaultInjectionEnableMsg(VFC_TrafficSign_00_01);
   ILFaultInjectionEnableMsg(VFC_TrafficSign_02_03);
   ILFaultInjectionEnableMsg(VFC_TrafficSign_04_05);
   ILFaultInjectionEnableMsg(VFC_TrafficSign_06_07);
   ILFaultInjectionEnableMsg(VFC_TrafficSign_08_09);
   ILFaultInjectionEnableMsg(VFC_TrafficSign_10_11);
   ILFaultInjectionEnableMsg(VFC_TrafficSign_12_13);
   ILFaultInjectionEnableMsg(VFC_TrafficSign_14_15);

}
void FVideo_sim_SetCANParameter()
{
  //For future purpose
  //ILFaultInjectionSetMsgDlc(dbMsg msg, dword dlc)
  //ILFaultInjectionSetMsgLength(dbMsg msg, dword msgLength)
  //ILFaultInjectionResetMsgDlc(dbMsg msg)
  //ILFaultInjectionResetMsgLength (dbMsg msg)
}

void FVideo_sim_SetCANFDParameter()
{
   //CAN FD Parameter Setting
   int FDF =1;
   int BRS =1;
   ILSetCANFDParam(VFC_AEB_Request,FDF,BRS,VFC_AEB_Request.dlc);
   ILSetCANFDParam(VFC_Status,FDF,BRS,VFC_Status.dlc);
   ILSetCANFDParam(VFC_ObjectHdr,FDF,BRS,VFC_ObjectHdr.dlc);
   ILSetCANFDParam(VFC_Object00,FDF,BRS,VFC_Object00.dlc);
   ILSetCANFDParam(VFC_Object01,FDF,BRS,VFC_Object01.dlc);
   ILSetCANFDParam(VFC_Object02,FDF,BRS,VFC_Object02.dlc);
   ILSetCANFDParam(VFC_Object03,FDF,BRS,VFC_Object03.dlc);
   ILSetCANFDParam(VFC_Object04,FDF,BRS,VFC_Object04.dlc);
   ILSetCANFDParam(VFC_Object05,FDF,BRS,VFC_Object05.dlc);
   ILSetCANFDParam(VFC_Object06,FDF,BRS,VFC_Object06.dlc);
   ILSetCANFDParam(VFC_Object07,FDF,BRS,VFC_Object07.dlc);
   ILSetCANFDParam(VFC_Object08,FDF,BRS,VFC_Object08.dlc);
   ILSetCANFDParam(VFC_Object09,FDF,BRS,VFC_Object09.dlc);
   ILSetCANFDParam(VFC_Object10,FDF,BRS,VFC_Object10.dlc);
   ILSetCANFDParam(VFC_Object11,FDF,BRS,VFC_Object11.dlc);
   ILSetCANFDParam(VFC_Object12,FDF,BRS,VFC_Object12.dlc);
   ILSetCANFDParam(VFC_Object13,FDF,BRS,VFC_Object13.dlc);
   ILSetCANFDParam(VFC_Object14,FDF,BRS,VFC_Object14.dlc);
   ILSetCANFDParam(VFC_Object15,FDF,BRS,VFC_Object15.dlc);
   ILSetCANFDParam(VFC_Object16,FDF,BRS,VFC_Object16.dlc);
   ILSetCANFDParam(VFC_Object17,FDF,BRS,VFC_Object17.dlc);
   ILSetCANFDParam(VFC_Object18,FDF,BRS,VFC_Object18.dlc);
   ILSetCANFDParam(VFC_Object19,FDF,BRS,VFC_Object19.dlc);
   ILSetCANFDParam(VFC_Object20,FDF,BRS,VFC_Object20.dlc);
   ILSetCANFDParam(VFC_Object21,FDF,BRS,VFC_Object21.dlc);
   ILSetCANFDParam(VFC_Object22,FDF,BRS,VFC_Object22.dlc);
   ILSetCANFDParam(VFC_Object23,FDF,BRS,VFC_Object23.dlc);
   ILSetCANFDParam(VFC_OcaHdr,FDF,BRS,VFC_OcaHdr.dlc);
   ILSetCANFDParam(VFC_Oca_000_017,FDF,BRS,VFC_Oca_000_017.dlc);
   ILSetCANFDParam(VFC_Oca_018_035,FDF,BRS,VFC_Oca_018_035.dlc);
   ILSetCANFDParam(VFC_Oca_036_053,FDF,BRS,VFC_Oca_036_053.dlc);
   ILSetCANFDParam(VFC_Oca_054_071,FDF,BRS,VFC_Oca_054_071.dlc);
   ILSetCANFDParam(VFC_RoadHdr,FDF,BRS,VFC_RoadHdr.dlc);
   ILSetCANFDParam(VFC_RoadClothoid_00_02,FDF,BRS,VFC_RoadClothoid_00_02.dlc);
   ILSetCANFDParam(VFC_RoadClothoid_03_05,FDF,BRS,VFC_RoadClothoid_03_05.dlc);
   ILSetCANFDParam(VFC_RoadClothoid_06_08,FDF,BRS,VFC_RoadClothoid_06_08.dlc);
   ILSetCANFDParam(VFC_RoadClothoid_09_11,FDF,BRS,VFC_RoadClothoid_09_11.dlc);
   ILSetCANFDParam(VFC_RoadPolynomial_00_02,FDF,BRS,VFC_RoadPolynomial_00_02.dlc);
   ILSetCANFDParam(VFC_RoadPolynomial_03_05,FDF,BRS,VFC_RoadPolynomial_03_05.dlc);
   ILSetCANFDParam(VFC_RoadPolynomial_06_08,FDF,BRS,VFC_RoadPolynomial_06_08.dlc);
   ILSetCANFDParam(VFC_RoadPolynomial_09_11,FDF,BRS,VFC_RoadPolynomial_09_11.dlc);
   ILSetCANFDParam(VFC_RoadPolynomial_12_14,FDF,BRS,VFC_RoadPolynomial_12_14.dlc);
   ILSetCANFDParam(VFC_Road2DPolynomial_00_02,FDF,BRS,VFC_Road2DPolynomial_00_02.dlc);
   ILSetCANFDParam(VFC_Road2DPolynomial_03_05,FDF,BRS,VFC_Road2DPolynomial_03_05.dlc);
   ILSetCANFDParam(VFC_Road2DPolynomial_06_08,FDF,BRS,VFC_Road2DPolynomial_06_08.dlc);
   ILSetCANFDParam(VFC_Road2DPolynomial_09_11,FDF,BRS,VFC_Road2DPolynomial_09_11.dlc);
   ILSetCANFDParam(VFC_Road2DPolynomial_12_14,FDF,BRS,VFC_Road2DPolynomial_12_14.dlc);
   ILSetCANFDParam(VFC_RoadMarking_00_06,FDF,BRS,VFC_RoadMarking_00_06.dlc);
   ILSetCANFDParam(VFC_TrafficLightHdr,FDF,BRS,VFC_TrafficLightHdr.dlc);
   ILSetCANFDParam(VFC_TrafficLight_00_04,FDF,BRS,VFC_TrafficLight_00_04.dlc);
   ILSetCANFDParam(VFC_TrafficLight_05_09,FDF,BRS,VFC_TrafficLight_05_09.dlc);
   ILSetCANFDParam(VFC_TrafficSignHdr,FDF,BRS,VFC_TrafficSignHdr.dlc);
   ILSetCANFDParam(VFC_TrafficSign_00_01,FDF,BRS,VFC_TrafficSign_00_01.dlc);
   ILSetCANFDParam(VFC_TrafficSign_02_03,FDF,BRS,VFC_TrafficSign_02_03.dlc);
   ILSetCANFDParam(VFC_TrafficSign_04_05,FDF,BRS,VFC_TrafficSign_04_05.dlc);
   ILSetCANFDParam(VFC_TrafficSign_06_07,FDF,BRS,VFC_TrafficSign_06_07.dlc);
   ILSetCANFDParam(VFC_TrafficSign_08_09,FDF,BRS,VFC_TrafficSign_08_09.dlc);
   ILSetCANFDParam(VFC_TrafficSign_10_11,FDF,BRS,VFC_TrafficSign_10_11.dlc);
   ILSetCANFDParam(VFC_TrafficSign_12_13,FDF,BRS,VFC_TrafficSign_12_13.dlc);
   ILSetCANFDParam(VFC_TrafficSign_14_15,FDF,BRS,VFC_TrafficSign_14_15.dlc);
}

dword applILTxPending (long aId, dword aDlc, byte data[])//This callback is being called before the IL sends a message to the bus
{
  switch(aId)
  {
    case VFC_AEB_Request.id:cfg_Msg_VFC_AEB_Request(aDlc, data);break;
    case VFC_Status.id:cfg_Msg_VFC_Status(aDlc, data);break;
    case VFC_ObjectHdr.id:cfg_Msg_VFC_ObjectHdr(aDlc, data);break;
    case VFC_Object00.id:cfg_Msg_VFC_Object00(aDlc, data);break;
    case VFC_Object01.id:cfg_Msg_VFC_Object01(aDlc, data);break;
    case VFC_Object02.id:cfg_Msg_VFC_Object02(aDlc, data);break;
    case VFC_Object03.id:cfg_Msg_VFC_Object03(aDlc, data);break;
    case VFC_Object04.id:cfg_Msg_VFC_Object04(aDlc, data);break;
    case VFC_Object05.id:cfg_Msg_VFC_Object05(aDlc, data);break;
    case VFC_Object06.id:cfg_Msg_VFC_Object06(aDlc, data);break;
    case VFC_Object07.id:cfg_Msg_VFC_Object07(aDlc, data);break;
    case VFC_Object08.id:cfg_Msg_VFC_Object08(aDlc, data);break;
    case VFC_Object09.id:cfg_Msg_VFC_Object09(aDlc, data);break;
    case VFC_Object10.id:cfg_Msg_VFC_Object10(aDlc, data);break;
    case VFC_Object11.id:cfg_Msg_VFC_Object11(aDlc, data);break;
    case VFC_Object12.id:cfg_Msg_VFC_Object12(aDlc, data);break;
    case VFC_Object13.id:cfg_Msg_VFC_Object13(aDlc, data);break;
    case VFC_Object14.id:cfg_Msg_VFC_Object14(aDlc, data);break;
    case VFC_Object15.id:cfg_Msg_VFC_Object15(aDlc, data);break;
    case VFC_Object16.id:cfg_Msg_VFC_Object16(aDlc, data);break;
    case VFC_Object17.id:cfg_Msg_VFC_Object17(aDlc, data);break;
    case VFC_Object18.id:cfg_Msg_VFC_Object18(aDlc, data);break;
    case VFC_Object19.id:cfg_Msg_VFC_Object19(aDlc, data);break;
    case VFC_Object20.id:cfg_Msg_VFC_Object20(aDlc, data);break;
    case VFC_Object21.id:cfg_Msg_VFC_Object21(aDlc, data);break;
    case VFC_Object22.id:cfg_Msg_VFC_Object22(aDlc, data);break;
    case VFC_Object23.id:cfg_Msg_VFC_Object23(aDlc, data);break;
    case VFC_OcaHdr.id:cfg_Msg_VFC_OcaHdr(aDlc, data);break;
    case VFC_Oca_000_017.id:cfg_Msg_VFC_Oca_000_017(aDlc, data);break;
    case VFC_Oca_018_035.id:cfg_Msg_VFC_Oca_018_035(aDlc, data);break;
    case VFC_Oca_036_053.id:cfg_Msg_VFC_Oca_036_053(aDlc, data);break;
    case VFC_Oca_054_071.id:cfg_Msg_VFC_Oca_054_071(aDlc, data);break;
    case VFC_RoadHdr.id:cfg_Msg_VFC_RoadHdr(aDlc, data);break;
    case VFC_RoadClothoid_00_02.id:cfg_Msg_VFC_RoadClothoid_00_02(aDlc, data);break;
    case VFC_RoadClothoid_03_05.id:cfg_Msg_VFC_RoadClothoid_03_05(aDlc, data);break;
    case VFC_RoadClothoid_06_08.id:cfg_Msg_VFC_RoadClothoid_06_08(aDlc, data);break;
    case VFC_RoadClothoid_09_11.id:cfg_Msg_VFC_RoadClothoid_09_11(aDlc, data);break;
    case VFC_RoadPolynomial_00_02.id:cfg_Msg_VFC_RoadPolynomial_00_02(aDlc, data);break;
    case VFC_RoadPolynomial_03_05.id:cfg_Msg_VFC_RoadPolynomial_03_05(aDlc, data);break;
    case VFC_RoadPolynomial_06_08.id:cfg_Msg_VFC_RoadPolynomial_06_08(aDlc, data);break;
    case VFC_RoadPolynomial_09_11.id:cfg_Msg_VFC_RoadPolynomial_09_11(aDlc, data);break;
    case VFC_RoadPolynomial_12_14.id:cfg_Msg_VFC_RoadPolynomial_12_14(aDlc, data);break;
    case VFC_Road2DPolynomial_00_02.id:cfg_Msg_VFC_Road2DPolynomial_00_02(aDlc, data);break;
    case VFC_Road2DPolynomial_03_05.id:cfg_Msg_VFC_Road2DPolynomial_03_05(aDlc, data);break;
    case VFC_Road2DPolynomial_06_08.id:cfg_Msg_VFC_Road2DPolynomial_06_08(aDlc, data);break;
    case VFC_Road2DPolynomial_09_11.id:cfg_Msg_VFC_Road2DPolynomial_09_11(aDlc, data);break;
    case VFC_Road2DPolynomial_12_14.id:cfg_Msg_VFC_Road2DPolynomial_12_14(aDlc, data);break;
    case VFC_RoadMarking_00_06.id:cfg_Msg_VFC_RoadMarking_00_06(aDlc, data);break;
    case VFC_TrafficLightHdr.id:cfg_Msg_VFC_TrafficLightHdr(aDlc, data);break;
    case VFC_TrafficLight_00_04.id:cfg_Msg_VFC_TrafficLight_00_04(aDlc, data);break;
    case VFC_TrafficLight_05_09.id:cfg_Msg_VFC_TrafficLight_05_09(aDlc, data);break;
    case VFC_TrafficSignHdr.id:cfg_Msg_VFC_TrafficSignHdr(aDlc, data);break;
    case VFC_TrafficSign_00_01.id:cfg_Msg_VFC_TrafficSign_00_01(aDlc, data);break;
    case VFC_TrafficSign_02_03.id:cfg_Msg_VFC_TrafficSign_02_03(aDlc, data);break;
    case VFC_TrafficSign_04_05.id:cfg_Msg_VFC_TrafficSign_04_05(aDlc, data);break;
    case VFC_TrafficSign_06_07.id:cfg_Msg_VFC_TrafficSign_06_07(aDlc, data);break;
    case VFC_TrafficSign_08_09.id:cfg_Msg_VFC_TrafficSign_08_09(aDlc, data);break;
    case VFC_TrafficSign_10_11.id:cfg_Msg_VFC_TrafficSign_10_11(aDlc, data);break;
    case VFC_TrafficSign_12_13.id:cfg_Msg_VFC_TrafficSign_12_13(aDlc, data);break;
    case VFC_TrafficSign_14_15.id:cfg_Msg_VFC_TrafficSign_14_15(aDlc, data);break;
    default :;//write("Node:FVideo ::No Cyclic event");
           break;
  }
  return 1; // don't prevent sending of the message
}

on sysvar CAN_PrivMain::VFC_AEB_Request::VFC_AEB_Request_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_AEB_Request);
     @CAN_PrivMain::VFC_AEB_Request::VFC_AEB_Request_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_AEB_Request(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_AEB_Request.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_AEB_Request.id;//Message ID
   
    if (@CAN_PrivMain::VFC_AEB_Request::VFC_AEB_AC_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_AEB_Request::VFC_AEB_AC_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_AEB_Request_VFC_AEB_AC;
      counter_VFC_AEB_Request_VFC_AEB_AC %=16;

      copyBitsToByteArrayLE(counter_VFC_AEB_Request_VFC_AEB_AC,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_AEB_Request::VFC_AEB_AC_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_AEB_Request::VFC_AEB_AC_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_AEB_Request_VFC_AEB_AC,data,8,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_AEB_Request::VFC_AEB_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_AEB_Request::VFC_AEB_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup_PRIVATE(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      crc_VFC_AEB_Request_VFC_AEB_CRC = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(crc_VFC_AEB_Request_VFC_AEB_CRC,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_AEB_Request::VFC_AEB_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_AEB_Request::VFC_AEB_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_AEB_Request_VFC_AEB_CRC,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object00::VFC_Object00_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object00);
     @CAN_PrivMain::VFC_Object00::VFC_Object00_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object00(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object00.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object00.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object00::VFC_Obj00_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object00::VFC_Obj00_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object00_VFC_Obj00_AliveCtr;
      counter_VFC_Object00_VFC_Obj00_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object00_VFC_Obj00_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object00::VFC_Obj00_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object00::VFC_Obj00_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object00_VFC_Obj00_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object00::VFC_Obj00_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object00::VFC_Obj00_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object00_VFC_Obj00_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object00_VFC_Obj00_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object00::VFC_Obj00_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object00::VFC_Obj00_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object00_VFC_Obj00_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object00::VFC_Obj00_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object00::VFC_Obj00_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2036 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2036 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object00_VFC_Obj00_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object00_VFC_Obj00_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object00::VFC_Obj00_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object00::VFC_Obj00_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object00_VFC_Obj00_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object01::VFC_Object01_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object01);
     @CAN_PrivMain::VFC_Object01::VFC_Object01_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object01(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object01.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object01.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object01::VFC_Obj01_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object01::VFC_Obj01_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object01_VFC_Obj01_AliveCtr;
      counter_VFC_Object01_VFC_Obj01_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object01_VFC_Obj01_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object01::VFC_Obj01_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object01::VFC_Obj01_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object01_VFC_Obj01_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object01::VFC_Obj01_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object01::VFC_Obj01_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object01_VFC_Obj01_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object01_VFC_Obj01_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object01::VFC_Obj01_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object01::VFC_Obj01_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object01_VFC_Obj01_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object01::VFC_Obj01_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object01::VFC_Obj01_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2037 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2037 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object01_VFC_Obj01_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object01_VFC_Obj01_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object01::VFC_Obj01_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object01::VFC_Obj01_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object01_VFC_Obj01_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object02::VFC_Object02_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object02);
     @CAN_PrivMain::VFC_Object02::VFC_Object02_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object02(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object02.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object02.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object02::VFC_Obj02_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object02::VFC_Obj02_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object02_VFC_Obj02_AliveCtr;
      counter_VFC_Object02_VFC_Obj02_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object02_VFC_Obj02_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object02::VFC_Obj02_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object02::VFC_Obj02_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object02_VFC_Obj02_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object02::VFC_Obj02_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object02::VFC_Obj02_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object02_VFC_Obj02_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object02_VFC_Obj02_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object02::VFC_Obj02_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object02::VFC_Obj02_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object02_VFC_Obj02_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object02::VFC_Obj02_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object02::VFC_Obj02_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2038 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2038 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object02_VFC_Obj02_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object02_VFC_Obj02_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object02::VFC_Obj02_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object02::VFC_Obj02_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object02_VFC_Obj02_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object03::VFC_Object03_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object03);
     @CAN_PrivMain::VFC_Object03::VFC_Object03_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object03(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object03.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object03.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object03::VFC_Obj03_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object03::VFC_Obj03_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object03_VFC_Obj03_AliveCtr;
      counter_VFC_Object03_VFC_Obj03_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object03_VFC_Obj03_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object03::VFC_Obj03_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object03::VFC_Obj03_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object03_VFC_Obj03_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object03::VFC_Obj03_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object03::VFC_Obj03_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object03_VFC_Obj03_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object03_VFC_Obj03_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object03::VFC_Obj03_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object03::VFC_Obj03_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object03_VFC_Obj03_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object03::VFC_Obj03_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object03::VFC_Obj03_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2039 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2039 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object03_VFC_Obj03_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object03_VFC_Obj03_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object03::VFC_Obj03_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object03::VFC_Obj03_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object03_VFC_Obj03_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object04::VFC_Object04_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object04);
     @CAN_PrivMain::VFC_Object04::VFC_Object04_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object04(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object04.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object04.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object04::VFC_Obj04_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object04::VFC_Obj04_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object04_VFC_Obj04_AliveCtr;
      counter_VFC_Object04_VFC_Obj04_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object04_VFC_Obj04_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object04::VFC_Obj04_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object04::VFC_Obj04_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object04_VFC_Obj04_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object04::VFC_Obj04_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object04::VFC_Obj04_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object04_VFC_Obj04_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object04_VFC_Obj04_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object04::VFC_Obj04_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object04::VFC_Obj04_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object04_VFC_Obj04_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object04::VFC_Obj04_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object04::VFC_Obj04_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x203a & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x203a & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object04_VFC_Obj04_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object04_VFC_Obj04_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object04::VFC_Obj04_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object04::VFC_Obj04_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object04_VFC_Obj04_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object05::VFC_Object05_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object05);
     @CAN_PrivMain::VFC_Object05::VFC_Object05_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object05(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object05.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object05.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object05::VFC_Obj05_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object05::VFC_Obj05_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object05_VFC_Obj05_AliveCtr;
      counter_VFC_Object05_VFC_Obj05_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object05_VFC_Obj05_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object05::VFC_Obj05_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object05::VFC_Obj05_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object05_VFC_Obj05_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object05::VFC_Obj05_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object05::VFC_Obj05_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object05_VFC_Obj05_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object05_VFC_Obj05_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object05::VFC_Obj05_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object05::VFC_Obj05_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object05_VFC_Obj05_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object05::VFC_Obj05_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object05::VFC_Obj05_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x203b & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x203b & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object05_VFC_Obj05_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object05_VFC_Obj05_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object05::VFC_Obj05_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object05::VFC_Obj05_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object05_VFC_Obj05_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object06::VFC_Object06_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object06);
     @CAN_PrivMain::VFC_Object06::VFC_Object06_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object06(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object06.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object06.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object06::VFC_Obj06_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object06::VFC_Obj06_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object06_VFC_Obj06_AliveCtr;
      counter_VFC_Object06_VFC_Obj06_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object06_VFC_Obj06_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object06::VFC_Obj06_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object06::VFC_Obj06_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object06_VFC_Obj06_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object06::VFC_Obj06_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object06::VFC_Obj06_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object06_VFC_Obj06_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object06_VFC_Obj06_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object06::VFC_Obj06_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object06::VFC_Obj06_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object06_VFC_Obj06_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object06::VFC_Obj06_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object06::VFC_Obj06_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x203c & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x203c & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object06_VFC_Obj06_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object06_VFC_Obj06_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object06::VFC_Obj06_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object06::VFC_Obj06_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object06_VFC_Obj06_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object07::VFC_Object07_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object07);
     @CAN_PrivMain::VFC_Object07::VFC_Object07_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object07(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object07.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object07.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object07::VFC_Obj07_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object07::VFC_Obj07_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object07_VFC_Obj07_AliveCtr;
      counter_VFC_Object07_VFC_Obj07_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object07_VFC_Obj07_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object07::VFC_Obj07_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object07::VFC_Obj07_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object07_VFC_Obj07_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object07::VFC_Obj07_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object07::VFC_Obj07_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object07_VFC_Obj07_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object07_VFC_Obj07_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object07::VFC_Obj07_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object07::VFC_Obj07_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object07_VFC_Obj07_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object07::VFC_Obj07_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object07::VFC_Obj07_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x203d & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x203d & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object07_VFC_Obj07_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object07_VFC_Obj07_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object07::VFC_Obj07_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object07::VFC_Obj07_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object07_VFC_Obj07_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object08::VFC_Object08_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object08);
     @CAN_PrivMain::VFC_Object08::VFC_Object08_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object08(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object08.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object08.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object08::VFC_Obj08_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object08::VFC_Obj08_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object08_VFC_Obj08_AliveCtr;
      counter_VFC_Object08_VFC_Obj08_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object08_VFC_Obj08_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object08::VFC_Obj08_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object08::VFC_Obj08_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object08_VFC_Obj08_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object08::VFC_Obj08_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object08::VFC_Obj08_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object08_VFC_Obj08_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object08_VFC_Obj08_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object08::VFC_Obj08_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object08::VFC_Obj08_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object08_VFC_Obj08_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object08::VFC_Obj08_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object08::VFC_Obj08_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x203e & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x203e & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object08_VFC_Obj08_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object08_VFC_Obj08_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object08::VFC_Obj08_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object08::VFC_Obj08_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object08_VFC_Obj08_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object09::VFC_Object09_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object09);
     @CAN_PrivMain::VFC_Object09::VFC_Object09_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object09(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object09.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object09.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object09::VFC_Obj09_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object09::VFC_Obj09_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object09_VFC_Obj09_AliveCtr;
      counter_VFC_Object09_VFC_Obj09_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object09_VFC_Obj09_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object09::VFC_Obj09_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object09::VFC_Obj09_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object09_VFC_Obj09_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object09::VFC_Obj09_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object09::VFC_Obj09_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object09_VFC_Obj09_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object09_VFC_Obj09_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object09::VFC_Obj09_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object09::VFC_Obj09_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object09_VFC_Obj09_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object09::VFC_Obj09_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object09::VFC_Obj09_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x203f & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x203f & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object09_VFC_Obj09_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object09_VFC_Obj09_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object09::VFC_Obj09_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object09::VFC_Obj09_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object09_VFC_Obj09_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object10::VFC_Object10_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object10);
     @CAN_PrivMain::VFC_Object10::VFC_Object10_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object10(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object10.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object10.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object10::VFC_Obj10_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object10::VFC_Obj10_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object10_VFC_Obj10_AliveCtr;
      counter_VFC_Object10_VFC_Obj10_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object10_VFC_Obj10_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object10::VFC_Obj10_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object10::VFC_Obj10_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object10_VFC_Obj10_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object10::VFC_Obj10_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object10::VFC_Obj10_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object10_VFC_Obj10_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object10_VFC_Obj10_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object10::VFC_Obj10_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object10::VFC_Obj10_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object10_VFC_Obj10_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object10::VFC_Obj10_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object10::VFC_Obj10_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2040 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2040 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object10_VFC_Obj10_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object10_VFC_Obj10_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object10::VFC_Obj10_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object10::VFC_Obj10_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object10_VFC_Obj10_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object11::VFC_Object11_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object11);
     @CAN_PrivMain::VFC_Object11::VFC_Object11_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object11(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object11.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object11.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object11::VFC_Obj11_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object11::VFC_Obj11_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object11_VFC_Obj11_AliveCtr;
      counter_VFC_Object11_VFC_Obj11_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object11_VFC_Obj11_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object11::VFC_Obj11_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object11::VFC_Obj11_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object11_VFC_Obj11_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object11::VFC_Obj11_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object11::VFC_Obj11_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object11_VFC_Obj11_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object11_VFC_Obj11_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object11::VFC_Obj11_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object11::VFC_Obj11_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object11_VFC_Obj11_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object11::VFC_Obj11_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object11::VFC_Obj11_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2041 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2041 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object11_VFC_Obj11_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object11_VFC_Obj11_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object11::VFC_Obj11_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object11::VFC_Obj11_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object11_VFC_Obj11_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object12::VFC_Object12_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object12);
     @CAN_PrivMain::VFC_Object12::VFC_Object12_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object12(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object12.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object12.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object12::VFC_Obj12_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object12::VFC_Obj12_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object12_VFC_Obj12_AliveCtr;
      counter_VFC_Object12_VFC_Obj12_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object12_VFC_Obj12_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object12::VFC_Obj12_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object12::VFC_Obj12_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object12_VFC_Obj12_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object12::VFC_Obj12_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object12::VFC_Obj12_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object12_VFC_Obj12_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object12_VFC_Obj12_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object12::VFC_Obj12_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object12::VFC_Obj12_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object12_VFC_Obj12_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object12::VFC_Obj12_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object12::VFC_Obj12_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2042 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2042 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object12_VFC_Obj12_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object12_VFC_Obj12_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object12::VFC_Obj12_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object12::VFC_Obj12_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object12_VFC_Obj12_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object13::VFC_Object13_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object13);
     @CAN_PrivMain::VFC_Object13::VFC_Object13_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object13(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object13.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object13.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object13::VFC_Obj13_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object13::VFC_Obj13_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object13_VFC_Obj13_AliveCtr;
      counter_VFC_Object13_VFC_Obj13_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object13_VFC_Obj13_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object13::VFC_Obj13_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object13::VFC_Obj13_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object13_VFC_Obj13_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object13::VFC_Obj13_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object13::VFC_Obj13_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object13_VFC_Obj13_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object13_VFC_Obj13_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object13::VFC_Obj13_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object13::VFC_Obj13_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object13_VFC_Obj13_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object13::VFC_Obj13_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object13::VFC_Obj13_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2043 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2043 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object13_VFC_Obj13_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object13_VFC_Obj13_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object13::VFC_Obj13_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object13::VFC_Obj13_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object13_VFC_Obj13_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object14::VFC_Object14_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object14);
     @CAN_PrivMain::VFC_Object14::VFC_Object14_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object14(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object14.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object14.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object14::VFC_Obj14_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object14::VFC_Obj14_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object14_VFC_Obj14_AliveCtr;
      counter_VFC_Object14_VFC_Obj14_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object14_VFC_Obj14_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object14::VFC_Obj14_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object14::VFC_Obj14_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object14_VFC_Obj14_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object14::VFC_Obj14_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object14::VFC_Obj14_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object14_VFC_Obj14_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object14_VFC_Obj14_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object14::VFC_Obj14_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object14::VFC_Obj14_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object14_VFC_Obj14_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object14::VFC_Obj14_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object14::VFC_Obj14_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2044 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2044 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object14_VFC_Obj14_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object14_VFC_Obj14_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object14::VFC_Obj14_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object14::VFC_Obj14_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object14_VFC_Obj14_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object15::VFC_Object15_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object15);
     @CAN_PrivMain::VFC_Object15::VFC_Object15_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object15(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object15.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object15.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object15::VFC_Obj15_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object15::VFC_Obj15_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object15_VFC_Obj15_AliveCtr;
      counter_VFC_Object15_VFC_Obj15_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object15_VFC_Obj15_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object15::VFC_Obj15_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object15::VFC_Obj15_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object15_VFC_Obj15_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object15::VFC_Obj15_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object15::VFC_Obj15_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object15_VFC_Obj15_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object15_VFC_Obj15_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object15::VFC_Obj15_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object15::VFC_Obj15_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object15_VFC_Obj15_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object15::VFC_Obj15_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object15::VFC_Obj15_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2045 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2045 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object15_VFC_Obj15_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object15_VFC_Obj15_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object15::VFC_Obj15_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object15::VFC_Obj15_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object15_VFC_Obj15_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object16::VFC_Object16_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object16);
     @CAN_PrivMain::VFC_Object16::VFC_Object16_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object16(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object16.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object16.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object16::VFC_Obj16_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object16::VFC_Obj16_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object16_VFC_Obj16_AliveCtr;
      counter_VFC_Object16_VFC_Obj16_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object16_VFC_Obj16_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object16::VFC_Obj16_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object16::VFC_Obj16_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object16_VFC_Obj16_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object16::VFC_Obj16_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object16::VFC_Obj16_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object16_VFC_Obj16_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object16_VFC_Obj16_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object16::VFC_Obj16_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object16::VFC_Obj16_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object16_VFC_Obj16_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object16::VFC_Obj16_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object16::VFC_Obj16_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2046 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2046 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object16_VFC_Obj16_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object16_VFC_Obj16_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object16::VFC_Obj16_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object16::VFC_Obj16_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object16_VFC_Obj16_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object17::VFC_Object17_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object17);
     @CAN_PrivMain::VFC_Object17::VFC_Object17_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object17(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object17.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object17.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object17::VFC_Obj17_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object17::VFC_Obj17_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object17_VFC_Obj17_AliveCtr;
      counter_VFC_Object17_VFC_Obj17_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object17_VFC_Obj17_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object17::VFC_Obj17_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object17::VFC_Obj17_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object17_VFC_Obj17_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object17::VFC_Obj17_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object17::VFC_Obj17_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object17_VFC_Obj17_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object17_VFC_Obj17_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object17::VFC_Obj17_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object17::VFC_Obj17_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object17_VFC_Obj17_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object17::VFC_Obj17_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object17::VFC_Obj17_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2047 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2047 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object17_VFC_Obj17_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object17_VFC_Obj17_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object17::VFC_Obj17_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object17::VFC_Obj17_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object17_VFC_Obj17_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object18::VFC_Object18_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object18);
     @CAN_PrivMain::VFC_Object18::VFC_Object18_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object18(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object18.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object18.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object18::VFC_Obj18_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object18::VFC_Obj18_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object18_VFC_Obj18_AliveCtr;
      counter_VFC_Object18_VFC_Obj18_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object18_VFC_Obj18_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object18::VFC_Obj18_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object18::VFC_Obj18_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object18_VFC_Obj18_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object18::VFC_Obj18_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object18::VFC_Obj18_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object18_VFC_Obj18_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object18_VFC_Obj18_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object18::VFC_Obj18_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object18::VFC_Obj18_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object18_VFC_Obj18_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object18::VFC_Obj18_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object18::VFC_Obj18_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2048 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2048 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object18_VFC_Obj18_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object18_VFC_Obj18_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object18::VFC_Obj18_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object18::VFC_Obj18_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object18_VFC_Obj18_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object19::VFC_Object19_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object19);
     @CAN_PrivMain::VFC_Object19::VFC_Object19_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object19(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object19.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object19.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object19::VFC_Obj19_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object19::VFC_Obj19_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object19_VFC_Obj19_AliveCtr;
      counter_VFC_Object19_VFC_Obj19_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object19_VFC_Obj19_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object19::VFC_Obj19_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object19::VFC_Obj19_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object19_VFC_Obj19_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object19::VFC_Obj19_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object19::VFC_Obj19_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object19_VFC_Obj19_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object19_VFC_Obj19_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object19::VFC_Obj19_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object19::VFC_Obj19_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object19_VFC_Obj19_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object19::VFC_Obj19_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object19::VFC_Obj19_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2049 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2049 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object19_VFC_Obj19_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object19_VFC_Obj19_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object19::VFC_Obj19_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object19::VFC_Obj19_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object19_VFC_Obj19_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object20::VFC_Object20_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object20);
     @CAN_PrivMain::VFC_Object20::VFC_Object20_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object20(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object20.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object20.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object20::VFC_Obj20_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object20::VFC_Obj20_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object20_VFC_Obj20_AliveCtr;
      counter_VFC_Object20_VFC_Obj20_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object20_VFC_Obj20_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object20::VFC_Obj20_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object20::VFC_Obj20_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object20_VFC_Obj20_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object20::VFC_Obj20_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object20::VFC_Obj20_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object20_VFC_Obj20_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object20_VFC_Obj20_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object20::VFC_Obj20_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object20::VFC_Obj20_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object20_VFC_Obj20_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object20::VFC_Obj20_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object20::VFC_Obj20_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x204a & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x204a & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object20_VFC_Obj20_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object20_VFC_Obj20_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object20::VFC_Obj20_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object20::VFC_Obj20_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object20_VFC_Obj20_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object21::VFC_Object21_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object21);
     @CAN_PrivMain::VFC_Object21::VFC_Object21_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object21(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object21.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object21.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object21::VFC_Obj21_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object21::VFC_Obj21_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object21_VFC_Obj21_AliveCtr;
      counter_VFC_Object21_VFC_Obj21_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object21_VFC_Obj21_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object21::VFC_Obj21_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object21::VFC_Obj21_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object21_VFC_Obj21_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object21::VFC_Obj21_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object21::VFC_Obj21_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object21_VFC_Obj21_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object21_VFC_Obj21_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object21::VFC_Obj21_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object21::VFC_Obj21_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object21_VFC_Obj21_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object21::VFC_Obj21_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object21::VFC_Obj21_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x204b & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x204b & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object21_VFC_Obj21_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object21_VFC_Obj21_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object21::VFC_Obj21_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object21::VFC_Obj21_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object21_VFC_Obj21_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object22::VFC_Object22_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object22);
     @CAN_PrivMain::VFC_Object22::VFC_Object22_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object22(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object22.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object22.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object22::VFC_Obj22_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object22::VFC_Obj22_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object22_VFC_Obj22_AliveCtr;
      counter_VFC_Object22_VFC_Obj22_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object22_VFC_Obj22_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object22::VFC_Obj22_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object22::VFC_Obj22_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object22_VFC_Obj22_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object22::VFC_Obj22_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object22::VFC_Obj22_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object22_VFC_Obj22_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object22_VFC_Obj22_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object22::VFC_Obj22_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object22::VFC_Obj22_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object22_VFC_Obj22_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object22::VFC_Obj22_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object22::VFC_Obj22_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x204c & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x204c & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object22_VFC_Obj22_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object22_VFC_Obj22_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object22::VFC_Obj22_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object22::VFC_Obj22_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object22_VFC_Obj22_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Object23::VFC_Object23_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Object23);
     @CAN_PrivMain::VFC_Object23::VFC_Object23_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Object23(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Object23.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Object23.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Object23::VFC_Obj23_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object23::VFC_Obj23_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Object23_VFC_Obj23_AliveCtr;
      counter_VFC_Object23_VFC_Obj23_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Object23_VFC_Obj23_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object23::VFC_Obj23_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object23::VFC_Obj23_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Object23_VFC_Obj23_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object23::VFC_Obj23_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Object23::VFC_Obj23_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Object23_VFC_Obj23_ProtBlockCtr = bc_VFC_Object_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Object23_VFC_Obj23_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object23::VFC_Obj23_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Object23::VFC_Obj23_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Object23_VFC_Obj23_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Object23::VFC_Obj23_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Object23::VFC_Obj23_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x204d & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x204d & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Object23_VFC_Obj23_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Object23_VFC_Obj23_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object23::VFC_Obj23_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Object23::VFC_Obj23_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Object23_VFC_Obj23_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_ObjectHdr::VFC_ObjectHdr_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_ObjectHdr);
     @CAN_PrivMain::VFC_ObjectHdr::VFC_ObjectHdr_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_ObjectHdr(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_ObjectHdr.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_ObjectHdr.id;//Message ID
   
    if (@CAN_PrivMain::VFC_ObjectHdr::VFC_ObjHdr_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_ObjectHdr::VFC_ObjHdr_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_ObjectHdr_VFC_ObjHdr_AliveCtr;
      counter_VFC_ObjectHdr_VFC_ObjHdr_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_ObjectHdr_VFC_ObjHdr_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_ObjectHdr::VFC_ObjHdr_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_ObjectHdr::VFC_ObjHdr_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_ObjectHdr_VFC_ObjHdr_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_ObjectHdr::VFC_ObjHdr_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_ObjectHdr::VFC_ObjHdr_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      ++bc_VFC_ObjectHdr_VFC_ObjHdr_ProtBlockCtr;
      bc_VFC_ObjectHdr_VFC_ObjHdr_ProtBlockCtr %=16;
      bc_VFC_Object_ProtBlockCtr = bc_VFC_ObjectHdr_VFC_ObjHdr_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_ObjectHdr_VFC_ObjHdr_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_ObjectHdr::VFC_ObjHdr_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_ObjectHdr::VFC_ObjHdr_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_ObjectHdr_VFC_ObjHdr_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }

    clearBitsInByteArrayLE(data,64,26); //Intel / little-endian

    //Msg_VFC_ObjectHdr.VFC_ObjHdr_TimeStamp = @CAN_PrivMain::VFC_ObjectHdr::VFC_ObjHdr_TimeStamp_FaultInject +(timeNowNS()/1000000);

      copyBitsToByteArrayLE(@CAN_PrivMain::VFC_ObjectHdr::VFC_ObjHdr_TimeStamp_FaultInject +(timeNowNS()/1000000),data,64,26); //Intel / little-endian;
    if (@CAN_PrivMain::VFC_ObjectHdr::VFC_ObjHdr_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_ObjectHdr::VFC_ObjHdr_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2034 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2034 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_ObjectHdr_VFC_ObjHdr_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_ObjectHdr_VFC_ObjHdr_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_ObjectHdr::VFC_ObjHdr_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_ObjectHdr::VFC_ObjHdr_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_ObjectHdr_VFC_ObjHdr_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_OcaHdr);
     @CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_OcaHdr(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_OcaHdr.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_OcaHdr.id;//Message ID
   
    if (@CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_OcaHdr_VFC_OcaHdr_AliveCtr;
      counter_VFC_OcaHdr_VFC_OcaHdr_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_OcaHdr_VFC_OcaHdr_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_OcaHdr_VFC_OcaHdr_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      ++bc_VFC_OcaHdr_VFC_OcaHdr_ProtBlockCtr;
      bc_VFC_OcaHdr_VFC_OcaHdr_ProtBlockCtr %=16;
      bc_None_ProtBlockCtr = bc_VFC_OcaHdr_VFC_OcaHdr_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_OcaHdr_VFC_OcaHdr_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_OcaHdr_VFC_OcaHdr_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }

    clearBitsInByteArrayLE(data,64,26); //Intel / little-endian

    //Msg_VFC_OcaHdr.VFC_OcaHdr_TimeStamp = @CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_TimeStamp_FaultInject +(timeNowNS()/1000000);

      copyBitsToByteArrayLE(@CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_TimeStamp_FaultInject +(timeNowNS()/1000000),data,64,26); //Intel / little-endian;
    if (@CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2056 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2056 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_OcaHdr_VFC_OcaHdr_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_OcaHdr_VFC_OcaHdr_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_OcaHdr::VFC_OcaHdr_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_OcaHdr_VFC_OcaHdr_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Oca_000_017::VFC_Oca_000_017_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Oca_000_017);
     @CAN_PrivMain::VFC_Oca_000_017::VFC_Oca_000_017_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Oca_000_017(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Oca_000_017.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Oca_000_017.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Oca_000_017::VFC_Oca_000_017_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Oca_000_017::VFC_Oca_000_017_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Oca_000_017_VFC_Oca_000_017_AliveCtr;
      counter_VFC_Oca_000_017_VFC_Oca_000_017_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Oca_000_017_VFC_Oca_000_017_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Oca_000_017::VFC_Oca_000_017_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Oca_000_017::VFC_Oca_000_017_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Oca_000_017_VFC_Oca_000_017_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Oca_000_017::VFC_Oca_000_017_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Oca_000_017::VFC_Oca_000_017_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Oca_000_017_VFC_Oca_000_017_ProtBlockCtr = bc_None_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Oca_000_017_VFC_Oca_000_017_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Oca_000_017::VFC_Oca_000_017_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Oca_000_017::VFC_Oca_000_017_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Oca_000_017_VFC_Oca_000_017_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Oca_000_017::VFC_Oca_000_017_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Oca_000_017::VFC_Oca_000_017_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2058 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2058 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Oca_000_017_VFC_Oca_000_017_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Oca_000_017_VFC_Oca_000_017_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Oca_000_017::VFC_Oca_000_017_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Oca_000_017::VFC_Oca_000_017_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Oca_000_017_VFC_Oca_000_017_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Oca_018_035::VFC_Oca_018_035_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Oca_018_035);
     @CAN_PrivMain::VFC_Oca_018_035::VFC_Oca_018_035_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Oca_018_035(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Oca_018_035.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Oca_018_035.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Oca_018_035::VFC_Oca_018_035_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Oca_018_035::VFC_Oca_018_035_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Oca_018_035_VFC_Oca_018_035_AliveCtr;
      counter_VFC_Oca_018_035_VFC_Oca_018_035_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Oca_018_035_VFC_Oca_018_035_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Oca_018_035::VFC_Oca_018_035_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Oca_018_035::VFC_Oca_018_035_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Oca_018_035_VFC_Oca_018_035_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Oca_018_035::VFC_Oca_018_035_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Oca_018_035::VFC_Oca_018_035_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Oca_018_035_VFC_Oca_018_035_ProtBlockCtr = bc_None_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Oca_018_035_VFC_Oca_018_035_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Oca_018_035::VFC_Oca_018_035_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Oca_018_035::VFC_Oca_018_035_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Oca_018_035_VFC_Oca_018_035_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Oca_018_035::VFC_Oca_018_035_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Oca_018_035::VFC_Oca_018_035_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2059 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2059 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Oca_018_035_VFC_Oca_018_035_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Oca_018_035_VFC_Oca_018_035_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Oca_018_035::VFC_Oca_018_035_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Oca_018_035::VFC_Oca_018_035_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Oca_018_035_VFC_Oca_018_035_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Oca_036_053::VFC_Oca_036_053_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Oca_036_053);
     @CAN_PrivMain::VFC_Oca_036_053::VFC_Oca_036_053_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Oca_036_053(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Oca_036_053.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Oca_036_053.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Oca_036_053::VFC_Oca_036_053_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Oca_036_053::VFC_Oca_036_053_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Oca_036_053_VFC_Oca_036_053_AliveCtr;
      counter_VFC_Oca_036_053_VFC_Oca_036_053_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Oca_036_053_VFC_Oca_036_053_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Oca_036_053::VFC_Oca_036_053_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Oca_036_053::VFC_Oca_036_053_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Oca_036_053_VFC_Oca_036_053_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Oca_036_053::VFC_Oca_036_053_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Oca_036_053::VFC_Oca_036_053_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Oca_036_053_VFC_Oca_036_053_ProtBlockCtr = bc_None_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Oca_036_053_VFC_Oca_036_053_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Oca_036_053::VFC_Oca_036_053_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Oca_036_053::VFC_Oca_036_053_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Oca_036_053_VFC_Oca_036_053_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Oca_036_053::VFC_Oca_036_053_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Oca_036_053::VFC_Oca_036_053_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x205a & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x205a & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Oca_036_053_VFC_Oca_036_053_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Oca_036_053_VFC_Oca_036_053_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Oca_036_053::VFC_Oca_036_053_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Oca_036_053::VFC_Oca_036_053_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Oca_036_053_VFC_Oca_036_053_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Oca_054_071::VFC_Oca_054_071_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Oca_054_071);
     @CAN_PrivMain::VFC_Oca_054_071::VFC_Oca_054_071_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Oca_054_071(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Oca_054_071.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Oca_054_071.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Oca_054_071::VFC_Oca_054_071_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Oca_054_071::VFC_Oca_054_071_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Oca_054_071_VFC_Oca_054_071_AliveCtr;
      counter_VFC_Oca_054_071_VFC_Oca_054_071_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Oca_054_071_VFC_Oca_054_071_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Oca_054_071::VFC_Oca_054_071_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Oca_054_071::VFC_Oca_054_071_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Oca_054_071_VFC_Oca_054_071_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Oca_054_071::VFC_Oca_054_071_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Oca_054_071::VFC_Oca_054_071_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Oca_054_071_VFC_Oca_054_071_ProtBlockCtr = bc_None_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Oca_054_071_VFC_Oca_054_071_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Oca_054_071::VFC_Oca_054_071_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Oca_054_071::VFC_Oca_054_071_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Oca_054_071_VFC_Oca_054_071_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Oca_054_071::VFC_Oca_054_071_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Oca_054_071::VFC_Oca_054_071_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x205b & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x205b & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Oca_054_071_VFC_Oca_054_071_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Oca_054_071_VFC_Oca_054_071_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Oca_054_071::VFC_Oca_054_071_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Oca_054_071::VFC_Oca_054_071_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Oca_054_071_VFC_Oca_054_071_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Road2DPolynomial_00_02::VFC_Road2DPolynomial_00_02_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Road2DPolynomial_00_02);
     @CAN_PrivMain::VFC_Road2DPolynomial_00_02::VFC_Road2DPolynomial_00_02_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Road2DPolynomial_00_02(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Road2DPolynomial_00_02.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Road2DPolynomial_00_02.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Road2DPolynomial_00_02::VFC_2DPoly_00_02_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_00_02::VFC_2DPoly_00_02_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Road2DPolynomial_00_02_VFC_2DPoly_00_02_AliveCtr;
      counter_VFC_Road2DPolynomial_00_02_VFC_2DPoly_00_02_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Road2DPolynomial_00_02_VFC_2DPoly_00_02_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_00_02::VFC_2DPoly_00_02_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_00_02::VFC_2DPoly_00_02_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Road2DPolynomial_00_02_VFC_2DPoly_00_02_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_00_02::VFC_2DPoly_00_02_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_00_02::VFC_2DPoly_00_02_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Road2DPolynomial_00_02_VFC_2DPoly_00_02_ProtBlockCtr = bc_VFC_Road_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Road2DPolynomial_00_02_VFC_2DPoly_00_02_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_00_02::VFC_2DPoly_00_02_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_00_02::VFC_2DPoly_00_02_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Road2DPolynomial_00_02_VFC_2DPoly_00_02_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_00_02::VFC_2DPoly_00_02_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Road2DPolynomial_00_02::VFC_2DPoly_00_02_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20a2 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20a2 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Road2DPolynomial_00_02_VFC_2DPoly_00_02_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Road2DPolynomial_00_02_VFC_2DPoly_00_02_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Road2DPolynomial_00_02::VFC_2DPoly_00_02_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Road2DPolynomial_00_02::VFC_2DPoly_00_02_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Road2DPolynomial_00_02_VFC_2DPoly_00_02_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Road2DPolynomial_03_05::VFC_Road2DPolynomial_03_05_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Road2DPolynomial_03_05);
     @CAN_PrivMain::VFC_Road2DPolynomial_03_05::VFC_Road2DPolynomial_03_05_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Road2DPolynomial_03_05(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Road2DPolynomial_03_05.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Road2DPolynomial_03_05.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Road2DPolynomial_03_05::VFC_2DPoly_03_05_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_03_05::VFC_2DPoly_03_05_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Road2DPolynomial_03_05_VFC_2DPoly_03_05_AliveCtr;
      counter_VFC_Road2DPolynomial_03_05_VFC_2DPoly_03_05_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Road2DPolynomial_03_05_VFC_2DPoly_03_05_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_03_05::VFC_2DPoly_03_05_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_03_05::VFC_2DPoly_03_05_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Road2DPolynomial_03_05_VFC_2DPoly_03_05_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_03_05::VFC_2DPoly_03_05_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_03_05::VFC_2DPoly_03_05_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Road2DPolynomial_03_05_VFC_2DPoly_03_05_ProtBlockCtr = bc_VFC_Road_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Road2DPolynomial_03_05_VFC_2DPoly_03_05_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_03_05::VFC_2DPoly_03_05_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_03_05::VFC_2DPoly_03_05_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Road2DPolynomial_03_05_VFC_2DPoly_03_05_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_03_05::VFC_2DPoly_03_05_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Road2DPolynomial_03_05::VFC_2DPoly_03_05_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20a3 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20a3 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Road2DPolynomial_03_05_VFC_2DPoly_03_05_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Road2DPolynomial_03_05_VFC_2DPoly_03_05_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Road2DPolynomial_03_05::VFC_2DPoly_03_05_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Road2DPolynomial_03_05::VFC_2DPoly_03_05_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Road2DPolynomial_03_05_VFC_2DPoly_03_05_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Road2DPolynomial_06_08::VFC_Road2DPolynomial_06_08_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Road2DPolynomial_06_08);
     @CAN_PrivMain::VFC_Road2DPolynomial_06_08::VFC_Road2DPolynomial_06_08_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Road2DPolynomial_06_08(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Road2DPolynomial_06_08.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Road2DPolynomial_06_08.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Road2DPolynomial_06_08::VFC_2DPoly_06_08_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_06_08::VFC_2DPoly_06_08_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Road2DPolynomial_06_08_VFC_2DPoly_06_08_AliveCtr;
      counter_VFC_Road2DPolynomial_06_08_VFC_2DPoly_06_08_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Road2DPolynomial_06_08_VFC_2DPoly_06_08_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_06_08::VFC_2DPoly_06_08_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_06_08::VFC_2DPoly_06_08_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Road2DPolynomial_06_08_VFC_2DPoly_06_08_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_06_08::VFC_2DPoly_06_08_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_06_08::VFC_2DPoly_06_08_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Road2DPolynomial_06_08_VFC_2DPoly_06_08_ProtBlockCtr = bc_VFC_Road_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Road2DPolynomial_06_08_VFC_2DPoly_06_08_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_06_08::VFC_2DPoly_06_08_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_06_08::VFC_2DPoly_06_08_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Road2DPolynomial_06_08_VFC_2DPoly_06_08_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_06_08::VFC_2DPoly_06_08_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Road2DPolynomial_06_08::VFC_2DPoly_06_08_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20a4 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20a4 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Road2DPolynomial_06_08_VFC_2DPoly_06_08_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Road2DPolynomial_06_08_VFC_2DPoly_06_08_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Road2DPolynomial_06_08::VFC_2DPoly_06_08_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Road2DPolynomial_06_08::VFC_2DPoly_06_08_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Road2DPolynomial_06_08_VFC_2DPoly_06_08_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Road2DPolynomial_09_11::VFC_Road2DPolynomial_09_11_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Road2DPolynomial_09_11);
     @CAN_PrivMain::VFC_Road2DPolynomial_09_11::VFC_Road2DPolynomial_09_11_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Road2DPolynomial_09_11(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Road2DPolynomial_09_11.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Road2DPolynomial_09_11.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Road2DPolynomial_09_11::VFC_2DPoly_09_11_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_09_11::VFC_2DPoly_09_11_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Road2DPolynomial_09_11_VFC_2DPoly_09_11_AliveCtr;
      counter_VFC_Road2DPolynomial_09_11_VFC_2DPoly_09_11_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Road2DPolynomial_09_11_VFC_2DPoly_09_11_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_09_11::VFC_2DPoly_09_11_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_09_11::VFC_2DPoly_09_11_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Road2DPolynomial_09_11_VFC_2DPoly_09_11_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_09_11::VFC_2DPoly_09_11_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_09_11::VFC_2DPoly_09_11_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Road2DPolynomial_09_11_VFC_2DPoly_09_11_ProtBlockCtr = bc_VFC_Road_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Road2DPolynomial_09_11_VFC_2DPoly_09_11_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_09_11::VFC_2DPoly_09_11_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_09_11::VFC_2DPoly_09_11_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Road2DPolynomial_09_11_VFC_2DPoly_09_11_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_09_11::VFC_2DPoly_09_11_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Road2DPolynomial_09_11::VFC_2DPoly_09_11_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20a5 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20a5 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Road2DPolynomial_09_11_VFC_2DPoly_09_11_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Road2DPolynomial_09_11_VFC_2DPoly_09_11_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Road2DPolynomial_09_11::VFC_2DPoly_09_11_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Road2DPolynomial_09_11::VFC_2DPoly_09_11_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Road2DPolynomial_09_11_VFC_2DPoly_09_11_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Road2DPolynomial_12_14::VFC_Road2DPolynomial_12_14_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Road2DPolynomial_12_14);
     @CAN_PrivMain::VFC_Road2DPolynomial_12_14::VFC_Road2DPolynomial_12_14_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Road2DPolynomial_12_14(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Road2DPolynomial_12_14.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Road2DPolynomial_12_14.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Road2DPolynomial_12_14::VFC_2DPoly_12_14_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_12_14::VFC_2DPoly_12_14_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Road2DPolynomial_12_14_VFC_2DPoly_12_14_AliveCtr;
      counter_VFC_Road2DPolynomial_12_14_VFC_2DPoly_12_14_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Road2DPolynomial_12_14_VFC_2DPoly_12_14_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_12_14::VFC_2DPoly_12_14_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_12_14::VFC_2DPoly_12_14_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Road2DPolynomial_12_14_VFC_2DPoly_12_14_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_12_14::VFC_2DPoly_12_14_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_12_14::VFC_2DPoly_12_14_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_Road2DPolynomial_12_14_VFC_2DPoly_12_14_ProtBlockCtr = bc_VFC_Road_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_Road2DPolynomial_12_14_VFC_2DPoly_12_14_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_12_14::VFC_2DPoly_12_14_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Road2DPolynomial_12_14::VFC_2DPoly_12_14_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_Road2DPolynomial_12_14_VFC_2DPoly_12_14_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Road2DPolynomial_12_14::VFC_2DPoly_12_14_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Road2DPolynomial_12_14::VFC_2DPoly_12_14_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20a6 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20a6 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Road2DPolynomial_12_14_VFC_2DPoly_12_14_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Road2DPolynomial_12_14_VFC_2DPoly_12_14_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Road2DPolynomial_12_14::VFC_2DPoly_12_14_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Road2DPolynomial_12_14::VFC_2DPoly_12_14_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Road2DPolynomial_12_14_VFC_2DPoly_12_14_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_RoadClothoid_00_02::VFC_RoadClothoid_00_02_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_RoadClothoid_00_02);
     @CAN_PrivMain::VFC_RoadClothoid_00_02::VFC_RoadClothoid_00_02_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_RoadClothoid_00_02(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_RoadClothoid_00_02.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_RoadClothoid_00_02.id;//Message ID
   
    if (@CAN_PrivMain::VFC_RoadClothoid_00_02::VFC_Cloth_00_02_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadClothoid_00_02::VFC_Cloth_00_02_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_RoadClothoid_00_02_VFC_Cloth_00_02_AliveCtr;
      counter_VFC_RoadClothoid_00_02_VFC_Cloth_00_02_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_RoadClothoid_00_02_VFC_Cloth_00_02_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadClothoid_00_02::VFC_Cloth_00_02_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadClothoid_00_02::VFC_Cloth_00_02_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_RoadClothoid_00_02_VFC_Cloth_00_02_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadClothoid_00_02::VFC_Cloth_00_02_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadClothoid_00_02::VFC_Cloth_00_02_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_RoadClothoid_00_02_VFC_Cloth_00_02_ProtBlockCtr = bc_VFC_Road_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_RoadClothoid_00_02_VFC_Cloth_00_02_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadClothoid_00_02::VFC_Cloth_00_02_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadClothoid_00_02::VFC_Cloth_00_02_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_RoadClothoid_00_02_VFC_Cloth_00_02_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadClothoid_00_02::VFC_Cloth_00_02_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_RoadClothoid_00_02::VFC_Cloth_00_02_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2082 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2082 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_RoadClothoid_00_02_VFC_Cloth_00_02_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_RoadClothoid_00_02_VFC_Cloth_00_02_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadClothoid_00_02::VFC_Cloth_00_02_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadClothoid_00_02::VFC_Cloth_00_02_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_RoadClothoid_00_02_VFC_Cloth_00_02_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_RoadClothoid_03_05::VFC_RoadClothoid_03_05_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_RoadClothoid_03_05);
     @CAN_PrivMain::VFC_RoadClothoid_03_05::VFC_RoadClothoid_03_05_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_RoadClothoid_03_05(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_RoadClothoid_03_05.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_RoadClothoid_03_05.id;//Message ID
   
    if (@CAN_PrivMain::VFC_RoadClothoid_03_05::VFC_Cloth_03_05_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadClothoid_03_05::VFC_Cloth_03_05_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_RoadClothoid_03_05_VFC_Cloth_03_05_AliveCtr;
      counter_VFC_RoadClothoid_03_05_VFC_Cloth_03_05_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_RoadClothoid_03_05_VFC_Cloth_03_05_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadClothoid_03_05::VFC_Cloth_03_05_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadClothoid_03_05::VFC_Cloth_03_05_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_RoadClothoid_03_05_VFC_Cloth_03_05_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadClothoid_03_05::VFC_Cloth_03_05_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadClothoid_03_05::VFC_Cloth_03_05_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_RoadClothoid_03_05_VFC_Cloth_03_05_ProtBlockCtr = bc_VFC_Road_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_RoadClothoid_03_05_VFC_Cloth_03_05_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadClothoid_03_05::VFC_Cloth_03_05_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadClothoid_03_05::VFC_Cloth_03_05_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_RoadClothoid_03_05_VFC_Cloth_03_05_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadClothoid_03_05::VFC_Cloth_03_05_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_RoadClothoid_03_05::VFC_Cloth_03_05_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2083 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2083 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_RoadClothoid_03_05_VFC_Cloth_03_05_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_RoadClothoid_03_05_VFC_Cloth_03_05_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadClothoid_03_05::VFC_Cloth_03_05_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadClothoid_03_05::VFC_Cloth_03_05_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_RoadClothoid_03_05_VFC_Cloth_03_05_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_RoadClothoid_06_08::VFC_RoadClothoid_06_08_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_RoadClothoid_06_08);
     @CAN_PrivMain::VFC_RoadClothoid_06_08::VFC_RoadClothoid_06_08_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_RoadClothoid_06_08(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_RoadClothoid_06_08.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_RoadClothoid_06_08.id;//Message ID
   
    if (@CAN_PrivMain::VFC_RoadClothoid_06_08::VFC_Cloth_06_08_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadClothoid_06_08::VFC_Cloth_06_08_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_RoadClothoid_06_08_VFC_Cloth_06_08_AliveCtr;
      counter_VFC_RoadClothoid_06_08_VFC_Cloth_06_08_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_RoadClothoid_06_08_VFC_Cloth_06_08_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadClothoid_06_08::VFC_Cloth_06_08_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadClothoid_06_08::VFC_Cloth_06_08_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_RoadClothoid_06_08_VFC_Cloth_06_08_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadClothoid_06_08::VFC_Cloth_06_08_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadClothoid_06_08::VFC_Cloth_06_08_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_RoadClothoid_06_08_VFC_Cloth_06_08_ProtBlockCtr = bc_VFC_Road_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_RoadClothoid_06_08_VFC_Cloth_06_08_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadClothoid_06_08::VFC_Cloth_06_08_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadClothoid_06_08::VFC_Cloth_06_08_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_RoadClothoid_06_08_VFC_Cloth_06_08_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadClothoid_06_08::VFC_Cloth_06_08_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_RoadClothoid_06_08::VFC_Cloth_06_08_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2084 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2084 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_RoadClothoid_06_08_VFC_Cloth_06_08_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_RoadClothoid_06_08_VFC_Cloth_06_08_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadClothoid_06_08::VFC_Cloth_06_08_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadClothoid_06_08::VFC_Cloth_06_08_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_RoadClothoid_06_08_VFC_Cloth_06_08_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_RoadClothoid_09_11::VFC_RoadClothoid_09_11_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_RoadClothoid_09_11);
     @CAN_PrivMain::VFC_RoadClothoid_09_11::VFC_RoadClothoid_09_11_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_RoadClothoid_09_11(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_RoadClothoid_09_11.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_RoadClothoid_09_11.id;//Message ID
   
    if (@CAN_PrivMain::VFC_RoadClothoid_09_11::VFC_Cloth_09_11_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadClothoid_09_11::VFC_Cloth_09_11_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_RoadClothoid_09_11_VFC_Cloth_09_11_AliveCtr;
      counter_VFC_RoadClothoid_09_11_VFC_Cloth_09_11_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_RoadClothoid_09_11_VFC_Cloth_09_11_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadClothoid_09_11::VFC_Cloth_09_11_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadClothoid_09_11::VFC_Cloth_09_11_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_RoadClothoid_09_11_VFC_Cloth_09_11_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadClothoid_09_11::VFC_Cloth_09_11_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadClothoid_09_11::VFC_Cloth_09_11_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_RoadClothoid_09_11_VFC_Cloth_09_11_ProtBlockCtr = bc_VFC_Road_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_RoadClothoid_09_11_VFC_Cloth_09_11_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadClothoid_09_11::VFC_Cloth_09_11_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadClothoid_09_11::VFC_Cloth_09_11_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_RoadClothoid_09_11_VFC_Cloth_09_11_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadClothoid_09_11::VFC_Cloth_09_11_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_RoadClothoid_09_11::VFC_Cloth_09_11_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2085 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2085 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_RoadClothoid_09_11_VFC_Cloth_09_11_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_RoadClothoid_09_11_VFC_Cloth_09_11_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadClothoid_09_11::VFC_Cloth_09_11_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadClothoid_09_11::VFC_Cloth_09_11_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_RoadClothoid_09_11_VFC_Cloth_09_11_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_RoadHdr);
     @CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_RoadHdr(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_RoadHdr.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_RoadHdr.id;//Message ID
   
    if (@CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_RoadHdr_VFC_RoadHdr_AliveCtr;
      counter_VFC_RoadHdr_VFC_RoadHdr_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_RoadHdr_VFC_RoadHdr_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_RoadHdr_VFC_RoadHdr_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      ++bc_VFC_RoadHdr_VFC_RoadHdr_ProtBlockCtr;
      bc_VFC_RoadHdr_VFC_RoadHdr_ProtBlockCtr %=16;
      bc_VFC_Road_ProtBlockCtr = bc_VFC_RoadHdr_VFC_RoadHdr_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_RoadHdr_VFC_RoadHdr_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_RoadHdr_VFC_RoadHdr_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }

    clearBitsInByteArrayLE(data,64,26); //Intel / little-endian

    //Msg_VFC_RoadHdr.VFC_RoadHdr_TimeStamp = @CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_TimeStamp_FaultInject +(timeNowNS()/1000000);

      copyBitsToByteArrayLE(@CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_TimeStamp_FaultInject +(timeNowNS()/1000000),data,64,26); //Intel / little-endian;
    if (@CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2080 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2080 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_RoadHdr_VFC_RoadHdr_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_RoadHdr_VFC_RoadHdr_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadHdr::VFC_RoadHdr_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_RoadHdr_VFC_RoadHdr_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_RoadMarking_00_06::VFC_RoadMarking_00_06_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_RoadMarking_00_06);
     @CAN_PrivMain::VFC_RoadMarking_00_06::VFC_RoadMarking_00_06_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_RoadMarking_00_06(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_RoadMarking_00_06.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_RoadMarking_00_06.id;//Message ID
   
    if (@CAN_PrivMain::VFC_RoadMarking_00_06::VFC_RM_00_06_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadMarking_00_06::VFC_RM_00_06_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_RoadMarking_00_06_VFC_RM_00_06_AliveCtr;
      counter_VFC_RoadMarking_00_06_VFC_RM_00_06_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_RoadMarking_00_06_VFC_RM_00_06_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadMarking_00_06::VFC_RM_00_06_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadMarking_00_06::VFC_RM_00_06_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_RoadMarking_00_06_VFC_RM_00_06_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadMarking_00_06::VFC_RM_00_06_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadMarking_00_06::VFC_RM_00_06_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_RoadMarking_00_06_VFC_RM_00_06_ProtBlockCtr = bc_VFC_Road_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_RoadMarking_00_06_VFC_RM_00_06_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadMarking_00_06::VFC_RM_00_06_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadMarking_00_06::VFC_RM_00_06_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_RoadMarking_00_06_VFC_RM_00_06_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadMarking_00_06::VFC_RM_00_06_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_RoadMarking_00_06::VFC_RM_00_06_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20b2 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20b2 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_RoadMarking_00_06_VFC_RM_00_06_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_RoadMarking_00_06_VFC_RM_00_06_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadMarking_00_06::VFC_RM_00_06_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadMarking_00_06::VFC_RM_00_06_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_RoadMarking_00_06_VFC_RM_00_06_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_RoadPolynomial_00_02::VFC_RoadPolynomial_00_02_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_RoadPolynomial_00_02);
     @CAN_PrivMain::VFC_RoadPolynomial_00_02::VFC_RoadPolynomial_00_02_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_RoadPolynomial_00_02(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_RoadPolynomial_00_02.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_RoadPolynomial_00_02.id;//Message ID
   
    if (@CAN_PrivMain::VFC_RoadPolynomial_00_02::VFC_Poly_00_02_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_00_02::VFC_Poly_00_02_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_RoadPolynomial_00_02_VFC_Poly_00_02_AliveCtr;
      counter_VFC_RoadPolynomial_00_02_VFC_Poly_00_02_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_RoadPolynomial_00_02_VFC_Poly_00_02_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_00_02::VFC_Poly_00_02_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_00_02::VFC_Poly_00_02_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_RoadPolynomial_00_02_VFC_Poly_00_02_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_00_02::VFC_Poly_00_02_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_00_02::VFC_Poly_00_02_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_RoadPolynomial_00_02_VFC_Poly_00_02_ProtBlockCtr = bc_VFC_Road_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_RoadPolynomial_00_02_VFC_Poly_00_02_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_00_02::VFC_Poly_00_02_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_00_02::VFC_Poly_00_02_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_RoadPolynomial_00_02_VFC_Poly_00_02_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_00_02::VFC_Poly_00_02_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_RoadPolynomial_00_02::VFC_Poly_00_02_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2092 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2092 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_RoadPolynomial_00_02_VFC_Poly_00_02_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_RoadPolynomial_00_02_VFC_Poly_00_02_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadPolynomial_00_02::VFC_Poly_00_02_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadPolynomial_00_02::VFC_Poly_00_02_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_RoadPolynomial_00_02_VFC_Poly_00_02_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_RoadPolynomial_03_05::VFC_RoadPolynomial_03_05_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_RoadPolynomial_03_05);
     @CAN_PrivMain::VFC_RoadPolynomial_03_05::VFC_RoadPolynomial_03_05_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_RoadPolynomial_03_05(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_RoadPolynomial_03_05.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_RoadPolynomial_03_05.id;//Message ID
   
    if (@CAN_PrivMain::VFC_RoadPolynomial_03_05::VFC_Poly_03_05_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_03_05::VFC_Poly_03_05_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_RoadPolynomial_03_05_VFC_Poly_03_05_AliveCtr;
      counter_VFC_RoadPolynomial_03_05_VFC_Poly_03_05_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_RoadPolynomial_03_05_VFC_Poly_03_05_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_03_05::VFC_Poly_03_05_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_03_05::VFC_Poly_03_05_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_RoadPolynomial_03_05_VFC_Poly_03_05_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_03_05::VFC_Poly_03_05_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_03_05::VFC_Poly_03_05_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_RoadPolynomial_03_05_VFC_Poly_03_05_ProtBlockCtr = bc_VFC_Road_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_RoadPolynomial_03_05_VFC_Poly_03_05_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_03_05::VFC_Poly_03_05_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_03_05::VFC_Poly_03_05_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_RoadPolynomial_03_05_VFC_Poly_03_05_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_03_05::VFC_Poly_03_05_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_RoadPolynomial_03_05::VFC_Poly_03_05_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2093 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2093 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_RoadPolynomial_03_05_VFC_Poly_03_05_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_RoadPolynomial_03_05_VFC_Poly_03_05_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadPolynomial_03_05::VFC_Poly_03_05_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadPolynomial_03_05::VFC_Poly_03_05_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_RoadPolynomial_03_05_VFC_Poly_03_05_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_RoadPolynomial_06_08::VFC_RoadPolynomial_06_08_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_RoadPolynomial_06_08);
     @CAN_PrivMain::VFC_RoadPolynomial_06_08::VFC_RoadPolynomial_06_08_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_RoadPolynomial_06_08(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_RoadPolynomial_06_08.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_RoadPolynomial_06_08.id;//Message ID
   
    if (@CAN_PrivMain::VFC_RoadPolynomial_06_08::VFC_Poly_06_08_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_06_08::VFC_Poly_06_08_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_RoadPolynomial_06_08_VFC_Poly_06_08_AliveCtr;
      counter_VFC_RoadPolynomial_06_08_VFC_Poly_06_08_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_RoadPolynomial_06_08_VFC_Poly_06_08_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_06_08::VFC_Poly_06_08_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_06_08::VFC_Poly_06_08_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_RoadPolynomial_06_08_VFC_Poly_06_08_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_06_08::VFC_Poly_06_08_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_06_08::VFC_Poly_06_08_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_RoadPolynomial_06_08_VFC_Poly_06_08_ProtBlockCtr = bc_VFC_Road_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_RoadPolynomial_06_08_VFC_Poly_06_08_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_06_08::VFC_Poly_06_08_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_06_08::VFC_Poly_06_08_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_RoadPolynomial_06_08_VFC_Poly_06_08_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_06_08::VFC_Poly_06_08_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_RoadPolynomial_06_08::VFC_Poly_06_08_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2094 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2094 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_RoadPolynomial_06_08_VFC_Poly_06_08_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_RoadPolynomial_06_08_VFC_Poly_06_08_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadPolynomial_06_08::VFC_Poly_06_08_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadPolynomial_06_08::VFC_Poly_06_08_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_RoadPolynomial_06_08_VFC_Poly_06_08_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_RoadPolynomial_09_11::VFC_RoadPolynomial_09_11_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_RoadPolynomial_09_11);
     @CAN_PrivMain::VFC_RoadPolynomial_09_11::VFC_RoadPolynomial_09_11_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_RoadPolynomial_09_11(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_RoadPolynomial_09_11.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_RoadPolynomial_09_11.id;//Message ID
   
    if (@CAN_PrivMain::VFC_RoadPolynomial_09_11::VFC_Poly_09_11_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_09_11::VFC_Poly_09_11_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_RoadPolynomial_09_11_VFC_Poly_09_11_AliveCtr;
      counter_VFC_RoadPolynomial_09_11_VFC_Poly_09_11_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_RoadPolynomial_09_11_VFC_Poly_09_11_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_09_11::VFC_Poly_09_11_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_09_11::VFC_Poly_09_11_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_RoadPolynomial_09_11_VFC_Poly_09_11_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_09_11::VFC_Poly_09_11_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_09_11::VFC_Poly_09_11_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_RoadPolynomial_09_11_VFC_Poly_09_11_ProtBlockCtr = bc_VFC_Road_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_RoadPolynomial_09_11_VFC_Poly_09_11_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_09_11::VFC_Poly_09_11_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_09_11::VFC_Poly_09_11_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_RoadPolynomial_09_11_VFC_Poly_09_11_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_09_11::VFC_Poly_09_11_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_RoadPolynomial_09_11::VFC_Poly_09_11_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2095 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2095 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_RoadPolynomial_09_11_VFC_Poly_09_11_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_RoadPolynomial_09_11_VFC_Poly_09_11_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadPolynomial_09_11::VFC_Poly_09_11_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadPolynomial_09_11::VFC_Poly_09_11_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_RoadPolynomial_09_11_VFC_Poly_09_11_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_RoadPolynomial_12_14::VFC_RoadPolynomial_12_14_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_RoadPolynomial_12_14);
     @CAN_PrivMain::VFC_RoadPolynomial_12_14::VFC_RoadPolynomial_12_14_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_RoadPolynomial_12_14(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_RoadPolynomial_12_14.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_RoadPolynomial_12_14.id;//Message ID
   
    if (@CAN_PrivMain::VFC_RoadPolynomial_12_14::VFC_Poly_12_14_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_12_14::VFC_Poly_12_14_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_RoadPolynomial_12_14_VFC_Poly_12_14_AliveCtr;
      counter_VFC_RoadPolynomial_12_14_VFC_Poly_12_14_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_RoadPolynomial_12_14_VFC_Poly_12_14_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_12_14::VFC_Poly_12_14_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_12_14::VFC_Poly_12_14_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_RoadPolynomial_12_14_VFC_Poly_12_14_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_12_14::VFC_Poly_12_14_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_12_14::VFC_Poly_12_14_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_RoadPolynomial_12_14_VFC_Poly_12_14_ProtBlockCtr = bc_VFC_Road_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_RoadPolynomial_12_14_VFC_Poly_12_14_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_12_14::VFC_Poly_12_14_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_RoadPolynomial_12_14::VFC_Poly_12_14_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_RoadPolynomial_12_14_VFC_Poly_12_14_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_RoadPolynomial_12_14::VFC_Poly_12_14_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_RoadPolynomial_12_14::VFC_Poly_12_14_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2096 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2096 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_RoadPolynomial_12_14_VFC_Poly_12_14_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_RoadPolynomial_12_14_VFC_Poly_12_14_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadPolynomial_12_14::VFC_Poly_12_14_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_RoadPolynomial_12_14::VFC_Poly_12_14_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_RoadPolynomial_12_14_VFC_Poly_12_14_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_Status::VFC_Status_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_Status);
     @CAN_PrivMain::VFC_Status::VFC_Status_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_Status(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_Status.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_Status.id;//Message ID
   
    if (@CAN_PrivMain::VFC_Status::VFC_Status_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Status::VFC_Status_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Status_VFC_Status_AliveCtr;
      counter_VFC_Status_VFC_Status_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_Status_VFC_Status_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Status::VFC_Status_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Status::VFC_Status_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Status_VFC_Status_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_Status::VFC_Status_FrameNumber_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,96,16); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_Status::VFC_Status_FrameNumber_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_Status_VFC_Status_FrameNumber;
      counter_VFC_Status_VFC_Status_FrameNumber %=65536;

      copyBitsToByteArrayLE(counter_VFC_Status_VFC_Status_FrameNumber,data,96,16); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Status::VFC_Status_FrameNumber_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,96,16); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_Status::VFC_Status_FrameNumber_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_Status_VFC_Status_FrameNumber,data,96,16); //Intel / little-endian;
    }

    clearBitsInByteArrayLE(data,64,26); //Intel / little-endian

    //Msg_VFC_Status.VFC_Status_TimeStamp = @CAN_PrivMain::VFC_Status::VFC_Status_TimeStamp_FaultInject +(timeNowNS()/1000000);

      copyBitsToByteArrayLE(@CAN_PrivMain::VFC_Status::VFC_Status_TimeStamp_FaultInject +(timeNowNS()/1000000),data,64,26); //Intel / little-endian;
    if (@CAN_PrivMain::VFC_Status::VFC_Status_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_Status::VFC_Status_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x2020 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x2020 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_Status_VFC_Status_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_Status_VFC_Status_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Status::VFC_Status_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_Status::VFC_Status_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_Status_VFC_Status_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_TrafficLightHdr::VFC_TrafficLightHdr_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_TrafficLightHdr);
     @CAN_PrivMain::VFC_TrafficLightHdr::VFC_TrafficLightHdr_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_TrafficLightHdr(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_TrafficLightHdr.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_TrafficLightHdr.id;//Message ID
   
    if (@CAN_PrivMain::VFC_TrafficLightHdr::VFC_TLHdr_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficLightHdr::VFC_TLHdr_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_TrafficLightHdr_VFC_TLHdr_AliveCtr;
      counter_VFC_TrafficLightHdr_VFC_TLHdr_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_TrafficLightHdr_VFC_TLHdr_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficLightHdr::VFC_TLHdr_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficLightHdr::VFC_TLHdr_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_TrafficLightHdr_VFC_TLHdr_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficLightHdr::VFC_TLHdr_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficLightHdr::VFC_TLHdr_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      ++bc_VFC_TrafficLightHdr_VFC_TLHdr_ProtBlockCtr;
      bc_VFC_TrafficLightHdr_VFC_TLHdr_ProtBlockCtr %=16;
      bc_VFC_TrafficLight_ProtBlockCtr = bc_VFC_TrafficLightHdr_VFC_TLHdr_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_TrafficLightHdr_VFC_TLHdr_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficLightHdr::VFC_TLHdr_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficLightHdr::VFC_TLHdr_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_TrafficLightHdr_VFC_TLHdr_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }

    clearBitsInByteArrayLE(data,64,26); //Intel / little-endian

    //Msg_VFC_TrafficLightHdr.VFC_TLHdr_TimeStamp = @CAN_PrivMain::VFC_TrafficLightHdr::VFC_TLHdr_TimeStamp_FaultInject +(timeNowNS()/1000000);

      copyBitsToByteArrayLE(@CAN_PrivMain::VFC_TrafficLightHdr::VFC_TLHdr_TimeStamp_FaultInject +(timeNowNS()/1000000),data,64,26); //Intel / little-endian;
    if (@CAN_PrivMain::VFC_TrafficLightHdr::VFC_TLHdr_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_TrafficLightHdr::VFC_TLHdr_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20e0 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20e0 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_TrafficLightHdr_VFC_TLHdr_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_TrafficLightHdr_VFC_TLHdr_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficLightHdr::VFC_TLHdr_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficLightHdr::VFC_TLHdr_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_TrafficLightHdr_VFC_TLHdr_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_TrafficLight_00_04::VFC_TrafficLight_00_04_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_TrafficLight_00_04);
     @CAN_PrivMain::VFC_TrafficLight_00_04::VFC_TrafficLight_00_04_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_TrafficLight_00_04(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_TrafficLight_00_04.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_TrafficLight_00_04.id;//Message ID
   
    if (@CAN_PrivMain::VFC_TrafficLight_00_04::VFC_TL00_04_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficLight_00_04::VFC_TL00_04_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_TrafficLight_00_04_VFC_TL00_04_AliveCtr;
      counter_VFC_TrafficLight_00_04_VFC_TL00_04_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_TrafficLight_00_04_VFC_TL00_04_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficLight_00_04::VFC_TL00_04_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficLight_00_04::VFC_TL00_04_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_TrafficLight_00_04_VFC_TL00_04_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficLight_00_04::VFC_TL00_04_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficLight_00_04::VFC_TL00_04_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_TrafficLight_00_04_VFC_TL00_04_ProtBlockCtr = bc_VFC_TrafficLight_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_TrafficLight_00_04_VFC_TL00_04_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficLight_00_04::VFC_TL00_04_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficLight_00_04::VFC_TL00_04_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_TrafficLight_00_04_VFC_TL00_04_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficLight_00_04::VFC_TL00_04_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_TrafficLight_00_04::VFC_TL00_04_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20e2 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20e2 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_TrafficLight_00_04_VFC_TL00_04_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_TrafficLight_00_04_VFC_TL00_04_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficLight_00_04::VFC_TL00_04_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficLight_00_04::VFC_TL00_04_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_TrafficLight_00_04_VFC_TL00_04_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_TrafficLight_05_09::VFC_TrafficLight_05_09_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_TrafficLight_05_09);
     @CAN_PrivMain::VFC_TrafficLight_05_09::VFC_TrafficLight_05_09_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_TrafficLight_05_09(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_TrafficLight_05_09.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_TrafficLight_05_09.id;//Message ID
   
    if (@CAN_PrivMain::VFC_TrafficLight_05_09::VFC_TL05_09_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficLight_05_09::VFC_TL05_09_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_TrafficLight_05_09_VFC_TL05_09_AliveCtr;
      counter_VFC_TrafficLight_05_09_VFC_TL05_09_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_TrafficLight_05_09_VFC_TL05_09_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficLight_05_09::VFC_TL05_09_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficLight_05_09::VFC_TL05_09_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_TrafficLight_05_09_VFC_TL05_09_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficLight_05_09::VFC_TL05_09_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficLight_05_09::VFC_TL05_09_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_TrafficLight_05_09_VFC_TL05_09_ProtBlockCtr = bc_VFC_TrafficLight_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_TrafficLight_05_09_VFC_TL05_09_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficLight_05_09::VFC_TL05_09_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficLight_05_09::VFC_TL05_09_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_TrafficLight_05_09_VFC_TL05_09_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficLight_05_09::VFC_TL05_09_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_TrafficLight_05_09::VFC_TL05_09_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20e3 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20e3 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_TrafficLight_05_09_VFC_TL05_09_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_TrafficLight_05_09_VFC_TL05_09_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficLight_05_09::VFC_TL05_09_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficLight_05_09::VFC_TL05_09_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_TrafficLight_05_09_VFC_TL05_09_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_TrafficSignHdr::VFC_TrafficSignHdr_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_TrafficSignHdr);
     @CAN_PrivMain::VFC_TrafficSignHdr::VFC_TrafficSignHdr_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_TrafficSignHdr(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_TrafficSignHdr.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_TrafficSignHdr.id;//Message ID
   
    if (@CAN_PrivMain::VFC_TrafficSignHdr::VFC_TSHdr_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSignHdr::VFC_TSHdr_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_TrafficSignHdr_VFC_TSHdr_AliveCtr;
      counter_VFC_TrafficSignHdr_VFC_TSHdr_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_TrafficSignHdr_VFC_TSHdr_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSignHdr::VFC_TSHdr_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSignHdr::VFC_TSHdr_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_TrafficSignHdr_VFC_TSHdr_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSignHdr::VFC_TSHdr_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSignHdr::VFC_TSHdr_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      ++bc_VFC_TrafficSignHdr_VFC_TSHdr_ProtBlockCtr;
      bc_VFC_TrafficSignHdr_VFC_TSHdr_ProtBlockCtr %=16;
      bc_VFC_TrafficSign_ProtBlockCtr = bc_VFC_TrafficSignHdr_VFC_TSHdr_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_TrafficSignHdr_VFC_TSHdr_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSignHdr::VFC_TSHdr_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSignHdr::VFC_TSHdr_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_TrafficSignHdr_VFC_TSHdr_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }

    clearBitsInByteArrayLE(data,64,26); //Intel / little-endian

    //Msg_VFC_TrafficSignHdr.VFC_TSHdr_TimeStamp = @CAN_PrivMain::VFC_TrafficSignHdr::VFC_TSHdr_TimeStamp_FaultInject +(timeNowNS()/1000000);

      copyBitsToByteArrayLE(@CAN_PrivMain::VFC_TrafficSignHdr::VFC_TSHdr_TimeStamp_FaultInject +(timeNowNS()/1000000),data,64,26); //Intel / little-endian;
    if (@CAN_PrivMain::VFC_TrafficSignHdr::VFC_TSHdr_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_TrafficSignHdr::VFC_TSHdr_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20ec & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20ec & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_TrafficSignHdr_VFC_TSHdr_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_TrafficSignHdr_VFC_TSHdr_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSignHdr::VFC_TSHdr_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSignHdr::VFC_TSHdr_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_TrafficSignHdr_VFC_TSHdr_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_TrafficSign_00_01::VFC_TrafficSign_00_01_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_TrafficSign_00_01);
     @CAN_PrivMain::VFC_TrafficSign_00_01::VFC_TrafficSign_00_01_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_TrafficSign_00_01(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_TrafficSign_00_01.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_TrafficSign_00_01.id;//Message ID
   
    if (@CAN_PrivMain::VFC_TrafficSign_00_01::VFC_TS_00_01_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSign_00_01::VFC_TS_00_01_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_TrafficSign_00_01_VFC_TS_00_01_AliveCtr;
      counter_VFC_TrafficSign_00_01_VFC_TS_00_01_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_TrafficSign_00_01_VFC_TS_00_01_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_00_01::VFC_TS_00_01_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_00_01::VFC_TS_00_01_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_TrafficSign_00_01_VFC_TS_00_01_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSign_00_01::VFC_TS_00_01_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSign_00_01::VFC_TS_00_01_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_TrafficSign_00_01_VFC_TS_00_01_ProtBlockCtr = bc_VFC_TrafficSign_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_TrafficSign_00_01_VFC_TS_00_01_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_00_01::VFC_TS_00_01_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_00_01::VFC_TS_00_01_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_TrafficSign_00_01_VFC_TS_00_01_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSign_00_01::VFC_TS_00_01_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_TrafficSign_00_01::VFC_TS_00_01_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20ee & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20ee & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_TrafficSign_00_01_VFC_TS_00_01_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_TrafficSign_00_01_VFC_TS_00_01_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSign_00_01::VFC_TS_00_01_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSign_00_01::VFC_TS_00_01_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_TrafficSign_00_01_VFC_TS_00_01_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_TrafficSign_02_03::VFC_TrafficSign_02_03_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_TrafficSign_02_03);
     @CAN_PrivMain::VFC_TrafficSign_02_03::VFC_TrafficSign_02_03_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_TrafficSign_02_03(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_TrafficSign_02_03.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_TrafficSign_02_03.id;//Message ID
   
    if (@CAN_PrivMain::VFC_TrafficSign_02_03::VFC_TS_02_03_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSign_02_03::VFC_TS_02_03_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_TrafficSign_02_03_VFC_TS_02_03_AliveCtr;
      counter_VFC_TrafficSign_02_03_VFC_TS_02_03_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_TrafficSign_02_03_VFC_TS_02_03_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_02_03::VFC_TS_02_03_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_02_03::VFC_TS_02_03_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_TrafficSign_02_03_VFC_TS_02_03_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSign_02_03::VFC_TS_02_03_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSign_02_03::VFC_TS_02_03_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_TrafficSign_02_03_VFC_TS_02_03_ProtBlockCtr = bc_VFC_TrafficSign_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_TrafficSign_02_03_VFC_TS_02_03_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_02_03::VFC_TS_02_03_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_02_03::VFC_TS_02_03_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_TrafficSign_02_03_VFC_TS_02_03_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSign_02_03::VFC_TS_02_03_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_TrafficSign_02_03::VFC_TS_02_03_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20ef & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20ef & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_TrafficSign_02_03_VFC_TS_02_03_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_TrafficSign_02_03_VFC_TS_02_03_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSign_02_03::VFC_TS_02_03_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSign_02_03::VFC_TS_02_03_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_TrafficSign_02_03_VFC_TS_02_03_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_TrafficSign_04_05::VFC_TrafficSign_04_05_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_TrafficSign_04_05);
     @CAN_PrivMain::VFC_TrafficSign_04_05::VFC_TrafficSign_04_05_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_TrafficSign_04_05(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_TrafficSign_04_05.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_TrafficSign_04_05.id;//Message ID
   
    if (@CAN_PrivMain::VFC_TrafficSign_04_05::VFC_TS_04_05_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSign_04_05::VFC_TS_04_05_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_TrafficSign_04_05_VFC_TS_04_05_AliveCtr;
      counter_VFC_TrafficSign_04_05_VFC_TS_04_05_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_TrafficSign_04_05_VFC_TS_04_05_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_04_05::VFC_TS_04_05_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_04_05::VFC_TS_04_05_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_TrafficSign_04_05_VFC_TS_04_05_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSign_04_05::VFC_TS_04_05_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSign_04_05::VFC_TS_04_05_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_TrafficSign_04_05_VFC_TS_04_05_ProtBlockCtr = bc_VFC_TrafficSign_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_TrafficSign_04_05_VFC_TS_04_05_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_04_05::VFC_TS_04_05_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_04_05::VFC_TS_04_05_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_TrafficSign_04_05_VFC_TS_04_05_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSign_04_05::VFC_TS_04_05_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_TrafficSign_04_05::VFC_TS_04_05_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20f0 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20f0 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_TrafficSign_04_05_VFC_TS_04_05_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_TrafficSign_04_05_VFC_TS_04_05_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSign_04_05::VFC_TS_04_05_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSign_04_05::VFC_TS_04_05_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_TrafficSign_04_05_VFC_TS_04_05_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_TrafficSign_06_07::VFC_TrafficSign_06_07_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_TrafficSign_06_07);
     @CAN_PrivMain::VFC_TrafficSign_06_07::VFC_TrafficSign_06_07_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_TrafficSign_06_07(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_TrafficSign_06_07.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_TrafficSign_06_07.id;//Message ID
   
    if (@CAN_PrivMain::VFC_TrafficSign_06_07::VFC_TS_06_07_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSign_06_07::VFC_TS_06_07_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_TrafficSign_06_07_VFC_TS_06_07_AliveCtr;
      counter_VFC_TrafficSign_06_07_VFC_TS_06_07_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_TrafficSign_06_07_VFC_TS_06_07_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_06_07::VFC_TS_06_07_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_06_07::VFC_TS_06_07_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_TrafficSign_06_07_VFC_TS_06_07_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSign_06_07::VFC_TS_06_07_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSign_06_07::VFC_TS_06_07_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_TrafficSign_06_07_VFC_TS_06_07_ProtBlockCtr = bc_VFC_TrafficSign_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_TrafficSign_06_07_VFC_TS_06_07_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_06_07::VFC_TS_06_07_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_06_07::VFC_TS_06_07_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_TrafficSign_06_07_VFC_TS_06_07_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSign_06_07::VFC_TS_06_07_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_TrafficSign_06_07::VFC_TS_06_07_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20f1 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20f1 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_TrafficSign_06_07_VFC_TS_06_07_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_TrafficSign_06_07_VFC_TS_06_07_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSign_06_07::VFC_TS_06_07_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSign_06_07::VFC_TS_06_07_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_TrafficSign_06_07_VFC_TS_06_07_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_TrafficSign_08_09::VFC_TrafficSign_08_09_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_TrafficSign_08_09);
     @CAN_PrivMain::VFC_TrafficSign_08_09::VFC_TrafficSign_08_09_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_TrafficSign_08_09(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_TrafficSign_08_09.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_TrafficSign_08_09.id;//Message ID
   
    if (@CAN_PrivMain::VFC_TrafficSign_08_09::VFC_TS_08_09_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSign_08_09::VFC_TS_08_09_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_TrafficSign_08_09_VFC_TS_08_09_AliveCtr;
      counter_VFC_TrafficSign_08_09_VFC_TS_08_09_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_TrafficSign_08_09_VFC_TS_08_09_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_08_09::VFC_TS_08_09_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_08_09::VFC_TS_08_09_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_TrafficSign_08_09_VFC_TS_08_09_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSign_08_09::VFC_TS_08_09_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSign_08_09::VFC_TS_08_09_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_TrafficSign_08_09_VFC_TS_08_09_ProtBlockCtr = bc_VFC_TrafficSign_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_TrafficSign_08_09_VFC_TS_08_09_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_08_09::VFC_TS_08_09_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_08_09::VFC_TS_08_09_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_TrafficSign_08_09_VFC_TS_08_09_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSign_08_09::VFC_TS_08_09_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_TrafficSign_08_09::VFC_TS_08_09_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20f2 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20f2 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_TrafficSign_08_09_VFC_TS_08_09_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_TrafficSign_08_09_VFC_TS_08_09_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSign_08_09::VFC_TS_08_09_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSign_08_09::VFC_TS_08_09_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_TrafficSign_08_09_VFC_TS_08_09_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_TrafficSign_10_11::VFC_TrafficSign_10_11_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_TrafficSign_10_11);
     @CAN_PrivMain::VFC_TrafficSign_10_11::VFC_TrafficSign_10_11_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_TrafficSign_10_11(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_TrafficSign_10_11.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_TrafficSign_10_11.id;//Message ID
   
    if (@CAN_PrivMain::VFC_TrafficSign_10_11::VFC_TS_10_11_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSign_10_11::VFC_TS_10_11_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_TrafficSign_10_11_VFC_TS_10_11_AliveCtr;
      counter_VFC_TrafficSign_10_11_VFC_TS_10_11_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_TrafficSign_10_11_VFC_TS_10_11_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_10_11::VFC_TS_10_11_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_10_11::VFC_TS_10_11_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_TrafficSign_10_11_VFC_TS_10_11_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSign_10_11::VFC_TS_10_11_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSign_10_11::VFC_TS_10_11_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_TrafficSign_10_11_VFC_TS_10_11_ProtBlockCtr = bc_VFC_TrafficSign_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_TrafficSign_10_11_VFC_TS_10_11_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_10_11::VFC_TS_10_11_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_10_11::VFC_TS_10_11_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_TrafficSign_10_11_VFC_TS_10_11_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSign_10_11::VFC_TS_10_11_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_TrafficSign_10_11::VFC_TS_10_11_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20f3 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20f3 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_TrafficSign_10_11_VFC_TS_10_11_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_TrafficSign_10_11_VFC_TS_10_11_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSign_10_11::VFC_TS_10_11_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSign_10_11::VFC_TS_10_11_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_TrafficSign_10_11_VFC_TS_10_11_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_TrafficSign_12_13::VFC_TrafficSign_12_13_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_TrafficSign_12_13);
     @CAN_PrivMain::VFC_TrafficSign_12_13::VFC_TrafficSign_12_13_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_TrafficSign_12_13(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_TrafficSign_12_13.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_TrafficSign_12_13.id;//Message ID
   
    if (@CAN_PrivMain::VFC_TrafficSign_12_13::VFC_TS_12_13_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSign_12_13::VFC_TS_12_13_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_TrafficSign_12_13_VFC_TS_12_13_AliveCtr;
      counter_VFC_TrafficSign_12_13_VFC_TS_12_13_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_TrafficSign_12_13_VFC_TS_12_13_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_12_13::VFC_TS_12_13_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_12_13::VFC_TS_12_13_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_TrafficSign_12_13_VFC_TS_12_13_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSign_12_13::VFC_TS_12_13_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSign_12_13::VFC_TS_12_13_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_TrafficSign_12_13_VFC_TS_12_13_ProtBlockCtr = bc_VFC_TrafficSign_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_TrafficSign_12_13_VFC_TS_12_13_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_12_13::VFC_TS_12_13_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_12_13::VFC_TS_12_13_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_TrafficSign_12_13_VFC_TS_12_13_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSign_12_13::VFC_TS_12_13_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_TrafficSign_12_13::VFC_TS_12_13_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20f4 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20f4 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_TrafficSign_12_13_VFC_TS_12_13_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_TrafficSign_12_13_VFC_TS_12_13_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSign_12_13::VFC_TS_12_13_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSign_12_13::VFC_TS_12_13_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_TrafficSign_12_13_VFC_TS_12_13_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_PrivMain::VFC_TrafficSign_14_15::VFC_TrafficSign_14_15_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(VFC_TrafficSign_14_15);
     @CAN_PrivMain::VFC_TrafficSign_14_15::VFC_TrafficSign_14_15_ON_OFF = 0;
  }
}

void cfg_Msg_VFC_TrafficSign_14_15(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VFC_TrafficSign_14_15.DataLength;//Message Data Length
   Msg_id  = Msg_VFC_TrafficSign_14_15.id;//Message ID
   
    if (@CAN_PrivMain::VFC_TrafficSign_14_15::VFC_TS_14_15_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSign_14_15::VFC_TS_14_15_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VFC_TrafficSign_14_15_VFC_TS_14_15_AliveCtr;
      counter_VFC_TrafficSign_14_15_VFC_TS_14_15_AliveCtr %=256;

      copyBitsToByteArrayLE(counter_VFC_TrafficSign_14_15_VFC_TS_14_15_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_14_15::VFC_TS_14_15_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_14_15::VFC_TS_14_15_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VFC_TrafficSign_14_15_VFC_TS_14_15_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSign_14_15::VFC_TS_14_15_ProtBlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_PrivMain::VFC_TrafficSign_14_15::VFC_TS_14_15_ProtBlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      bc_VFC_TrafficSign_14_15_VFC_TS_14_15_ProtBlockCtr = bc_VFC_TrafficSign_ProtBlockCtr ;

      copyBitsToByteArrayLE(bc_VFC_TrafficSign_14_15_VFC_TS_14_15_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_14_15::VFC_TS_14_15_ProtBlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_PrivMain::VFC_TrafficSign_14_15::VFC_TS_14_15_ProtBlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_VFC_TrafficSign_14_15_VFC_TS_14_15_ProtBlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_PrivMain::VFC_TrafficSign_14_15::VFC_TS_14_15_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_PrivMain::VFC_TrafficSign_14_15::VFC_TS_14_15_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (0x20f5 & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (0x20f5 & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_VFC_TrafficSign_14_15_VFC_TS_14_15_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_VFC_TrafficSign_14_15_VFC_TS_14_15_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSign_14_15::VFC_TS_14_15_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_PrivMain::VFC_TrafficSign_14_15::VFC_TS_14_15_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_VFC_TrafficSign_14_15_VFC_TS_14_15_CRC,data,0,16); //Intel / little-endian;
    }
}


void FVideo_sim_SetCycleTimeOffset()
{

//  ILNodeSetPDUTimingCyclic (dbMsg dbMessage, long TrueOrFalse, long offset, long period, long disturbanceCount, long flags);
//  TrueOrFalse ; 0: denotes the False timing; 1: denotes the True timing; 3: denotes the True and the False timing.
//  offset :Defines the delay in [ms] from now when the first cyclic transmission will start.
//  period :Defines the period in [ms] for the cyclic transmission.
//  disturbanceCount :Reserved/unused; should be set to -1 (infinite).
//  flags :Reserved; should be set to 0.

}