/*@!Encoding:1252*/
/**
 * @file Rbs_CAN_ADAS.can
 * @author ADAS_HIL_TEAM
 * @date 10-04-2022
 * @brief 
 *
 * ################################################################
 * C O P Y R I G H T S
 * ----------------------------------------------------------------
 * Copyright (c) 2022-2023 by Robert Bosch GmbH. All rights reserved.
 
 * The reproduction, distribution and utilization of this file as
 * well as the communication of its contents to others without express
 * authorization is prohibited. Offenders will be held liable for the
 * payment of damages. All rights reserved in the event of the grant
 * of a patent, utility model or design.
 *
 * ################################################################
*/

// Autogenerated by -> Platform\Classe\Scripts\Rbs_Scripts\create_nodes.py
includes
{
  #pragma library ("C:\ProgramData\Vector\AddOn Packages\Vector AddOn\vModules\CANoeILNLVector.vmodule")
  #include "CAPL\DataHandling.cin" /*DataHandling for IL*/
  #include "CAPL\E2E.cin" /*OD Specific for CRC calculation */
}

variables {
  message ADAS_Position Msg_ADAS_Position;
  message ADAS_Segment Msg_ADAS_Segment;
  message ADAS_Stub Msg_ADAS_Stub;
  message ADAS_Profile_Short Msg_ADAS_Profile_Short;
  message ADAS_Profile_Long Msg_ADAS_Profile_Long;
  message ADAS_Metadata Msg_ADAS_Metadata;
  message ADASLong_Mux Msg_ADASLong_Mux;
  message ESP_0x116 Msg_ESP_0x116;
  message ESP_0x120 Msg_ESP_0x120;
  message MCU_F_0x150 Msg_MCU_F_0x150;
  message MCU_R_0x151 Msg_MCU_R_0x151;
  message APA_0x1B0 Msg_APA_0x1B0;
  message VCU_0x1BA Msg_VCU_0x1BA;
  message AFB_0x1BB Msg_AFB_0x1BB;
  message EPS_0x1C2 Msg_EPS_0x1C2;
  message EPS_0x1C4 Msg_EPS_0x1C4;
  message EPS2ADAS_0x1C5 Msg_EPS2ADAS_0x1C5;
  message VCU_0x214 Msg_VCU_0x214;
  message VCU_0x225 Msg_VCU_0x225;
  message YRS_0x242 Msg_YRS_0x242;
  message YRS_0x246 Msg_YRS_0x246;
  message ESP_0x261 Msg_ESP_0x261;
  message ESP_0x268 Msg_ESP_0x268;
  message iBooster_0x271 Msg_iBooster_0x271;
  message GW_HSC8_FrP16 Msg_GW_HSC8_FrP16;
  message ESP_0x305 Msg_ESP_0x305;
  message ESP_0x306 Msg_ESP_0x306;
  message CIM_0x310 Msg_CIM_0x310;
  message ESP_0x318 Msg_ESP_0x318;
  message SDM_0x319 Msg_SDM_0x319;
  message PEPS_0x333 Msg_PEPS_0x333;
  message BCM_0x335 Msg_BCM_0x335;
  message BCM_0x343 Msg_BCM_0x343;
  message ECC_0x373 Msg_ECC_0x373;
  message PT_VMI_01 Msg_PT_VMI_01;
  message EPS_0x475 Msg_EPS_0x475;
  message ADAS_0x4BB_HMI Msg_ADAS_0x4BB_HMI;
  message HMI_0x4BF_ADAS Msg_HMI_0x4BF_ADAS;
  message ICC_0x526 Msg_ICC_0x526;
  message ICC_0x531 Msg_ICC_0x531;
  message AEB_Status_0x5A0 Msg_AEB_Status_0x5A0;
  message RBFMain11 Msg_RBFMain11;
  message RBFMain12 Msg_RBFMain12;
  message VariantCoding Msg_VariantCoding;
  message DBC_Version Msg_DBC_Version;

  word counter_ESP_0x116_ESP_116_AliveCounter;
  word counter_ESP_0x120_ESP_120_AliveCounter;
  word counter_MCU_F_0x150_MCU_F_150_AliveCounter;
  word counter_MCU_R_0x151_MCU_R_151_AliveCounter;
  word counter_APA_0x1B0_APA_1B0_AliveCounter;
  word counter_VCU_0x1BA_VCU_1BA_AliveCounter;
  word counter_AFB_0x1BB_AFB_1BB_AliveCounter;
  word counter_EPS_0x1C2_EPS_1C2_AliveCounter;
  word counter_EPS_0x1C4_EPS_1C4_AliveCounter;
  word counter_EPS2ADAS_0x1C5_ADAS_1C5_AliveCounter;
  word counter_VCU_0x214_VCU_214_AliveCounter;
  word counter_VCU_0x225_VCU_225_AliveCounter;
  word counter_YRS_0x242_YRS_242_AliveCounter;
  word counter_YRS_0x246_YRS_246_AliveCounter;
  word counter_ESP_0x261_ESP_261_AliveCounter;
  word counter_ESP_0x268_ESP_268_AliveCounter;
  word counter_iBooster_0x271_iBooster_271_AliveCounter;
  word counter_GW_HSC8_FrP16_GW_FrP16_RolingCounter_h8HSC8;
  word counter_ESP_0x305_ESP_305_AliveCounter;
  word counter_ESP_0x306_ESP_306_AliveCounter;
  word counter_CIM_0x310_CIM_310_AliveCounter;
  word counter_ESP_0x318_ESP_318_AliveCounter;
  word counter_SDM_0x319_SDM_319_AliveCounter;
  word counter_PEPS_0x333_PEPS_333_AliveCounter;
  word counter_BCM_0x335_BCM_335_AliveCounter;
  word counter_BCM_0x343_BCM_343_AliveCounter;
  word counter_PT_VMI_01_PT_VMI_01_BZ;
  word counter_AEB_Status_0x5A0_AEB_Status_5A0_Alivecounter;
  word counter_RBFMain11_RBFMain11_AliveCounter;
  word counter_RBFMain12_RBFMain12_AliveCounter;

  byte chksum_ESP_0x116_ESP_116_CheckSum;
  byte chksum_ESP_0x120_ESP_120_CheckSum;
  byte chksum_MCU_F_0x150_MCU_F_150_CheckSum;
  byte chksum_MCU_R_0x151_MCU_R_151_CheckSum;
  byte chksum_APA_0x1B0_APA_1B0_CheckSum;
  byte chksum_VCU_0x1BA_VCU_1BA_CheckSum;
  byte chksum_AFB_0x1BB_AFB_1BB_CheckSum;
  byte chksum_EPS_0x1C2_EPS_1C2_CheckSum;
  byte chksum_EPS_0x1C4_EPS_1C4_CheckSum;
  byte chksum_EPS2ADAS_0x1C5_ADAS_1C5_CheckSum;
  byte chksum_VCU_0x214_VCU_214_CheckSum;
  byte chksum_VCU_0x225_VCU_225_CheckSum;
  byte chksum_YRS_0x242_YRS_242_CheckSum;
  byte chksum_YRS_0x246_YRS_246_CheckSum;
  byte chksum_ESP_0x261_ESP_261_CheckSum;
  byte chksum_ESP_0x268_ESP_268_CheckSum;
  byte chksum_iBooster_0x271_iBooster_271_CheckSum;
  byte chksum_GW_HSC8_FrP16_GW_FrP16_Checksum_h8HSC8;
  byte chksum_ESP_0x305_ESP_305_CheckSum;
  byte chksum_ESP_0x306_ESP_306_CheckSum;
  byte chksum_CIM_0x310_CIM_310_CheckSum;
  byte chksum_ESP_0x318_ESP_318_CheckSum;
  byte chksum_SDM_0x319_SDM_319_CheckSum;
  byte chksum_PEPS_0x333_PEPS_333_CheckSum;
  byte chksum_BCM_0x335_BCM_335_CheckSum;
  byte chksum_BCM_0x343_BCM_343_CheckSum;
  byte crc_PT_VMI_01_PT_VMI_01_CRC;
  byte chksum_HMI_0x4BF_ADAS_ACCplusActivationSubfeatureCSA;
  byte chksum_AEB_Status_0x5A0_AEB_Status_0x5A0_Checksum;
  byte chksum_RBFMain11_RBFMain11_Checksum;
  byte chksum_RBFMain12_RBFMain12_Checksum;

}

on preStart {
  long result;
  result=ILControlInit ();//Initialization of CANoe IL,to prevent the IL autostart function.
  switch(result)
  {
    case  0   : write("ILControlInit :: Rbs :: No error."); break;
    case -1   : write("ILControlInit :: Rbs :: Momentary state of the IL does not permit this query."); break;
    case -50  : write("ILControlInit :: Rbs :: Nodelayer is inactive - possibly deactivated in the nodes configuration dialog.");  break;
   }

  Rbs_sim_Disable();
  Rbs_sim_SetCycleTimeOffset();
}

on start {

  ILControlSimulationOn();//Starts the simulation of the IL.
  Rbs_sim_SetCANFDParameter();
  ILControlStart ();//Cyclical sending starts; setting signals is now possible.
  Rbs_sim_Reset();
}

on stopMeasurement {

  Rbs_sim_DisableMsg();
  Rbs_sim_Disable();
  ILControlStop();//Cyclical sending is stopped; setting signals is now no longer possible.
  ILControlSimulationOff();//Stops the simulation of the IL. After that no other function to control the IL has an effect to the IL.

}

on sysvar_update hil_ctrl::rbs_sim
{
  Rbs_sim_Reset();
}

on sysvar_update hil_ctrl::variant
{
  Rbs_sim_Reset();
}

on sysvar_update Cus_bus::bus_CAN_ADAS_ON_OFF
{
  Rbs_sim_Reset();
}

void Rbs_sim_Reset()
{

  Rbs_sim_DisableMsg();
  Rbs_sim_Disable();

  if ((@Cus_bus::bus_CAN_ADAS_ON_OFF == 1) && (@hil_ctrl::rbs_sim == 1))
  {
    switch(@hil_ctrl::variant)
    {
      case a_variant:Rbs_sim_start_a_variant();break;
      case b_variant:Rbs_sim_start_b_variant();break;
    }
    if (@hil_ctrl::hil_mode == @hil_ctrl::hil_mode::Restbus) 
    {
       Rbs_sim_EnableEventMsg();
    }
    else
    {
       Rbs_sim_DisableEventMsg();
    }
  }
}

void Rbs_sim_start_a_variant()
{
  @CAN_ADAS::ADAS_Position::ADAS_Position_ON_OFF = 1;
  @CAN_ADAS::ADAS_Metadata::ADAS_Metadata_ON_OFF = 1;
  @CAN_ADAS::ADASLong_Mux::ADASLong_Mux_ON_OFF = 1;
  @CAN_ADAS::ESP_0x116::ESP_0x116_ON_OFF = 1;
  @CAN_ADAS::ESP_0x120::ESP_0x120_ON_OFF = 1;
  @CAN_ADAS::MCU_F_0x150::MCU_F_0x150_ON_OFF = 1;
  @CAN_ADAS::MCU_R_0x151::MCU_R_0x151_ON_OFF = 1;
  @CAN_ADAS::APA_0x1B0::APA_0x1B0_ON_OFF = 1;
  @CAN_ADAS::VCU_0x1BA::VCU_0x1BA_ON_OFF = 1;
  @CAN_ADAS::AFB_0x1BB::AFB_0x1BB_ON_OFF = 1;
  @CAN_ADAS::EPS_0x1C2::EPS_0x1C2_ON_OFF = 1;
  @CAN_ADAS::EPS_0x1C4::EPS_0x1C4_ON_OFF = 1;
  @CAN_ADAS::EPS2ADAS_0x1C5::EPS2ADAS_0x1C5_ON_OFF = 1;
  @CAN_ADAS::VCU_0x214::VCU_0x214_ON_OFF = 1;
  @CAN_ADAS::VCU_0x225::VCU_0x225_ON_OFF = 1;
  @CAN_ADAS::YRS_0x242::YRS_0x242_ON_OFF = 1;
  @CAN_ADAS::YRS_0x246::YRS_0x246_ON_OFF = 1;
  @CAN_ADAS::ESP_0x261::ESP_0x261_ON_OFF = 1;
  @CAN_ADAS::ESP_0x268::ESP_0x268_ON_OFF = 1;
  @CAN_ADAS::iBooster_0x271::iBooster_0x271_ON_OFF = 1;
  @CAN_ADAS::GW_HSC8_FrP16::GW_HSC8_FrP16_ON_OFF = 1;
  @CAN_ADAS::ESP_0x305::ESP_0x305_ON_OFF = 1;
  @CAN_ADAS::ESP_0x306::ESP_0x306_ON_OFF = 1;
  @CAN_ADAS::CIM_0x310::CIM_0x310_ON_OFF = 1;
  @CAN_ADAS::ESP_0x318::ESP_0x318_ON_OFF = 1;
  @CAN_ADAS::SDM_0x319::SDM_0x319_ON_OFF = 1;
  @CAN_ADAS::PEPS_0x333::PEPS_0x333_ON_OFF = 1;
  @CAN_ADAS::BCM_0x335::BCM_0x335_ON_OFF = 1;
  @CAN_ADAS::BCM_0x343::BCM_0x343_ON_OFF = 1;
  @CAN_ADAS::ECC_0x373::ECC_0x373_ON_OFF = 1;
  @CAN_ADAS::PT_VMI_01::PT_VMI_01_ON_OFF = 1;
  @CAN_ADAS::EPS_0x475::EPS_0x475_ON_OFF = 1;
  @CAN_ADAS::ADAS_0x4BB_HMI::ADAS_0x4BB_HMI_ON_OFF = 1;
  @CAN_ADAS::HMI_0x4BF_ADAS::HMI_0x4BF_ADAS_ON_OFF = 1;
  @CAN_ADAS::ICC_0x526::ICC_0x526_ON_OFF = 1;
  @CAN_ADAS::ICC_0x531::ICC_0x531_ON_OFF = 1;
  @CAN_ADAS::AEB_Status_0x5A0::AEB_Status_0x5A0_ON_OFF = 1;
  @CAN_ADAS::RBFMain11::RBFMain11_ON_OFF = 1;
  @CAN_ADAS::RBFMain12::RBFMain12_ON_OFF = 1;
  @CAN_ADAS::VariantCoding::VariantCoding_ON_OFF = 1;
  @CAN_ADAS::DBC_Version::DBC_Version_ON_OFF = 1;
}

void Rbs_sim_start_b_variant()
{
  @CAN_ADAS::ADAS_Position::ADAS_Position_ON_OFF = 1;
  @CAN_ADAS::ADAS_Metadata::ADAS_Metadata_ON_OFF = 1;
  @CAN_ADAS::ADASLong_Mux::ADASLong_Mux_ON_OFF = 1;
  @CAN_ADAS::ESP_0x116::ESP_0x116_ON_OFF = 1;
  @CAN_ADAS::ESP_0x120::ESP_0x120_ON_OFF = 1;
  @CAN_ADAS::MCU_F_0x150::MCU_F_0x150_ON_OFF = 1;
  @CAN_ADAS::MCU_R_0x151::MCU_R_0x151_ON_OFF = 1;
  @CAN_ADAS::APA_0x1B0::APA_0x1B0_ON_OFF = 1;
  @CAN_ADAS::VCU_0x1BA::VCU_0x1BA_ON_OFF = 1;
  @CAN_ADAS::AFB_0x1BB::AFB_0x1BB_ON_OFF = 1;
  @CAN_ADAS::EPS_0x1C2::EPS_0x1C2_ON_OFF = 1;
  @CAN_ADAS::EPS_0x1C4::EPS_0x1C4_ON_OFF = 1;
  @CAN_ADAS::EPS2ADAS_0x1C5::EPS2ADAS_0x1C5_ON_OFF = 1;
  @CAN_ADAS::VCU_0x214::VCU_0x214_ON_OFF = 1;
  @CAN_ADAS::VCU_0x225::VCU_0x225_ON_OFF = 1;
  @CAN_ADAS::YRS_0x242::YRS_0x242_ON_OFF = 1;
  @CAN_ADAS::YRS_0x246::YRS_0x246_ON_OFF = 1;
  @CAN_ADAS::ESP_0x261::ESP_0x261_ON_OFF = 1;
  @CAN_ADAS::ESP_0x268::ESP_0x268_ON_OFF = 1;
  @CAN_ADAS::iBooster_0x271::iBooster_0x271_ON_OFF = 1;
  @CAN_ADAS::GW_HSC8_FrP16::GW_HSC8_FrP16_ON_OFF = 1;
  @CAN_ADAS::ESP_0x305::ESP_0x305_ON_OFF = 1;
  @CAN_ADAS::ESP_0x306::ESP_0x306_ON_OFF = 1;
  @CAN_ADAS::CIM_0x310::CIM_0x310_ON_OFF = 1;
  @CAN_ADAS::ESP_0x318::ESP_0x318_ON_OFF = 1;
  @CAN_ADAS::SDM_0x319::SDM_0x319_ON_OFF = 1;
  @CAN_ADAS::PEPS_0x333::PEPS_0x333_ON_OFF = 1;
  @CAN_ADAS::BCM_0x335::BCM_0x335_ON_OFF = 1;
  @CAN_ADAS::BCM_0x343::BCM_0x343_ON_OFF = 1;
  @CAN_ADAS::ECC_0x373::ECC_0x373_ON_OFF = 1;
  @CAN_ADAS::PT_VMI_01::PT_VMI_01_ON_OFF = 1;
  @CAN_ADAS::EPS_0x475::EPS_0x475_ON_OFF = 1;
  @CAN_ADAS::ADAS_0x4BB_HMI::ADAS_0x4BB_HMI_ON_OFF = 1;
  @CAN_ADAS::HMI_0x4BF_ADAS::HMI_0x4BF_ADAS_ON_OFF = 1;
  @CAN_ADAS::ICC_0x526::ICC_0x526_ON_OFF = 1;
  @CAN_ADAS::ICC_0x531::ICC_0x531_ON_OFF = 1;
  @CAN_ADAS::AEB_Status_0x5A0::AEB_Status_0x5A0_ON_OFF = 1;
  @CAN_ADAS::RBFMain11::RBFMain11_ON_OFF = 1;
  @CAN_ADAS::RBFMain12::RBFMain12_ON_OFF = 1;
  @CAN_ADAS::VariantCoding::VariantCoding_ON_OFF = 1;
  @CAN_ADAS::DBC_Version::DBC_Version_ON_OFF = 1;
}

void Rbs_sim_Disable()
{
  @CAN_ADAS::ADAS_Position::ADAS_Position_ON_OFF = 0;
  @CAN_ADAS::ADAS_Segment::ADAS_Segment_ON_OFF = 0;
  @CAN_ADAS::ADAS_Stub::ADAS_Stub_ON_OFF = 0;
  @CAN_ADAS::ADAS_Profile_Short::ADAS_Profile_Short_ON_OFF = 0;
  @CAN_ADAS::ADAS_Profile_Long::ADAS_Profile_Long_ON_OFF = 0;
  @CAN_ADAS::ADAS_Metadata::ADAS_Metadata_ON_OFF = 0;
  @CAN_ADAS::ADASLong_Mux::ADASLong_Mux_ON_OFF = 0;
  @CAN_ADAS::ESP_0x116::ESP_0x116_ON_OFF = 0;
  @CAN_ADAS::ESP_0x120::ESP_0x120_ON_OFF = 0;
  @CAN_ADAS::MCU_F_0x150::MCU_F_0x150_ON_OFF = 0;
  @CAN_ADAS::MCU_R_0x151::MCU_R_0x151_ON_OFF = 0;
  @CAN_ADAS::APA_0x1B0::APA_0x1B0_ON_OFF = 0;
  @CAN_ADAS::VCU_0x1BA::VCU_0x1BA_ON_OFF = 0;
  @CAN_ADAS::AFB_0x1BB::AFB_0x1BB_ON_OFF = 0;
  @CAN_ADAS::EPS_0x1C2::EPS_0x1C2_ON_OFF = 0;
  @CAN_ADAS::EPS_0x1C4::EPS_0x1C4_ON_OFF = 0;
  @CAN_ADAS::EPS2ADAS_0x1C5::EPS2ADAS_0x1C5_ON_OFF = 0;
  @CAN_ADAS::VCU_0x214::VCU_0x214_ON_OFF = 0;
  @CAN_ADAS::VCU_0x225::VCU_0x225_ON_OFF = 0;
  @CAN_ADAS::YRS_0x242::YRS_0x242_ON_OFF = 0;
  @CAN_ADAS::YRS_0x246::YRS_0x246_ON_OFF = 0;
  @CAN_ADAS::ESP_0x261::ESP_0x261_ON_OFF = 0;
  @CAN_ADAS::ESP_0x268::ESP_0x268_ON_OFF = 0;
  @CAN_ADAS::iBooster_0x271::iBooster_0x271_ON_OFF = 0;
  @CAN_ADAS::GW_HSC8_FrP16::GW_HSC8_FrP16_ON_OFF = 0;
  @CAN_ADAS::ESP_0x305::ESP_0x305_ON_OFF = 0;
  @CAN_ADAS::ESP_0x306::ESP_0x306_ON_OFF = 0;
  @CAN_ADAS::CIM_0x310::CIM_0x310_ON_OFF = 0;
  @CAN_ADAS::ESP_0x318::ESP_0x318_ON_OFF = 0;
  @CAN_ADAS::SDM_0x319::SDM_0x319_ON_OFF = 0;
  @CAN_ADAS::PEPS_0x333::PEPS_0x333_ON_OFF = 0;
  @CAN_ADAS::BCM_0x335::BCM_0x335_ON_OFF = 0;
  @CAN_ADAS::BCM_0x343::BCM_0x343_ON_OFF = 0;
  @CAN_ADAS::ECC_0x373::ECC_0x373_ON_OFF = 0;
  @CAN_ADAS::PT_VMI_01::PT_VMI_01_ON_OFF = 0;
  @CAN_ADAS::EPS_0x475::EPS_0x475_ON_OFF = 0;
  @CAN_ADAS::ADAS_0x4BB_HMI::ADAS_0x4BB_HMI_ON_OFF = 0;
  @CAN_ADAS::HMI_0x4BF_ADAS::HMI_0x4BF_ADAS_ON_OFF = 0;
  @CAN_ADAS::ICC_0x526::ICC_0x526_ON_OFF = 0;
  @CAN_ADAS::ICC_0x531::ICC_0x531_ON_OFF = 0;
  @CAN_ADAS::AEB_Status_0x5A0::AEB_Status_0x5A0_ON_OFF = 0;
  @CAN_ADAS::RBFMain11::RBFMain11_ON_OFF = 0;
  @CAN_ADAS::RBFMain12::RBFMain12_ON_OFF = 0;
  @CAN_ADAS::VariantCoding::VariantCoding_ON_OFF = 0;
  @CAN_ADAS::DBC_Version::DBC_Version_ON_OFF = 0;
}

void Rbs_sim_DisableMsg()
{
   ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_Position);
   ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_Segment);
   ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_Stub);
   ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_Profile_Short);
   ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_Profile_Long);
   ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_Metadata);
   ILFaultInjectionDisableMsg(CAN_ADAS::ADASLong_Mux);
   ILFaultInjectionDisableMsg(CAN_ADAS::ESP_0x116);
   ILFaultInjectionDisableMsg(CAN_ADAS::ESP_0x120);
   ILFaultInjectionDisableMsg(CAN_ADAS::MCU_F_0x150);
   ILFaultInjectionDisableMsg(CAN_ADAS::MCU_R_0x151);
   ILFaultInjectionDisableMsg(CAN_ADAS::APA_0x1B0);
   ILFaultInjectionDisableMsg(CAN_ADAS::VCU_0x1BA);
   ILFaultInjectionDisableMsg(CAN_ADAS::AFB_0x1BB);
   ILFaultInjectionDisableMsg(CAN_ADAS::EPS_0x1C2);
   ILFaultInjectionDisableMsg(CAN_ADAS::EPS_0x1C4);
   ILFaultInjectionDisableMsg(CAN_ADAS::EPS2ADAS_0x1C5);
   ILFaultInjectionDisableMsg(CAN_ADAS::TimeSync);
   ILFaultInjectionDisableMsg(CAN_ADAS::VCU_0x214);
   ILFaultInjectionDisableMsg(CAN_ADAS::VCU_0x225);
   ILFaultInjectionDisableMsg(CAN_ADAS::YRS_0x242);
   ILFaultInjectionDisableMsg(CAN_ADAS::YRS_0x246);
   ILFaultInjectionDisableMsg(CAN_ADAS::ESP_0x261);
   ILFaultInjectionDisableMsg(CAN_ADAS::ESP_0x268);
   ILFaultInjectionDisableMsg(CAN_ADAS::iBooster_0x271);
   ILFaultInjectionDisableMsg(CAN_ADAS::GW_HSC8_FrP16);
   ILFaultInjectionDisableMsg(CAN_ADAS::ESP_0x305);
   ILFaultInjectionDisableMsg(CAN_ADAS::ESP_0x306);
   ILFaultInjectionDisableMsg(CAN_ADAS::CIM_0x310);
   ILFaultInjectionDisableMsg(CAN_ADAS::ESP_0x318);
   ILFaultInjectionDisableMsg(CAN_ADAS::SDM_0x319);
   ILFaultInjectionDisableMsg(CAN_ADAS::PEPS_0x333);
   ILFaultInjectionDisableMsg(CAN_ADAS::BCM_0x335);
   ILFaultInjectionDisableMsg(CAN_ADAS::BCM_0x343);
   ILFaultInjectionDisableMsg(CAN_ADAS::ECC_0x373);
   ILFaultInjectionDisableMsg(CAN_ADAS::PT_VMI_01);
   ILFaultInjectionDisableMsg(CAN_ADAS::EPS_0x475);
   ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_0x4BB_HMI);
   ILFaultInjectionDisableMsg(CAN_ADAS::HMI_0x4BF_ADAS);
   ILFaultInjectionDisableMsg(CAN_ADAS::ICC_0x526);
   ILFaultInjectionDisableMsg(CAN_ADAS::ICC_0x531);
   ILFaultInjectionDisableMsg(CAN_ADAS::AEB_Status_0x5A0);
   ILFaultInjectionDisableMsg(CAN_ADAS::RBFMain11);
   ILFaultInjectionDisableMsg(CAN_ADAS::RBFMain12);
   ILFaultInjectionDisableMsg(CAN_ADAS::VariantCoding);
   ILFaultInjectionDisableMsg(CAN_ADAS::DBC_Version);
   ILFaultInjectionDisableMsg(CAN_ADAS::SW_ID_Video);
}
on sysvar hil_ctrl::hil_mode
{
  Rbs_sim_Reset();
}

void Rbs_sim_DisableEventMsg()
{
   ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_Segment);
   ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_Stub);
   ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_Profile_Short);
   ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_Profile_Long);

}

void Rbs_sim_EnableEventMsg()
{
   ILFaultInjectionEnableMsg(CAN_ADAS::ADAS_Segment);
   ILFaultInjectionEnableMsg(CAN_ADAS::ADAS_Stub);
   ILFaultInjectionEnableMsg(CAN_ADAS::ADAS_Profile_Short);
   ILFaultInjectionEnableMsg(CAN_ADAS::ADAS_Profile_Long);

}
void Rbs_sim_SetCANParameter()
{
  //For future purpose
  //ILFaultInjectionSetMsgDlc(dbMsg msg, dword dlc)
  //ILFaultInjectionSetMsgLength(dbMsg msg, dword msgLength)
  //ILFaultInjectionResetMsgDlc(dbMsg msg)
  //ILFaultInjectionResetMsgLength (dbMsg msg)
}

void Rbs_sim_SetCANFDParameter()
{
   //CAN FD Parameter Setting
   int FDF =1;
   int BRS =1;
   ILSetCANFDParam(CAN_ADAS::ADAS_Position,FDF,BRS,CAN_ADAS::ADAS_Position.dlc);
   ILSetCANFDParam(CAN_ADAS::ADAS_Segment,FDF,BRS,CAN_ADAS::ADAS_Segment.dlc);
   ILSetCANFDParam(CAN_ADAS::ADAS_Stub,FDF,BRS,CAN_ADAS::ADAS_Stub.dlc);
   ILSetCANFDParam(CAN_ADAS::ADAS_Profile_Short,FDF,BRS,CAN_ADAS::ADAS_Profile_Short.dlc);
   ILSetCANFDParam(CAN_ADAS::ADAS_Profile_Long,FDF,BRS,CAN_ADAS::ADAS_Profile_Long.dlc);
   ILSetCANFDParam(CAN_ADAS::ADAS_Metadata,FDF,BRS,CAN_ADAS::ADAS_Metadata.dlc);
   ILSetCANFDParam(CAN_ADAS::ADASLong_Mux,FDF,BRS,CAN_ADAS::ADASLong_Mux.dlc);
   ILSetCANFDParam(CAN_ADAS::ESP_0x116,FDF,BRS,CAN_ADAS::ESP_0x116.dlc);
   ILSetCANFDParam(CAN_ADAS::ESP_0x120,FDF,BRS,CAN_ADAS::ESP_0x120.dlc);
   ILSetCANFDParam(CAN_ADAS::MCU_F_0x150,FDF,BRS,CAN_ADAS::MCU_F_0x150.dlc);
   ILSetCANFDParam(CAN_ADAS::MCU_R_0x151,FDF,BRS,CAN_ADAS::MCU_R_0x151.dlc);
   ILSetCANFDParam(CAN_ADAS::APA_0x1B0,FDF,BRS,CAN_ADAS::APA_0x1B0.dlc);
   ILSetCANFDParam(CAN_ADAS::VCU_0x1BA,FDF,BRS,CAN_ADAS::VCU_0x1BA.dlc);
   ILSetCANFDParam(CAN_ADAS::AFB_0x1BB,FDF,BRS,CAN_ADAS::AFB_0x1BB.dlc);
   ILSetCANFDParam(CAN_ADAS::EPS_0x1C2,FDF,BRS,CAN_ADAS::EPS_0x1C2.dlc);
   ILSetCANFDParam(CAN_ADAS::EPS_0x1C4,FDF,BRS,CAN_ADAS::EPS_0x1C4.dlc);
   ILSetCANFDParam(CAN_ADAS::EPS2ADAS_0x1C5,FDF,BRS,CAN_ADAS::EPS2ADAS_0x1C5.dlc);
   ILSetCANFDParam(CAN_ADAS::VCU_0x214,FDF,BRS,CAN_ADAS::VCU_0x214.dlc);
   ILSetCANFDParam(CAN_ADAS::VCU_0x225,FDF,BRS,CAN_ADAS::VCU_0x225.dlc);
   ILSetCANFDParam(CAN_ADAS::YRS_0x242,FDF,BRS,CAN_ADAS::YRS_0x242.dlc);
   ILSetCANFDParam(CAN_ADAS::YRS_0x246,FDF,BRS,CAN_ADAS::YRS_0x246.dlc);
   ILSetCANFDParam(CAN_ADAS::ESP_0x261,FDF,BRS,CAN_ADAS::ESP_0x261.dlc);
   ILSetCANFDParam(CAN_ADAS::ESP_0x268,FDF,BRS,CAN_ADAS::ESP_0x268.dlc);
   ILSetCANFDParam(CAN_ADAS::iBooster_0x271,FDF,BRS,CAN_ADAS::iBooster_0x271.dlc);
   ILSetCANFDParam(CAN_ADAS::GW_HSC8_FrP16,FDF,BRS,CAN_ADAS::GW_HSC8_FrP16.dlc);
   ILSetCANFDParam(CAN_ADAS::ESP_0x305,FDF,BRS,CAN_ADAS::ESP_0x305.dlc);
   ILSetCANFDParam(CAN_ADAS::ESP_0x306,FDF,BRS,CAN_ADAS::ESP_0x306.dlc);
   ILSetCANFDParam(CAN_ADAS::CIM_0x310,FDF,BRS,CAN_ADAS::CIM_0x310.dlc);
   ILSetCANFDParam(CAN_ADAS::ESP_0x318,FDF,BRS,CAN_ADAS::ESP_0x318.dlc);
   ILSetCANFDParam(CAN_ADAS::SDM_0x319,FDF,BRS,CAN_ADAS::SDM_0x319.dlc);
   ILSetCANFDParam(CAN_ADAS::PEPS_0x333,FDF,BRS,CAN_ADAS::PEPS_0x333.dlc);
   ILSetCANFDParam(CAN_ADAS::BCM_0x335,FDF,BRS,CAN_ADAS::BCM_0x335.dlc);
   ILSetCANFDParam(CAN_ADAS::BCM_0x343,FDF,BRS,CAN_ADAS::BCM_0x343.dlc);
   ILSetCANFDParam(CAN_ADAS::ECC_0x373,FDF,BRS,CAN_ADAS::ECC_0x373.dlc);
   ILSetCANFDParam(CAN_ADAS::PT_VMI_01,FDF,BRS,CAN_ADAS::PT_VMI_01.dlc);
   ILSetCANFDParam(CAN_ADAS::EPS_0x475,FDF,BRS,CAN_ADAS::EPS_0x475.dlc);
   ILSetCANFDParam(CAN_ADAS::ADAS_0x4BB_HMI,FDF,BRS,CAN_ADAS::ADAS_0x4BB_HMI.dlc);
   ILSetCANFDParam(CAN_ADAS::HMI_0x4BF_ADAS,FDF,BRS,CAN_ADAS::HMI_0x4BF_ADAS.dlc);
   ILSetCANFDParam(CAN_ADAS::ICC_0x526,FDF,BRS,CAN_ADAS::ICC_0x526.dlc);
   ILSetCANFDParam(CAN_ADAS::ICC_0x531,FDF,BRS,CAN_ADAS::ICC_0x531.dlc);
   ILSetCANFDParam(CAN_ADAS::AEB_Status_0x5A0,FDF,BRS,CAN_ADAS::AEB_Status_0x5A0.dlc);
   ILSetCANFDParam(CAN_ADAS::RBFMain11,FDF,BRS,CAN_ADAS::RBFMain11.dlc);
   ILSetCANFDParam(CAN_ADAS::RBFMain12,FDF,BRS,CAN_ADAS::RBFMain12.dlc);
   ILSetCANFDParam(CAN_ADAS::VariantCoding,FDF,BRS,CAN_ADAS::VariantCoding.dlc);
   ILSetCANFDParam(CAN_ADAS::DBC_Version,FDF,BRS,CAN_ADAS::DBC_Version.dlc);
}

dword applILTxPending (long aId, dword aDlc, byte data[])//This callback is being called before the IL sends a message to the bus
{
  switch(aId)
  {
    case CAN_ADAS::ADAS_Position.id:cfg_Msg_ADAS_Position(aDlc, data);break;
    case CAN_ADAS::ADAS_Segment.id:cfg_Msg_ADAS_Segment(aDlc, data);break;
    case CAN_ADAS::ADAS_Stub.id:cfg_Msg_ADAS_Stub(aDlc, data);break;
    case CAN_ADAS::ADAS_Profile_Short.id:cfg_Msg_ADAS_Profile_Short(aDlc, data);break;
    case CAN_ADAS::ADAS_Profile_Long.id:cfg_Msg_ADAS_Profile_Long(aDlc, data);break;
    case CAN_ADAS::ADAS_Metadata.id:cfg_Msg_ADAS_Metadata(aDlc, data);break;
    case CAN_ADAS::ADASLong_Mux.id:cfg_Msg_ADASLong_Mux(aDlc, data);break;
    case CAN_ADAS::ESP_0x116.id:cfg_Msg_ESP_0x116(aDlc, data);break;
    case CAN_ADAS::ESP_0x120.id:cfg_Msg_ESP_0x120(aDlc, data);break;
    case CAN_ADAS::MCU_F_0x150.id:cfg_Msg_MCU_F_0x150(aDlc, data);break;
    case CAN_ADAS::MCU_R_0x151.id:cfg_Msg_MCU_R_0x151(aDlc, data);break;
    case CAN_ADAS::APA_0x1B0.id:cfg_Msg_APA_0x1B0(aDlc, data);break;
    case CAN_ADAS::VCU_0x1BA.id:cfg_Msg_VCU_0x1BA(aDlc, data);break;
    case CAN_ADAS::AFB_0x1BB.id:cfg_Msg_AFB_0x1BB(aDlc, data);break;
    case CAN_ADAS::EPS_0x1C2.id:cfg_Msg_EPS_0x1C2(aDlc, data);break;
    case CAN_ADAS::EPS_0x1C4.id:cfg_Msg_EPS_0x1C4(aDlc, data);break;
    case CAN_ADAS::EPS2ADAS_0x1C5.id:cfg_Msg_EPS2ADAS_0x1C5(aDlc, data);break;
    case CAN_ADAS::VCU_0x214.id:cfg_Msg_VCU_0x214(aDlc, data);break;
    case CAN_ADAS::VCU_0x225.id:cfg_Msg_VCU_0x225(aDlc, data);break;
    case CAN_ADAS::YRS_0x242.id:cfg_Msg_YRS_0x242(aDlc, data);break;
    case CAN_ADAS::YRS_0x246.id:cfg_Msg_YRS_0x246(aDlc, data);break;
    case CAN_ADAS::ESP_0x261.id:cfg_Msg_ESP_0x261(aDlc, data);break;
    case CAN_ADAS::ESP_0x268.id:cfg_Msg_ESP_0x268(aDlc, data);break;
    case CAN_ADAS::iBooster_0x271.id:cfg_Msg_iBooster_0x271(aDlc, data);break;
    case CAN_ADAS::GW_HSC8_FrP16.id:cfg_Msg_GW_HSC8_FrP16(aDlc, data);break;
    case CAN_ADAS::ESP_0x305.id:cfg_Msg_ESP_0x305(aDlc, data);break;
    case CAN_ADAS::ESP_0x306.id:cfg_Msg_ESP_0x306(aDlc, data);break;
    case CAN_ADAS::CIM_0x310.id:cfg_Msg_CIM_0x310(aDlc, data);break;
    case CAN_ADAS::ESP_0x318.id:cfg_Msg_ESP_0x318(aDlc, data);break;
    case CAN_ADAS::SDM_0x319.id:cfg_Msg_SDM_0x319(aDlc, data);break;
    case CAN_ADAS::PEPS_0x333.id:cfg_Msg_PEPS_0x333(aDlc, data);break;
    case CAN_ADAS::BCM_0x335.id:cfg_Msg_BCM_0x335(aDlc, data);break;
    case CAN_ADAS::BCM_0x343.id:cfg_Msg_BCM_0x343(aDlc, data);break;
    case CAN_ADAS::ECC_0x373.id:cfg_Msg_ECC_0x373(aDlc, data);break;
    case CAN_ADAS::PT_VMI_01.id:cfg_Msg_PT_VMI_01(aDlc, data);break;
    case CAN_ADAS::EPS_0x475.id:cfg_Msg_EPS_0x475(aDlc, data);break;
    case CAN_ADAS::ADAS_0x4BB_HMI.id:cfg_Msg_ADAS_0x4BB_HMI(aDlc, data);break;
    case CAN_ADAS::HMI_0x4BF_ADAS.id:cfg_Msg_HMI_0x4BF_ADAS(aDlc, data);break;
    case CAN_ADAS::ICC_0x526.id:cfg_Msg_ICC_0x526(aDlc, data);break;
    case CAN_ADAS::ICC_0x531.id:cfg_Msg_ICC_0x531(aDlc, data);break;
    case CAN_ADAS::AEB_Status_0x5A0.id:cfg_Msg_AEB_Status_0x5A0(aDlc, data);break;
    case CAN_ADAS::RBFMain11.id:cfg_Msg_RBFMain11(aDlc, data);break;
    case CAN_ADAS::RBFMain12.id:cfg_Msg_RBFMain12(aDlc, data);break;
    case CAN_ADAS::VariantCoding.id:cfg_Msg_VariantCoding(aDlc, data);break;
    case CAN_ADAS::DBC_Version.id:cfg_Msg_DBC_Version(aDlc, data);break;
    default :;//write("Node:Rbs ::No Cyclic event");
           break;
  }
  return 1; // don't prevent sending of the message
}

on sysvar CAN_ADAS::ADASLong_Mux::ADASLong_Mux_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ADASLong_Mux);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ADASLong_Mux);
      }
}

void cfg_Msg_ADASLong_Mux(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ADASLong_Mux.DataLength;//Message Data Length
   Msg_id  = Msg_ADASLong_Mux.id;//Message ID
   
}


on sysvar CAN_ADAS::ADAS_0x4BB_HMI::ADAS_0x4BB_HMI_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ADAS_0x4BB_HMI);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_0x4BB_HMI);
      }
}

void cfg_Msg_ADAS_0x4BB_HMI(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ADAS_0x4BB_HMI.DataLength;//Message Data Length
   Msg_id  = Msg_ADAS_0x4BB_HMI.id;//Message ID
   
}


on sysvar CAN_ADAS::ADAS_Metadata::ADAS_Metadata_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ADAS_Metadata);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_Metadata);
      }
}

void cfg_Msg_ADAS_Metadata(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ADAS_Metadata.DataLength;//Message Data Length
   Msg_id  = Msg_ADAS_Metadata.id;//Message ID
   
}


on sysvar CAN_ADAS::ADAS_Position::ADAS_Position_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ADAS_Position);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_Position);
      }
}

void cfg_Msg_ADAS_Position(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ADAS_Position.DataLength;//Message Data Length
   Msg_id  = Msg_ADAS_Position.id;//Message ID
   
}


on sysvar CAN_ADAS::ADAS_Profile_Long::ADAS_Profile_Long_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(CAN_ADAS::ADAS_Profile_Long);
     @CAN_ADAS::ADAS_Profile_Long::ADAS_Profile_Long_ON_OFF = 0;
  }
}

void cfg_Msg_ADAS_Profile_Long(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ADAS_Profile_Long.DataLength;//Message Data Length
   Msg_id  = Msg_ADAS_Profile_Long.id;//Message ID
   
}


on sysvar CAN_ADAS::ADAS_Profile_Short::ADAS_Profile_Short_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(CAN_ADAS::ADAS_Profile_Short);
     @CAN_ADAS::ADAS_Profile_Short::ADAS_Profile_Short_ON_OFF = 0;
  }
}

void cfg_Msg_ADAS_Profile_Short(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ADAS_Profile_Short.DataLength;//Message Data Length
   Msg_id  = Msg_ADAS_Profile_Short.id;//Message ID
   
}


on sysvar CAN_ADAS::ADAS_Segment::ADAS_Segment_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(CAN_ADAS::ADAS_Segment);
     @CAN_ADAS::ADAS_Segment::ADAS_Segment_ON_OFF = 0;
  }
}

void cfg_Msg_ADAS_Segment(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ADAS_Segment.DataLength;//Message Data Length
   Msg_id  = Msg_ADAS_Segment.id;//Message ID
   
}


on sysvar CAN_ADAS::ADAS_Stub::ADAS_Stub_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(CAN_ADAS::ADAS_Stub);
     @CAN_ADAS::ADAS_Stub::ADAS_Stub_ON_OFF = 0;
  }
}

void cfg_Msg_ADAS_Stub(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ADAS_Stub.DataLength;//Message Data Length
   Msg_id  = Msg_ADAS_Stub.id;//Message ID
   
}


on sysvar CAN_ADAS::AEB_Status_0x5A0::AEB_Status_0x5A0_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::AEB_Status_0x5A0);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::AEB_Status_0x5A0);
      }
}

void cfg_Msg_AEB_Status_0x5A0(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_AEB_Status_0x5A0.DataLength;//Message Data Length
   Msg_id  = Msg_AEB_Status_0x5A0.id;//Message ID
   
    if (@CAN_ADAS::AEB_Status_0x5A0::AEB_Status_5A0_Alivecounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_ADAS::AEB_Status_0x5A0::AEB_Status_5A0_Alivecounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_AEB_Status_0x5A0_AEB_Status_5A0_Alivecounter;
      counter_AEB_Status_0x5A0_AEB_Status_5A0_Alivecounter %=15;

      copyBitsToByteArrayLE(counter_AEB_Status_0x5A0_AEB_Status_5A0_Alivecounter,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::AEB_Status_0x5A0::AEB_Status_5A0_Alivecounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::AEB_Status_0x5A0::AEB_Status_5A0_Alivecounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_AEB_Status_0x5A0_AEB_Status_5A0_Alivecounter,data,8,4); //Intel / little-endian;
    }
    if (@CAN_ADAS::AEB_Status_0x5A0::AEB_Status_0x5A0_Checksum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_ADAS::AEB_Status_0x5A0::AEB_Status_0x5A0_Checksum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_AEB_Status_0x5A0_AEB_Status_0x5A0_Checksum = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(chksum_AEB_Status_0x5A0_AEB_Status_0x5A0_Checksum,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ADAS::AEB_Status_0x5A0::AEB_Status_0x5A0_Checksum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ADAS::AEB_Status_0x5A0::AEB_Status_0x5A0_Checksum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(chksum_AEB_Status_0x5A0_AEB_Status_0x5A0_Checksum,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::AFB_0x1BB::AFB_0x1BB_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::AFB_0x1BB);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::AFB_0x1BB);
      }
}

void cfg_Msg_AFB_0x1BB(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_AFB_0x1BB.DataLength;//Message Data Length
   Msg_id  = Msg_AFB_0x1BB.id;//Message ID
   
    if (@CAN_ADAS::AFB_0x1BB::AFB_1BB_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::AFB_0x1BB::AFB_1BB_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_AFB_0x1BB_AFB_1BB_AliveCounter;
      counter_AFB_0x1BB_AFB_1BB_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_AFB_0x1BB_AFB_1BB_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::AFB_0x1BB::AFB_1BB_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::AFB_0x1BB::AFB_1BB_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_AFB_0x1BB_AFB_1BB_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::AFB_0x1BB::AFB_1BB_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::AFB_0x1BB::AFB_1BB_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_AFB_0x1BB_AFB_1BB_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_AFB_0x1BB_AFB_1BB_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::AFB_0x1BB::AFB_1BB_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::AFB_0x1BB::AFB_1BB_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_AFB_0x1BB_AFB_1BB_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::APA_0x1B0::APA_0x1B0_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::APA_0x1B0);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::APA_0x1B0);
      }
}

void cfg_Msg_APA_0x1B0(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_APA_0x1B0.DataLength;//Message Data Length
   Msg_id  = Msg_APA_0x1B0.id;//Message ID
   
    if (@CAN_ADAS::APA_0x1B0::APA_1B0_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::APA_0x1B0::APA_1B0_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_APA_0x1B0_APA_1B0_AliveCounter;
      counter_APA_0x1B0_APA_1B0_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_APA_0x1B0_APA_1B0_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::APA_0x1B0::APA_1B0_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::APA_0x1B0::APA_1B0_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_APA_0x1B0_APA_1B0_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::APA_0x1B0::APA_1B0_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::APA_0x1B0::APA_1B0_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_APA_0x1B0_APA_1B0_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_APA_0x1B0_APA_1B0_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::APA_0x1B0::APA_1B0_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::APA_0x1B0::APA_1B0_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_APA_0x1B0_APA_1B0_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::BCM_0x335::BCM_0x335_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::BCM_0x335);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::BCM_0x335);
      }
}

void cfg_Msg_BCM_0x335(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_BCM_0x335.DataLength;//Message Data Length
   Msg_id  = Msg_BCM_0x335.id;//Message ID
   
    if (@CAN_ADAS::BCM_0x335::BCM_335_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::BCM_0x335::BCM_335_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_BCM_0x335_BCM_335_AliveCounter;
      counter_BCM_0x335_BCM_335_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_BCM_0x335_BCM_335_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::BCM_0x335::BCM_335_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::BCM_0x335::BCM_335_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_BCM_0x335_BCM_335_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::BCM_0x335::BCM_335_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::BCM_0x335::BCM_335_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_BCM_0x335_BCM_335_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_BCM_0x335_BCM_335_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::BCM_0x335::BCM_335_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::BCM_0x335::BCM_335_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_BCM_0x335_BCM_335_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::BCM_0x343::BCM_0x343_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::BCM_0x343);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::BCM_0x343);
      }
}

void cfg_Msg_BCM_0x343(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_BCM_0x343.DataLength;//Message Data Length
   Msg_id  = Msg_BCM_0x343.id;//Message ID
   
    if (@CAN_ADAS::BCM_0x343::BCM_343_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::BCM_0x343::BCM_343_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_BCM_0x343_BCM_343_AliveCounter;
      counter_BCM_0x343_BCM_343_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_BCM_0x343_BCM_343_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::BCM_0x343::BCM_343_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::BCM_0x343::BCM_343_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_BCM_0x343_BCM_343_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::BCM_0x343::BCM_343_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::BCM_0x343::BCM_343_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_BCM_0x343_BCM_343_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_BCM_0x343_BCM_343_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::BCM_0x343::BCM_343_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::BCM_0x343::BCM_343_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_BCM_0x343_BCM_343_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::CIM_0x310::CIM_0x310_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::CIM_0x310);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::CIM_0x310);
      }
}

void cfg_Msg_CIM_0x310(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_CIM_0x310.DataLength;//Message Data Length
   Msg_id  = Msg_CIM_0x310.id;//Message ID
   
    if (@CAN_ADAS::CIM_0x310::CIM_310_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::CIM_0x310::CIM_310_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_CIM_0x310_CIM_310_AliveCounter;
      counter_CIM_0x310_CIM_310_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_CIM_0x310_CIM_310_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::CIM_0x310::CIM_310_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::CIM_0x310::CIM_310_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_CIM_0x310_CIM_310_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::CIM_0x310::CIM_310_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::CIM_0x310::CIM_310_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_CIM_0x310_CIM_310_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_CIM_0x310_CIM_310_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::CIM_0x310::CIM_310_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::CIM_0x310::CIM_310_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_CIM_0x310_CIM_310_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::DBC_Version::DBC_Version_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::DBC_Version);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::DBC_Version);
      }
}

void cfg_Msg_DBC_Version(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_DBC_Version.DataLength;//Message Data Length
   Msg_id  = Msg_DBC_Version.id;//Message ID
   
}


on sysvar CAN_ADAS::ECC_0x373::ECC_0x373_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ECC_0x373);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ECC_0x373);
      }
}

void cfg_Msg_ECC_0x373(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ECC_0x373.DataLength;//Message Data Length
   Msg_id  = Msg_ECC_0x373.id;//Message ID
   
}


on sysvar CAN_ADAS::EPS2ADAS_0x1C5::EPS2ADAS_0x1C5_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::EPS2ADAS_0x1C5);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::EPS2ADAS_0x1C5);
      }
}

void cfg_Msg_EPS2ADAS_0x1C5(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_EPS2ADAS_0x1C5.DataLength;//Message Data Length
   Msg_id  = Msg_EPS2ADAS_0x1C5.id;//Message ID
   
    if (@CAN_ADAS::EPS2ADAS_0x1C5::ADAS_1C5_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::EPS2ADAS_0x1C5::ADAS_1C5_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_EPS2ADAS_0x1C5_ADAS_1C5_AliveCounter;
      counter_EPS2ADAS_0x1C5_ADAS_1C5_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_EPS2ADAS_0x1C5_ADAS_1C5_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::EPS2ADAS_0x1C5::ADAS_1C5_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::EPS2ADAS_0x1C5::ADAS_1C5_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_EPS2ADAS_0x1C5_ADAS_1C5_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::EPS2ADAS_0x1C5::ADAS_1C5_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::EPS2ADAS_0x1C5::ADAS_1C5_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_EPS2ADAS_0x1C5_ADAS_1C5_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_EPS2ADAS_0x1C5_ADAS_1C5_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::EPS2ADAS_0x1C5::ADAS_1C5_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::EPS2ADAS_0x1C5::ADAS_1C5_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_EPS2ADAS_0x1C5_ADAS_1C5_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::EPS_0x1C2::EPS_0x1C2_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::EPS_0x1C2);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::EPS_0x1C2);
      }
}

void cfg_Msg_EPS_0x1C2(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_EPS_0x1C2.DataLength;//Message Data Length
   Msg_id  = Msg_EPS_0x1C2.id;//Message ID
   
    if (@CAN_ADAS::EPS_0x1C2::EPS_1C2_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::EPS_0x1C2::EPS_1C2_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_EPS_0x1C2_EPS_1C2_AliveCounter;
      counter_EPS_0x1C2_EPS_1C2_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_EPS_0x1C2_EPS_1C2_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::EPS_0x1C2::EPS_1C2_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::EPS_0x1C2::EPS_1C2_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_EPS_0x1C2_EPS_1C2_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::EPS_0x1C2::EPS_1C2_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::EPS_0x1C2::EPS_1C2_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_EPS_0x1C2_EPS_1C2_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_EPS_0x1C2_EPS_1C2_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::EPS_0x1C2::EPS_1C2_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::EPS_0x1C2::EPS_1C2_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_EPS_0x1C2_EPS_1C2_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::EPS_0x1C4::EPS_0x1C4_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::EPS_0x1C4);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::EPS_0x1C4);
      }
}

void cfg_Msg_EPS_0x1C4(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_EPS_0x1C4.DataLength;//Message Data Length
   Msg_id  = Msg_EPS_0x1C4.id;//Message ID
   
    if (@CAN_ADAS::EPS_0x1C4::EPS_1C4_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::EPS_0x1C4::EPS_1C4_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_EPS_0x1C4_EPS_1C4_AliveCounter;
      counter_EPS_0x1C4_EPS_1C4_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_EPS_0x1C4_EPS_1C4_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::EPS_0x1C4::EPS_1C4_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::EPS_0x1C4::EPS_1C4_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_EPS_0x1C4_EPS_1C4_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::EPS_0x1C4::EPS_1C4_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::EPS_0x1C4::EPS_1C4_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_EPS_0x1C4_EPS_1C4_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_EPS_0x1C4_EPS_1C4_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::EPS_0x1C4::EPS_1C4_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::EPS_0x1C4::EPS_1C4_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_EPS_0x1C4_EPS_1C4_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::EPS_0x475::EPS_0x475_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::EPS_0x475);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::EPS_0x475);
      }
}

void cfg_Msg_EPS_0x475(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_EPS_0x475.DataLength;//Message Data Length
   Msg_id  = Msg_EPS_0x475.id;//Message ID
   
}


on sysvar CAN_ADAS::ESP_0x116::ESP_0x116_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ESP_0x116);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ESP_0x116);
      }
}

void cfg_Msg_ESP_0x116(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ESP_0x116.DataLength;//Message Data Length
   Msg_id  = Msg_ESP_0x116.id;//Message ID
   
    if (@CAN_ADAS::ESP_0x116::ESP_116_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,12,15,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::ESP_0x116::ESP_116_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_ESP_0x116_ESP_116_AliveCounter;
      counter_ESP_0x116_ESP_116_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_ESP_0x116_ESP_116_AliveCounter,data,12,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ESP_0x116::ESP_116_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,12,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ESP_0x116::ESP_116_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_ESP_0x116_ESP_116_AliveCounter,data,12,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::ESP_0x116::ESP_116_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::ESP_0x116::ESP_116_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_ESP_0x116_ESP_116_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_ESP_0x116_ESP_116_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ESP_0x116::ESP_116_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ESP_0x116::ESP_116_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_ESP_0x116_ESP_116_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::ESP_0x120::ESP_0x120_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ESP_0x120);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ESP_0x120);
      }
}

void cfg_Msg_ESP_0x120(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ESP_0x120.DataLength;//Message Data Length
   Msg_id  = Msg_ESP_0x120.id;//Message ID
   
    if (@CAN_ADAS::ESP_0x120::ESP_120_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::ESP_0x120::ESP_120_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_ESP_0x120_ESP_120_AliveCounter;
      counter_ESP_0x120_ESP_120_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_ESP_0x120_ESP_120_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ESP_0x120::ESP_120_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ESP_0x120::ESP_120_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_ESP_0x120_ESP_120_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::ESP_0x120::ESP_120_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::ESP_0x120::ESP_120_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_ESP_0x120_ESP_120_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_ESP_0x120_ESP_120_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ESP_0x120::ESP_120_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ESP_0x120::ESP_120_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_ESP_0x120_ESP_120_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::ESP_0x261::ESP_0x261_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ESP_0x261);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ESP_0x261);
      }
}

void cfg_Msg_ESP_0x261(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ESP_0x261.DataLength;//Message Data Length
   Msg_id  = Msg_ESP_0x261.id;//Message ID
   
    if (@CAN_ADAS::ESP_0x261::ESP_261_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::ESP_0x261::ESP_261_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_ESP_0x261_ESP_261_AliveCounter;
      counter_ESP_0x261_ESP_261_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_ESP_0x261_ESP_261_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ESP_0x261::ESP_261_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ESP_0x261::ESP_261_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_ESP_0x261_ESP_261_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::ESP_0x261::ESP_261_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::ESP_0x261::ESP_261_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_ESP_0x261_ESP_261_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_ESP_0x261_ESP_261_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ESP_0x261::ESP_261_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ESP_0x261::ESP_261_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_ESP_0x261_ESP_261_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::ESP_0x268::ESP_0x268_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ESP_0x268);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ESP_0x268);
      }
}

void cfg_Msg_ESP_0x268(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ESP_0x268.DataLength;//Message Data Length
   Msg_id  = Msg_ESP_0x268.id;//Message ID
   
    if (@CAN_ADAS::ESP_0x268::ESP_268_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::ESP_0x268::ESP_268_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_ESP_0x268_ESP_268_AliveCounter;
      counter_ESP_0x268_ESP_268_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_ESP_0x268_ESP_268_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ESP_0x268::ESP_268_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ESP_0x268::ESP_268_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_ESP_0x268_ESP_268_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::ESP_0x268::ESP_268_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::ESP_0x268::ESP_268_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_ESP_0x268_ESP_268_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_ESP_0x268_ESP_268_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ESP_0x268::ESP_268_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ESP_0x268::ESP_268_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_ESP_0x268_ESP_268_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::ESP_0x305::ESP_0x305_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ESP_0x305);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ESP_0x305);
      }
}

void cfg_Msg_ESP_0x305(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ESP_0x305.DataLength;//Message Data Length
   Msg_id  = Msg_ESP_0x305.id;//Message ID
   
    if (@CAN_ADAS::ESP_0x305::ESP_305_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::ESP_0x305::ESP_305_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_ESP_0x305_ESP_305_AliveCounter;
      counter_ESP_0x305_ESP_305_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_ESP_0x305_ESP_305_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ESP_0x305::ESP_305_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ESP_0x305::ESP_305_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_ESP_0x305_ESP_305_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::ESP_0x305::ESP_305_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::ESP_0x305::ESP_305_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_ESP_0x305_ESP_305_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_ESP_0x305_ESP_305_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ESP_0x305::ESP_305_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ESP_0x305::ESP_305_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_ESP_0x305_ESP_305_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::ESP_0x306::ESP_0x306_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ESP_0x306);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ESP_0x306);
      }
}

void cfg_Msg_ESP_0x306(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ESP_0x306.DataLength;//Message Data Length
   Msg_id  = Msg_ESP_0x306.id;//Message ID
   
    if (@CAN_ADAS::ESP_0x306::ESP_306_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::ESP_0x306::ESP_306_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_ESP_0x306_ESP_306_AliveCounter;
      counter_ESP_0x306_ESP_306_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_ESP_0x306_ESP_306_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ESP_0x306::ESP_306_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ESP_0x306::ESP_306_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_ESP_0x306_ESP_306_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::ESP_0x306::ESP_306_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::ESP_0x306::ESP_306_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_ESP_0x306_ESP_306_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_ESP_0x306_ESP_306_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ESP_0x306::ESP_306_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ESP_0x306::ESP_306_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_ESP_0x306_ESP_306_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::ESP_0x318::ESP_0x318_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ESP_0x318);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ESP_0x318);
      }
}

void cfg_Msg_ESP_0x318(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ESP_0x318.DataLength;//Message Data Length
   Msg_id  = Msg_ESP_0x318.id;//Message ID
   
    if (@CAN_ADAS::ESP_0x318::ESP_318_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::ESP_0x318::ESP_318_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_ESP_0x318_ESP_318_AliveCounter;
      counter_ESP_0x318_ESP_318_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_ESP_0x318_ESP_318_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ESP_0x318::ESP_318_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ESP_0x318::ESP_318_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_ESP_0x318_ESP_318_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::ESP_0x318::ESP_318_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::ESP_0x318::ESP_318_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_ESP_0x318_ESP_318_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_ESP_0x318_ESP_318_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ESP_0x318::ESP_318_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ESP_0x318::ESP_318_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_ESP_0x318_ESP_318_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::GW_HSC8_FrP16::GW_HSC8_FrP16_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::GW_HSC8_FrP16);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::GW_HSC8_FrP16);
      }
}

void cfg_Msg_GW_HSC8_FrP16(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_GW_HSC8_FrP16.DataLength;//Message Data Length
   Msg_id  = Msg_GW_HSC8_FrP16.id;//Message ID
   
    if (@CAN_ADAS::GW_HSC8_FrP16::GW_FrP16_RolingCounter_h8HSC8_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_ADAS::GW_HSC8_FrP16::GW_FrP16_RolingCounter_h8HSC8_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_GW_HSC8_FrP16_GW_FrP16_RolingCounter_h8HSC8;
      counter_GW_HSC8_FrP16_GW_FrP16_RolingCounter_h8HSC8 %=15;

      copyBitsToByteArrayLE(counter_GW_HSC8_FrP16_GW_FrP16_RolingCounter_h8HSC8,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::GW_HSC8_FrP16::GW_FrP16_RolingCounter_h8HSC8_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::GW_HSC8_FrP16::GW_FrP16_RolingCounter_h8HSC8_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_GW_HSC8_FrP16_GW_FrP16_RolingCounter_h8HSC8,data,8,4); //Intel / little-endian;
    }
    if (@CAN_ADAS::GW_HSC8_FrP16::GW_FrP16_Checksum_h8HSC8_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_ADAS::GW_HSC8_FrP16::GW_FrP16_Checksum_h8HSC8_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_GW_HSC8_FrP16_GW_FrP16_Checksum_h8HSC8 = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(chksum_GW_HSC8_FrP16_GW_FrP16_Checksum_h8HSC8,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ADAS::GW_HSC8_FrP16::GW_FrP16_Checksum_h8HSC8_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ADAS::GW_HSC8_FrP16::GW_FrP16_Checksum_h8HSC8_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(chksum_GW_HSC8_FrP16_GW_FrP16_Checksum_h8HSC8,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::HMI_0x4BF_ADAS::HMI_0x4BF_ADAS_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::HMI_0x4BF_ADAS);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::HMI_0x4BF_ADAS);
      }
}

void cfg_Msg_HMI_0x4BF_ADAS(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_HMI_0x4BF_ADAS.DataLength;//Message Data Length
   Msg_id  = Msg_HMI_0x4BF_ADAS.id;//Message ID
   
    if (@CAN_ADAS::HMI_0x4BF_ADAS::ACCplusActivationSubfeatureCSA_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,5,1); //Intel / little-endian

    }
    if(@CAN_ADAS::HMI_0x4BF_ADAS::ACCplusActivationSubfeatureCSA_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_HMI_0x4BF_ADAS_ACCplusActivationSubfeatureCSA = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(chksum_HMI_0x4BF_ADAS_ACCplusActivationSubfeatureCSA,data,5,1); //Intel / little-endian;
    }
    else if(@CAN_ADAS::HMI_0x4BF_ADAS::ACCplusActivationSubfeatureCSA_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,5,1); //Intel / little-endian;
    }
    else if(@CAN_ADAS::HMI_0x4BF_ADAS::ACCplusActivationSubfeatureCSA_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(chksum_HMI_0x4BF_ADAS_ACCplusActivationSubfeatureCSA,data,5,1); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::ICC_0x526::ICC_0x526_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ICC_0x526);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ICC_0x526);
      }
}

void cfg_Msg_ICC_0x526(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ICC_0x526.DataLength;//Message Data Length
   Msg_id  = Msg_ICC_0x526.id;//Message ID
   
}


on sysvar CAN_ADAS::ICC_0x531::ICC_0x531_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ICC_0x531);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ICC_0x531);
      }
}

void cfg_Msg_ICC_0x531(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ICC_0x531.DataLength;//Message Data Length
   Msg_id  = Msg_ICC_0x531.id;//Message ID
   
}


on sysvar CAN_ADAS::MCU_F_0x150::MCU_F_0x150_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::MCU_F_0x150);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::MCU_F_0x150);
      }
}

void cfg_Msg_MCU_F_0x150(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_MCU_F_0x150.DataLength;//Message Data Length
   Msg_id  = Msg_MCU_F_0x150.id;//Message ID
   
    if (@CAN_ADAS::MCU_F_0x150::MCU_F_150_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::MCU_F_0x150::MCU_F_150_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_MCU_F_0x150_MCU_F_150_AliveCounter;
      counter_MCU_F_0x150_MCU_F_150_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_MCU_F_0x150_MCU_F_150_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::MCU_F_0x150::MCU_F_150_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::MCU_F_0x150::MCU_F_150_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_MCU_F_0x150_MCU_F_150_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::MCU_F_0x150::MCU_F_150_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::MCU_F_0x150::MCU_F_150_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_MCU_F_0x150_MCU_F_150_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_MCU_F_0x150_MCU_F_150_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::MCU_F_0x150::MCU_F_150_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::MCU_F_0x150::MCU_F_150_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_MCU_F_0x150_MCU_F_150_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::MCU_R_0x151::MCU_R_0x151_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::MCU_R_0x151);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::MCU_R_0x151);
      }
}

void cfg_Msg_MCU_R_0x151(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_MCU_R_0x151.DataLength;//Message Data Length
   Msg_id  = Msg_MCU_R_0x151.id;//Message ID
   
    if (@CAN_ADAS::MCU_R_0x151::MCU_R_151_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::MCU_R_0x151::MCU_R_151_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_MCU_R_0x151_MCU_R_151_AliveCounter;
      counter_MCU_R_0x151_MCU_R_151_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_MCU_R_0x151_MCU_R_151_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::MCU_R_0x151::MCU_R_151_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::MCU_R_0x151::MCU_R_151_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_MCU_R_0x151_MCU_R_151_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::MCU_R_0x151::MCU_R_151_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::MCU_R_0x151::MCU_R_151_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_MCU_R_0x151_MCU_R_151_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_MCU_R_0x151_MCU_R_151_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::MCU_R_0x151::MCU_R_151_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::MCU_R_0x151::MCU_R_151_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_MCU_R_0x151_MCU_R_151_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::PEPS_0x333::PEPS_0x333_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::PEPS_0x333);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::PEPS_0x333);
      }
}

void cfg_Msg_PEPS_0x333(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_PEPS_0x333.DataLength;//Message Data Length
   Msg_id  = Msg_PEPS_0x333.id;//Message ID
   
    if (@CAN_ADAS::PEPS_0x333::PEPS_333_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::PEPS_0x333::PEPS_333_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_PEPS_0x333_PEPS_333_AliveCounter;
      counter_PEPS_0x333_PEPS_333_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_PEPS_0x333_PEPS_333_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::PEPS_0x333::PEPS_333_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::PEPS_0x333::PEPS_333_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_PEPS_0x333_PEPS_333_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::PEPS_0x333::PEPS_333_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::PEPS_0x333::PEPS_333_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_PEPS_0x333_PEPS_333_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_PEPS_0x333_PEPS_333_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::PEPS_0x333::PEPS_333_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::PEPS_0x333::PEPS_333_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_PEPS_0x333_PEPS_333_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::PT_VMI_01::PT_VMI_01_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::PT_VMI_01);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::PT_VMI_01);
      }
}

void cfg_Msg_PT_VMI_01(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_PT_VMI_01.DataLength;//Message Data Length
   Msg_id  = Msg_PT_VMI_01.id;//Message ID
   
    if (@CAN_ADAS::PT_VMI_01::PT_VMI_01_BZ_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_ADAS::PT_VMI_01::PT_VMI_01_BZ_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_PT_VMI_01_PT_VMI_01_BZ;
      counter_PT_VMI_01_PT_VMI_01_BZ %=15;

      copyBitsToByteArrayLE(counter_PT_VMI_01_PT_VMI_01_BZ,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::PT_VMI_01::PT_VMI_01_BZ_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::PT_VMI_01::PT_VMI_01_BZ_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_PT_VMI_01_PT_VMI_01_BZ,data,8,4); //Intel / little-endian;
    }
    if (@CAN_ADAS::PT_VMI_01::PT_VMI_01_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_ADAS::PT_VMI_01::PT_VMI_01_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      crc_PT_VMI_01_PT_VMI_01_CRC = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(crc_PT_VMI_01_PT_VMI_01_CRC,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ADAS::PT_VMI_01::PT_VMI_01_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ADAS::PT_VMI_01::PT_VMI_01_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_PT_VMI_01_PT_VMI_01_CRC,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::RBFMain11::RBFMain11_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::RBFMain11);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::RBFMain11);
      }
}

void cfg_Msg_RBFMain11(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RBFMain11.DataLength;//Message Data Length
   Msg_id  = Msg_RBFMain11.id;//Message ID
   
    if (@CAN_ADAS::RBFMain11::RBFMain11_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_ADAS::RBFMain11::RBFMain11_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RBFMain11_RBFMain11_AliveCounter;
      counter_RBFMain11_RBFMain11_AliveCounter %=15;

      copyBitsToByteArrayLE(counter_RBFMain11_RBFMain11_AliveCounter,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::RBFMain11::RBFMain11_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::RBFMain11::RBFMain11_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RBFMain11_RBFMain11_AliveCounter,data,8,4); //Intel / little-endian;
    }
    if (@CAN_ADAS::RBFMain11::RBFMain11_Checksum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_ADAS::RBFMain11::RBFMain11_Checksum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_RBFMain11_RBFMain11_Checksum = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(chksum_RBFMain11_RBFMain11_Checksum,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ADAS::RBFMain11::RBFMain11_Checksum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ADAS::RBFMain11::RBFMain11_Checksum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(chksum_RBFMain11_RBFMain11_Checksum,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::RBFMain12::RBFMain12_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::RBFMain12);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::RBFMain12);
      }
}

void cfg_Msg_RBFMain12(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_RBFMain12.DataLength;//Message Data Length
   Msg_id  = Msg_RBFMain12.id;//Message ID
   
    if (@CAN_ADAS::RBFMain12::RBFMain12_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_ADAS::RBFMain12::RBFMain12_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_RBFMain12_RBFMain12_AliveCounter;
      counter_RBFMain12_RBFMain12_AliveCounter %=15;

      copyBitsToByteArrayLE(counter_RBFMain12_RBFMain12_AliveCounter,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::RBFMain12::RBFMain12_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::RBFMain12::RBFMain12_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_RBFMain12_RBFMain12_AliveCounter,data,8,4); //Intel / little-endian;
    }
    if (@CAN_ADAS::RBFMain12::RBFMain12_Checksum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_ADAS::RBFMain12::RBFMain12_Checksum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_RBFMain12_RBFMain12_Checksum = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(chksum_RBFMain12_RBFMain12_Checksum,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ADAS::RBFMain12::RBFMain12_Checksum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ADAS::RBFMain12::RBFMain12_Checksum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(chksum_RBFMain12_RBFMain12_Checksum,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::SDM_0x319::SDM_0x319_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::SDM_0x319);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::SDM_0x319);
      }
}

void cfg_Msg_SDM_0x319(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_SDM_0x319.DataLength;//Message Data Length
   Msg_id  = Msg_SDM_0x319.id;//Message ID
   
    if (@CAN_ADAS::SDM_0x319::SDM_319_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::SDM_0x319::SDM_319_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_SDM_0x319_SDM_319_AliveCounter;
      counter_SDM_0x319_SDM_319_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_SDM_0x319_SDM_319_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::SDM_0x319::SDM_319_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::SDM_0x319::SDM_319_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_SDM_0x319_SDM_319_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::SDM_0x319::SDM_319_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::SDM_0x319::SDM_319_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_SDM_0x319_SDM_319_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_SDM_0x319_SDM_319_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::SDM_0x319::SDM_319_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::SDM_0x319::SDM_319_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_SDM_0x319_SDM_319_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::VCU_0x1BA::VCU_0x1BA_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::VCU_0x1BA);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::VCU_0x1BA);
      }
}

void cfg_Msg_VCU_0x1BA(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VCU_0x1BA.DataLength;//Message Data Length
   Msg_id  = Msg_VCU_0x1BA.id;//Message ID
   
    if (@CAN_ADAS::VCU_0x1BA::VCU_1BA_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::VCU_0x1BA::VCU_1BA_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VCU_0x1BA_VCU_1BA_AliveCounter;
      counter_VCU_0x1BA_VCU_1BA_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_VCU_0x1BA_VCU_1BA_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::VCU_0x1BA::VCU_1BA_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::VCU_0x1BA::VCU_1BA_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_VCU_0x1BA_VCU_1BA_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::VCU_0x1BA::VCU_1BA_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::VCU_0x1BA::VCU_1BA_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_VCU_0x1BA_VCU_1BA_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_VCU_0x1BA_VCU_1BA_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::VCU_0x1BA::VCU_1BA_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::VCU_0x1BA::VCU_1BA_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_VCU_0x1BA_VCU_1BA_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::VCU_0x214::VCU_0x214_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::VCU_0x214);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::VCU_0x214);
      }
}

void cfg_Msg_VCU_0x214(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VCU_0x214.DataLength;//Message Data Length
   Msg_id  = Msg_VCU_0x214.id;//Message ID
   
    if (@CAN_ADAS::VCU_0x214::VCU_214_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::VCU_0x214::VCU_214_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VCU_0x214_VCU_214_AliveCounter;
      counter_VCU_0x214_VCU_214_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_VCU_0x214_VCU_214_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::VCU_0x214::VCU_214_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::VCU_0x214::VCU_214_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_VCU_0x214_VCU_214_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::VCU_0x214::VCU_214_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::VCU_0x214::VCU_214_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_VCU_0x214_VCU_214_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_VCU_0x214_VCU_214_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::VCU_0x214::VCU_214_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::VCU_0x214::VCU_214_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_VCU_0x214_VCU_214_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::VCU_0x225::VCU_0x225_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::VCU_0x225);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::VCU_0x225);
      }
}

void cfg_Msg_VCU_0x225(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VCU_0x225.DataLength;//Message Data Length
   Msg_id  = Msg_VCU_0x225.id;//Message ID
   
    if (@CAN_ADAS::VCU_0x225::VCU_225_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::VCU_0x225::VCU_225_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VCU_0x225_VCU_225_AliveCounter;
      counter_VCU_0x225_VCU_225_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_VCU_0x225_VCU_225_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::VCU_0x225::VCU_225_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::VCU_0x225::VCU_225_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_VCU_0x225_VCU_225_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::VCU_0x225::VCU_225_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::VCU_0x225::VCU_225_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_VCU_0x225_VCU_225_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_VCU_0x225_VCU_225_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::VCU_0x225::VCU_225_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::VCU_0x225::VCU_225_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_VCU_0x225_VCU_225_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::VariantCoding::VariantCoding_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::VariantCoding);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::VariantCoding);
      }
}

void cfg_Msg_VariantCoding(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VariantCoding.DataLength;//Message Data Length
   Msg_id  = Msg_VariantCoding.id;//Message ID
   
}


on sysvar CAN_ADAS::YRS_0x242::YRS_0x242_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::YRS_0x242);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::YRS_0x242);
      }
}

void cfg_Msg_YRS_0x242(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_YRS_0x242.DataLength;//Message Data Length
   Msg_id  = Msg_YRS_0x242.id;//Message ID
   
    if (@CAN_ADAS::YRS_0x242::YRS_242_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::YRS_0x242::YRS_242_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_YRS_0x242_YRS_242_AliveCounter;
      counter_YRS_0x242_YRS_242_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_YRS_0x242_YRS_242_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::YRS_0x242::YRS_242_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::YRS_0x242::YRS_242_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_YRS_0x242_YRS_242_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::YRS_0x242::YRS_242_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::YRS_0x242::YRS_242_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_YRS_0x242_YRS_242_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_YRS_0x242_YRS_242_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::YRS_0x242::YRS_242_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::YRS_0x242::YRS_242_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_YRS_0x242_YRS_242_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::YRS_0x246::YRS_0x246_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::YRS_0x246);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::YRS_0x246);
      }
}

void cfg_Msg_YRS_0x246(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_YRS_0x246.DataLength;//Message Data Length
   Msg_id  = Msg_YRS_0x246.id;//Message ID
   
    if (@CAN_ADAS::YRS_0x246::YRS_246_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::YRS_0x246::YRS_246_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_YRS_0x246_YRS_246_AliveCounter;
      counter_YRS_0x246_YRS_246_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_YRS_0x246_YRS_246_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::YRS_0x246::YRS_246_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::YRS_0x246::YRS_246_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_YRS_0x246_YRS_246_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::YRS_0x246::YRS_246_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::YRS_0x246::YRS_246_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_YRS_0x246_YRS_246_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_YRS_0x246_YRS_246_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::YRS_0x246::YRS_246_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::YRS_0x246::YRS_246_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_YRS_0x246_YRS_246_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::iBooster_0x271::iBooster_0x271_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::iBooster_0x271);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::iBooster_0x271);
      }
}

void cfg_Msg_iBooster_0x271(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_iBooster_0x271.DataLength;//Message Data Length
   Msg_id  = Msg_iBooster_0x271.id;//Message ID
   
    if (@CAN_ADAS::iBooster_0x271::iBooster_271_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::iBooster_0x271::iBooster_271_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_iBooster_0x271_iBooster_271_AliveCounter;
      counter_iBooster_0x271_iBooster_271_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_iBooster_0x271_iBooster_271_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::iBooster_0x271::iBooster_271_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::iBooster_0x271::iBooster_271_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_iBooster_0x271_iBooster_271_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::iBooster_0x271::iBooster_271_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::iBooster_0x271::iBooster_271_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_iBooster_0x271_iBooster_271_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_iBooster_0x271_iBooster_271_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::iBooster_0x271::iBooster_271_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::iBooster_0x271::iBooster_271_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_iBooster_0x271_iBooster_271_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::ADAS_Position::ADAS_Position_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ADAS_Position,@this);
  //ILFaultInjectionResetMsgCycleTime(ADAS_Position);
}

on sysvar CAN_ADAS::ADAS_Metadata::ADAS_Metadata_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ADAS_Metadata,@this);
  //ILFaultInjectionResetMsgCycleTime(ADAS_Metadata);
}

on sysvar CAN_ADAS::ADASLong_Mux::ADASLong_Mux_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ADASLong_Mux,@this);
  //ILFaultInjectionResetMsgCycleTime(ADASLong_Mux);
}

on sysvar CAN_ADAS::ESP_0x116::ESP_0x116_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ESP_0x116,@this);
  //ILFaultInjectionResetMsgCycleTime(ESP_0x116);
}

on sysvar CAN_ADAS::ESP_0x120::ESP_0x120_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ESP_0x120,@this);
  //ILFaultInjectionResetMsgCycleTime(ESP_0x120);
}

on sysvar CAN_ADAS::MCU_F_0x150::MCU_F_0x150_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::MCU_F_0x150,@this);
  //ILFaultInjectionResetMsgCycleTime(MCU_F_0x150);
}

on sysvar CAN_ADAS::MCU_R_0x151::MCU_R_0x151_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::MCU_R_0x151,@this);
  //ILFaultInjectionResetMsgCycleTime(MCU_R_0x151);
}

on sysvar CAN_ADAS::APA_0x1B0::APA_0x1B0_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::APA_0x1B0,@this);
  //ILFaultInjectionResetMsgCycleTime(APA_0x1B0);
}

on sysvar CAN_ADAS::VCU_0x1BA::VCU_0x1BA_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::VCU_0x1BA,@this);
  //ILFaultInjectionResetMsgCycleTime(VCU_0x1BA);
}

on sysvar CAN_ADAS::AFB_0x1BB::AFB_0x1BB_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::AFB_0x1BB,@this);
  //ILFaultInjectionResetMsgCycleTime(AFB_0x1BB);
}

on sysvar CAN_ADAS::EPS_0x1C2::EPS_0x1C2_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::EPS_0x1C2,@this);
  //ILFaultInjectionResetMsgCycleTime(EPS_0x1C2);
}

on sysvar CAN_ADAS::EPS_0x1C4::EPS_0x1C4_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::EPS_0x1C4,@this);
  //ILFaultInjectionResetMsgCycleTime(EPS_0x1C4);
}

on sysvar CAN_ADAS::EPS2ADAS_0x1C5::EPS2ADAS_0x1C5_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::EPS2ADAS_0x1C5,@this);
  //ILFaultInjectionResetMsgCycleTime(EPS2ADAS_0x1C5);
}

on sysvar CAN_ADAS::VCU_0x214::VCU_0x214_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::VCU_0x214,@this);
  //ILFaultInjectionResetMsgCycleTime(VCU_0x214);
}

on sysvar CAN_ADAS::VCU_0x225::VCU_0x225_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::VCU_0x225,@this);
  //ILFaultInjectionResetMsgCycleTime(VCU_0x225);
}

on sysvar CAN_ADAS::YRS_0x242::YRS_0x242_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::YRS_0x242,@this);
  //ILFaultInjectionResetMsgCycleTime(YRS_0x242);
}

on sysvar CAN_ADAS::YRS_0x246::YRS_0x246_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::YRS_0x246,@this);
  //ILFaultInjectionResetMsgCycleTime(YRS_0x246);
}

on sysvar CAN_ADAS::ESP_0x261::ESP_0x261_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ESP_0x261,@this);
  //ILFaultInjectionResetMsgCycleTime(ESP_0x261);
}

on sysvar CAN_ADAS::ESP_0x268::ESP_0x268_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ESP_0x268,@this);
  //ILFaultInjectionResetMsgCycleTime(ESP_0x268);
}

on sysvar CAN_ADAS::iBooster_0x271::iBooster_0x271_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::iBooster_0x271,@this);
  //ILFaultInjectionResetMsgCycleTime(iBooster_0x271);
}

on sysvar CAN_ADAS::GW_HSC8_FrP16::GW_HSC8_FrP16_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::GW_HSC8_FrP16,@this);
  //ILFaultInjectionResetMsgCycleTime(GW_HSC8_FrP16);
}

on sysvar CAN_ADAS::ESP_0x305::ESP_0x305_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ESP_0x305,@this);
  //ILFaultInjectionResetMsgCycleTime(ESP_0x305);
}

on sysvar CAN_ADAS::ESP_0x306::ESP_0x306_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ESP_0x306,@this);
  //ILFaultInjectionResetMsgCycleTime(ESP_0x306);
}

on sysvar CAN_ADAS::CIM_0x310::CIM_0x310_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::CIM_0x310,@this);
  //ILFaultInjectionResetMsgCycleTime(CIM_0x310);
}

on sysvar CAN_ADAS::ESP_0x318::ESP_0x318_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ESP_0x318,@this);
  //ILFaultInjectionResetMsgCycleTime(ESP_0x318);
}

on sysvar CAN_ADAS::SDM_0x319::SDM_0x319_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::SDM_0x319,@this);
  //ILFaultInjectionResetMsgCycleTime(SDM_0x319);
}

on sysvar CAN_ADAS::PEPS_0x333::PEPS_0x333_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::PEPS_0x333,@this);
  //ILFaultInjectionResetMsgCycleTime(PEPS_0x333);
}

on sysvar CAN_ADAS::BCM_0x335::BCM_0x335_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::BCM_0x335,@this);
  //ILFaultInjectionResetMsgCycleTime(BCM_0x335);
}

on sysvar CAN_ADAS::BCM_0x343::BCM_0x343_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::BCM_0x343,@this);
  //ILFaultInjectionResetMsgCycleTime(BCM_0x343);
}

on sysvar CAN_ADAS::ECC_0x373::ECC_0x373_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ECC_0x373,@this);
  //ILFaultInjectionResetMsgCycleTime(ECC_0x373);
}

on sysvar CAN_ADAS::PT_VMI_01::PT_VMI_01_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::PT_VMI_01,@this);
  //ILFaultInjectionResetMsgCycleTime(PT_VMI_01);
}

on sysvar CAN_ADAS::EPS_0x475::EPS_0x475_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::EPS_0x475,@this);
  //ILFaultInjectionResetMsgCycleTime(EPS_0x475);
}

on sysvar CAN_ADAS::ADAS_0x4BB_HMI::ADAS_0x4BB_HMI_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ADAS_0x4BB_HMI,@this);
  //ILFaultInjectionResetMsgCycleTime(ADAS_0x4BB_HMI);
}

on sysvar CAN_ADAS::HMI_0x4BF_ADAS::HMI_0x4BF_ADAS_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::HMI_0x4BF_ADAS,@this);
  //ILFaultInjectionResetMsgCycleTime(HMI_0x4BF_ADAS);
}

on sysvar CAN_ADAS::ICC_0x526::ICC_0x526_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ICC_0x526,@this);
  //ILFaultInjectionResetMsgCycleTime(ICC_0x526);
}

on sysvar CAN_ADAS::ICC_0x531::ICC_0x531_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ICC_0x531,@this);
  //ILFaultInjectionResetMsgCycleTime(ICC_0x531);
}

on sysvar CAN_ADAS::AEB_Status_0x5A0::AEB_Status_0x5A0_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::AEB_Status_0x5A0,@this);
  //ILFaultInjectionResetMsgCycleTime(AEB_Status_0x5A0);
}

on sysvar CAN_ADAS::RBFMain11::RBFMain11_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::RBFMain11,@this);
  //ILFaultInjectionResetMsgCycleTime(RBFMain11);
}

on sysvar CAN_ADAS::RBFMain12::RBFMain12_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::RBFMain12,@this);
  //ILFaultInjectionResetMsgCycleTime(RBFMain12);
}

on sysvar CAN_ADAS::VariantCoding::VariantCoding_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::VariantCoding,@this);
  //ILFaultInjectionResetMsgCycleTime(VariantCoding);
}

on sysvar CAN_ADAS::DBC_Version::DBC_Version_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::DBC_Version,@this);
  //ILFaultInjectionResetMsgCycleTime(DBC_Version);
}

void Rbs_sim_SetCycleTimeOffset()
{

//  ILNodeSetPDUTimingCyclic (dbMsg dbMessage, long TrueOrFalse, long offset, long period, long disturbanceCount, long flags);
//  TrueOrFalse ; 0: denotes the False timing; 1: denotes the True timing; 3: denotes the True and the False timing.
//  offset :Defines the delay in [ms] from now when the first cyclic transmission will start.
//  period :Defines the period in [ms] for the cyclic transmission.
//  disturbanceCount :Reserved/unused; should be set to -1 (infinite).
//  flags :Reserved; should be set to 0.

}