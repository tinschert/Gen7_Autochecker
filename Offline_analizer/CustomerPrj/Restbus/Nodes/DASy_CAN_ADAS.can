/*@!Encoding:1252*/
/**
 * @file DASy_CAN_ADAS.can
 * @author ADAS_HIL_TEAM
 * @date 10-04-2022
 * @brief 
 *
 * ################################################################
 * C O P Y R I G H T S
 * ----------------------------------------------------------------
 * Copyright (c) 2022-2023 by Robert Bosch GmbH. All rights reserved.
 
 * The reproduction, distribution and utilization of this file as
 * well as the communication of its contents to others without express
 * authorization is prohibited. Offenders will be held liable for the
 * payment of damages. All rights reserved in the event of the grant
 * of a patent, utility model or design.
 *
 * ################################################################
*/

// Autogenerated by -> Platform\Classe\Scripts\Rbs_Scripts\create_nodes.py
includes
{
  #pragma library ("C:\ProgramData\Vector\AddOn Packages\Vector AddOn\vModules\CANoeILNLVector.vmodule")
  #include "CAPL\DataHandling.cin" /*DataHandling for IL*/
  #include "CAPL\E2E.cin" /*OD Specific for CRC calculation */
}

variables {
  message ACC_06_DASy Msg_ACC_06_DASy;
  message MRR_0x1C0 Msg_MRR_0x1C0;
  message ADAS2EPS_0x1C1 Msg_ADAS2EPS_0x1C1;
  message MRR_0x254 Msg_MRR_0x254;
  message MRR_0x25A Msg_MRR_0x25A;
  message MRR_0x25B Msg_MRR_0x25B;
  message MRR_0x32C Msg_MRR_0x32C;
  message MRR_0x33C Msg_MRR_0x33C;
  message MRR_0x340 Msg_MRR_0x340;
  message MRR_0x347 Msg_MRR_0x347;
  message MCAM_VMI_01 Msg_MCAM_VMI_01;
  message ADAS_0x4BA_HMI Msg_ADAS_0x4BA_HMI;
  message ADAS_0x4BC_HMI Msg_ADAS_0x4BC_HMI;
  message ADAS_0x4BD_HMI Msg_ADAS_0x4BD_HMI;
  message ADAS_0x4BE_HMI Msg_ADAS_0x4BE_HMI;
  message VMCMain11 Msg_VMCMain11;
  message VMCMain12 Msg_VMCMain12;
  message DASyToFleaTP Msg_DASyToFleaTP;
  message SW_ID_DASy Msg_SW_ID_DASy;
  message SW_ID_RadarFront Msg_SW_ID_RadarFront;

  word counter_ACC_06_DASy_ACC_06_AliveCounter_D;
  word counter_MRR_0x1C0_ADAS_1C0_AliveCounter;
  word counter_ADAS2EPS_0x1C1_ADAS_1C1_AliveCounter;
  word counter_MRR_0x254_ADAS_254_AliveCounter;
  word counter_MRR_0x25A_ADAS_25A_AliveCounter;
  word counter_MCAM_VMI_01_MCAM_VMI_01_BZ;
  word counter_ADAS_0x4BA_HMI_ADAS_4BA_AliveCounter;
  word counter_VMCMain11_VMCMain11_AliveCounter;
  word counter_VMCMain12_VMCMain12_AliveCounter;

  byte chksum_ACC_06_DASy_ACC_06_CheckSum_D;
  byte chksum_MRR_0x1C0_ADAS_1C0_CheckSum;
  byte chksum_ADAS2EPS_0x1C1_ADAS_1C1_CheckSum;
  byte chksum_MRR_0x254_ADAS_254_CheckSum;
  byte chksum_MRR_0x25A_ADAS_25A_CheckSum;
  byte crc_MCAM_VMI_01_MCAM_VMI_01_CRC;
  dword chksum_ADAS_0x4BA_HMI_ADAS_4BA_CheckSum;
  byte chksum_ADAS_0x4BE_HMI_ACCplusIsActiveSubfeatureCSA;
  byte chksum_VMCMain11_VMCMain11_Checksum;
  byte chksum_VMCMain12_VMCMain12_Checksum;

}

on preStart {
  long result;
  result=ILControlInit ();//Initialization of CANoe IL,to prevent the IL autostart function.
  switch(result)
  {
    case  0   : write("ILControlInit :: DASy :: No error."); break;
    case -1   : write("ILControlInit :: DASy :: Momentary state of the IL does not permit this query."); break;
    case -50  : write("ILControlInit :: DASy :: Nodelayer is inactive - possibly deactivated in the nodes configuration dialog.");  break;
   }

  DASy_sim_Disable();
  DASy_sim_SetCycleTimeOffset();
}

on start {

  ILControlSimulationOn();//Starts the simulation of the IL.
  DASy_sim_SetCANFDParameter();
  ILControlStart ();//Cyclical sending starts; setting signals is now possible.
  DASy_sim_Reset();
}

on stopMeasurement {

  DASy_sim_DisableMsg();
  DASy_sim_Disable();
  ILControlStop();//Cyclical sending is stopped; setting signals is now no longer possible.
  ILControlSimulationOff();//Stops the simulation of the IL. After that no other function to control the IL has an effect to the IL.

}

on sysvar_update hil_ctrl::adas_1_sim
{
  DASy_sim_Reset();
}

on sysvar_update hil_ctrl::variant
{
  DASy_sim_Reset();
}

on sysvar_update Cus_bus::bus_CAN_ADAS_ON_OFF
{
  DASy_sim_Reset();
}

void DASy_sim_Reset()
{

  DASy_sim_DisableMsg();
  DASy_sim_Disable();

  if ((@Cus_bus::bus_CAN_ADAS_ON_OFF == 1) && (@hil_ctrl::adas_1_sim == 1))
  {
    switch(@hil_ctrl::variant)
    {
      case a_variant:DASy_sim_start_a_variant();break;
      case b_variant:DASy_sim_start_b_variant();break;
    }
    if (@hil_ctrl::hil_mode == @hil_ctrl::hil_mode::Restbus) 
    {
       DASy_sim_EnableEventMsg();
    }
    else
    {
       DASy_sim_DisableEventMsg();
    }
  }
}

void DASy_sim_start_a_variant()
{
  @CAN_ADAS::ACC_06_DASy::ACC_06_DASy_ON_OFF = 1;
  @CAN_ADAS::MRR_0x1C0::MRR_0x1C0_ON_OFF = 1;
  @CAN_ADAS::ADAS2EPS_0x1C1::ADAS2EPS_0x1C1_ON_OFF = 1;
  @CAN_ADAS::MRR_0x254::MRR_0x254_ON_OFF = 1;
  @CAN_ADAS::MRR_0x25A::MRR_0x25A_ON_OFF = 1;
  @CAN_ADAS::MRR_0x25B::MRR_0x25B_ON_OFF = 1;
  @CAN_ADAS::MRR_0x32C::MRR_0x32C_ON_OFF = 1;
  @CAN_ADAS::MRR_0x33C::MRR_0x33C_ON_OFF = 1;
  @CAN_ADAS::MRR_0x340::MRR_0x340_ON_OFF = 1;
  @CAN_ADAS::MRR_0x347::MRR_0x347_ON_OFF = 1;
  @CAN_ADAS::MCAM_VMI_01::MCAM_VMI_01_ON_OFF = 1;
  @CAN_ADAS::ADAS_0x4BA_HMI::ADAS_0x4BA_HMI_ON_OFF = 1;
  @CAN_ADAS::ADAS_0x4BC_HMI::ADAS_0x4BC_HMI_ON_OFF = 1;
  @CAN_ADAS::ADAS_0x4BD_HMI::ADAS_0x4BD_HMI_ON_OFF = 1;
  @CAN_ADAS::ADAS_0x4BE_HMI::ADAS_0x4BE_HMI_ON_OFF = 1;
  @CAN_ADAS::VMCMain11::VMCMain11_ON_OFF = 1;
  @CAN_ADAS::VMCMain12::VMCMain12_ON_OFF = 1;
  @CAN_ADAS::SW_ID_DASy::SW_ID_DASy_ON_OFF = 1;
  @CAN_ADAS::SW_ID_RadarFront::SW_ID_RadarFront_ON_OFF = 1;
}

void DASy_sim_start_b_variant()
{
  @CAN_ADAS::ACC_06_DASy::ACC_06_DASy_ON_OFF = 1;
  @CAN_ADAS::MRR_0x1C0::MRR_0x1C0_ON_OFF = 1;
  @CAN_ADAS::ADAS2EPS_0x1C1::ADAS2EPS_0x1C1_ON_OFF = 1;
  @CAN_ADAS::MRR_0x254::MRR_0x254_ON_OFF = 1;
  @CAN_ADAS::MRR_0x25A::MRR_0x25A_ON_OFF = 1;
  @CAN_ADAS::MRR_0x25B::MRR_0x25B_ON_OFF = 1;
  @CAN_ADAS::MRR_0x32C::MRR_0x32C_ON_OFF = 1;
  @CAN_ADAS::MRR_0x33C::MRR_0x33C_ON_OFF = 1;
  @CAN_ADAS::MRR_0x340::MRR_0x340_ON_OFF = 1;
  @CAN_ADAS::MRR_0x347::MRR_0x347_ON_OFF = 1;
  @CAN_ADAS::MCAM_VMI_01::MCAM_VMI_01_ON_OFF = 1;
  @CAN_ADAS::ADAS_0x4BA_HMI::ADAS_0x4BA_HMI_ON_OFF = 1;
  @CAN_ADAS::ADAS_0x4BC_HMI::ADAS_0x4BC_HMI_ON_OFF = 1;
  @CAN_ADAS::ADAS_0x4BD_HMI::ADAS_0x4BD_HMI_ON_OFF = 1;
  @CAN_ADAS::ADAS_0x4BE_HMI::ADAS_0x4BE_HMI_ON_OFF = 1;
  @CAN_ADAS::VMCMain11::VMCMain11_ON_OFF = 1;
  @CAN_ADAS::VMCMain12::VMCMain12_ON_OFF = 1;
  @CAN_ADAS::SW_ID_DASy::SW_ID_DASy_ON_OFF = 1;
  @CAN_ADAS::SW_ID_RadarFront::SW_ID_RadarFront_ON_OFF = 1;
}

void DASy_sim_Disable()
{
  @CAN_ADAS::ACC_06_DASy::ACC_06_DASy_ON_OFF = 0;
  @CAN_ADAS::MRR_0x1C0::MRR_0x1C0_ON_OFF = 0;
  @CAN_ADAS::ADAS2EPS_0x1C1::ADAS2EPS_0x1C1_ON_OFF = 0;
  @CAN_ADAS::MRR_0x254::MRR_0x254_ON_OFF = 0;
  @CAN_ADAS::MRR_0x25A::MRR_0x25A_ON_OFF = 0;
  @CAN_ADAS::MRR_0x25B::MRR_0x25B_ON_OFF = 0;
  @CAN_ADAS::MRR_0x32C::MRR_0x32C_ON_OFF = 0;
  @CAN_ADAS::MRR_0x33C::MRR_0x33C_ON_OFF = 0;
  @CAN_ADAS::MRR_0x340::MRR_0x340_ON_OFF = 0;
  @CAN_ADAS::MRR_0x347::MRR_0x347_ON_OFF = 0;
  @CAN_ADAS::MCAM_VMI_01::MCAM_VMI_01_ON_OFF = 0;
  @CAN_ADAS::ADAS_0x4BA_HMI::ADAS_0x4BA_HMI_ON_OFF = 0;
  @CAN_ADAS::ADAS_0x4BC_HMI::ADAS_0x4BC_HMI_ON_OFF = 0;
  @CAN_ADAS::ADAS_0x4BD_HMI::ADAS_0x4BD_HMI_ON_OFF = 0;
  @CAN_ADAS::ADAS_0x4BE_HMI::ADAS_0x4BE_HMI_ON_OFF = 0;
  @CAN_ADAS::VMCMain11::VMCMain11_ON_OFF = 0;
  @CAN_ADAS::VMCMain12::VMCMain12_ON_OFF = 0;
  @CAN_ADAS::DASyToFleaTP::DASyToFleaTP_ON_OFF = 0;
  @CAN_ADAS::SW_ID_DASy::SW_ID_DASy_ON_OFF = 0;
  @CAN_ADAS::SW_ID_RadarFront::SW_ID_RadarFront_ON_OFF = 0;
}

void DASy_sim_DisableMsg()
{
   ILFaultInjectionDisableMsg(CAN_ADAS::ACC_06_DASy);
   ILFaultInjectionDisableMsg(CAN_ADAS::MRR_0x1C0);
   ILFaultInjectionDisableMsg(CAN_ADAS::ADAS2EPS_0x1C1);
   ILFaultInjectionDisableMsg(CAN_ADAS::MRR_0x254);
   ILFaultInjectionDisableMsg(CAN_ADAS::MRR_0x25A);
   ILFaultInjectionDisableMsg(CAN_ADAS::MRR_0x25B);
   ILFaultInjectionDisableMsg(CAN_ADAS::MRR_0x32C);
   ILFaultInjectionDisableMsg(CAN_ADAS::MRR_0x33C);
   ILFaultInjectionDisableMsg(CAN_ADAS::MRR_0x340);
   ILFaultInjectionDisableMsg(CAN_ADAS::MRR_0x347);
   ILFaultInjectionDisableMsg(CAN_ADAS::MCAM_VMI_01);
   ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_0x4BA_HMI);
   ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_0x4BC_HMI);
   ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_0x4BD_HMI);
   ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_0x4BE_HMI);
   ILFaultInjectionDisableMsg(CAN_ADAS::VMCMain11);
   ILFaultInjectionDisableMsg(CAN_ADAS::VMCMain12);
   ILFaultInjectionDisableMsg(CAN_ADAS::DASyToFleaTP);
   ILFaultInjectionDisableMsg(CAN_ADAS::SW_ID_DASy);
   ILFaultInjectionDisableMsg(CAN_ADAS::SW_ID_RadarFront);
}
on sysvar hil_ctrl::hil_mode
{
  DASy_sim_Reset();
}

void DASy_sim_DisableEventMsg()
{
   ILFaultInjectionDisableMsg(CAN_ADAS::DASyToFleaTP);

}

void DASy_sim_EnableEventMsg()
{
   ILFaultInjectionEnableMsg(CAN_ADAS::DASyToFleaTP);

}
void DASy_sim_SetCANParameter()
{
  //For future purpose
  //ILFaultInjectionSetMsgDlc(dbMsg msg, dword dlc)
  //ILFaultInjectionSetMsgLength(dbMsg msg, dword msgLength)
  //ILFaultInjectionResetMsgDlc(dbMsg msg)
  //ILFaultInjectionResetMsgLength (dbMsg msg)
}

void DASy_sim_SetCANFDParameter()
{
   //CAN FD Parameter Setting
   int FDF =1;
   int BRS =1;
   ILSetCANFDParam(CAN_ADAS::ACC_06_DASy,FDF,BRS,CAN_ADAS::ACC_06_DASy.dlc);
   ILSetCANFDParam(CAN_ADAS::MRR_0x1C0,FDF,BRS,CAN_ADAS::MRR_0x1C0.dlc);
   ILSetCANFDParam(CAN_ADAS::ADAS2EPS_0x1C1,FDF,BRS,CAN_ADAS::ADAS2EPS_0x1C1.dlc);
   ILSetCANFDParam(CAN_ADAS::MRR_0x254,FDF,BRS,CAN_ADAS::MRR_0x254.dlc);
   ILSetCANFDParam(CAN_ADAS::MRR_0x25A,FDF,BRS,CAN_ADAS::MRR_0x25A.dlc);
   ILSetCANFDParam(CAN_ADAS::MRR_0x25B,FDF,BRS,CAN_ADAS::MRR_0x25B.dlc);
   ILSetCANFDParam(CAN_ADAS::MRR_0x32C,FDF,BRS,CAN_ADAS::MRR_0x32C.dlc);
   ILSetCANFDParam(CAN_ADAS::MRR_0x33C,FDF,BRS,CAN_ADAS::MRR_0x33C.dlc);
   ILSetCANFDParam(CAN_ADAS::MRR_0x340,FDF,BRS,CAN_ADAS::MRR_0x340.dlc);
   ILSetCANFDParam(CAN_ADAS::MRR_0x347,FDF,BRS,CAN_ADAS::MRR_0x347.dlc);
   ILSetCANFDParam(CAN_ADAS::MCAM_VMI_01,FDF,BRS,CAN_ADAS::MCAM_VMI_01.dlc);
   ILSetCANFDParam(CAN_ADAS::ADAS_0x4BA_HMI,FDF,BRS,CAN_ADAS::ADAS_0x4BA_HMI.dlc);
   ILSetCANFDParam(CAN_ADAS::ADAS_0x4BC_HMI,FDF,BRS,CAN_ADAS::ADAS_0x4BC_HMI.dlc);
   ILSetCANFDParam(CAN_ADAS::ADAS_0x4BD_HMI,FDF,BRS,CAN_ADAS::ADAS_0x4BD_HMI.dlc);
   ILSetCANFDParam(CAN_ADAS::ADAS_0x4BE_HMI,FDF,BRS,CAN_ADAS::ADAS_0x4BE_HMI.dlc);
   ILSetCANFDParam(CAN_ADAS::VMCMain11,FDF,BRS,CAN_ADAS::VMCMain11.dlc);
   ILSetCANFDParam(CAN_ADAS::VMCMain12,FDF,BRS,CAN_ADAS::VMCMain12.dlc);
   ILSetCANFDParam(CAN_ADAS::DASyToFleaTP,FDF,BRS,CAN_ADAS::DASyToFleaTP.dlc);
   ILSetCANFDParam(CAN_ADAS::SW_ID_DASy,FDF,BRS,CAN_ADAS::SW_ID_DASy.dlc);
   ILSetCANFDParam(CAN_ADAS::SW_ID_RadarFront,FDF,BRS,CAN_ADAS::SW_ID_RadarFront.dlc);
}

dword applILTxPending (long aId, dword aDlc, byte data[])//This callback is being called before the IL sends a message to the bus
{
  switch(aId)
  {
    case CAN_ADAS::ACC_06_DASy.id:cfg_Msg_ACC_06_DASy(aDlc, data);break;
    case CAN_ADAS::MRR_0x1C0.id:cfg_Msg_MRR_0x1C0(aDlc, data);break;
    case CAN_ADAS::ADAS2EPS_0x1C1.id:cfg_Msg_ADAS2EPS_0x1C1(aDlc, data);break;
    case CAN_ADAS::MRR_0x254.id:cfg_Msg_MRR_0x254(aDlc, data);break;
    case CAN_ADAS::MRR_0x25A.id:cfg_Msg_MRR_0x25A(aDlc, data);break;
    case CAN_ADAS::MRR_0x25B.id:cfg_Msg_MRR_0x25B(aDlc, data);break;
    case CAN_ADAS::MRR_0x32C.id:cfg_Msg_MRR_0x32C(aDlc, data);break;
    case CAN_ADAS::MRR_0x33C.id:cfg_Msg_MRR_0x33C(aDlc, data);break;
    case CAN_ADAS::MRR_0x340.id:cfg_Msg_MRR_0x340(aDlc, data);break;
    case CAN_ADAS::MRR_0x347.id:cfg_Msg_MRR_0x347(aDlc, data);break;
    case CAN_ADAS::MCAM_VMI_01.id:cfg_Msg_MCAM_VMI_01(aDlc, data);break;
    case CAN_ADAS::ADAS_0x4BA_HMI.id:cfg_Msg_ADAS_0x4BA_HMI(aDlc, data);break;
    case CAN_ADAS::ADAS_0x4BC_HMI.id:cfg_Msg_ADAS_0x4BC_HMI(aDlc, data);break;
    case CAN_ADAS::ADAS_0x4BD_HMI.id:cfg_Msg_ADAS_0x4BD_HMI(aDlc, data);break;
    case CAN_ADAS::ADAS_0x4BE_HMI.id:cfg_Msg_ADAS_0x4BE_HMI(aDlc, data);break;
    case CAN_ADAS::VMCMain11.id:cfg_Msg_VMCMain11(aDlc, data);break;
    case CAN_ADAS::VMCMain12.id:cfg_Msg_VMCMain12(aDlc, data);break;
    case CAN_ADAS::DASyToFleaTP.id:cfg_Msg_DASyToFleaTP(aDlc, data);break;
    case CAN_ADAS::SW_ID_DASy.id:cfg_Msg_SW_ID_DASy(aDlc, data);break;
    case CAN_ADAS::SW_ID_RadarFront.id:cfg_Msg_SW_ID_RadarFront(aDlc, data);break;
    default :;//write("Node:DASy ::No Cyclic event");
           break;
  }
  return 1; // don't prevent sending of the message
}

on sysvar CAN_ADAS::ACC_06_DASy::ACC_06_DASy_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ACC_06_DASy);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ACC_06_DASy);
      }
}

void cfg_Msg_ACC_06_DASy(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ACC_06_DASy.DataLength;//Message Data Length
   Msg_id  = Msg_ACC_06_DASy.id;//Message ID
   
    if (@CAN_ADAS::ACC_06_DASy::ACC_06_AliveCounter_D_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,12,15,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::ACC_06_DASy::ACC_06_AliveCounter_D_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_ACC_06_DASy_ACC_06_AliveCounter_D;
      counter_ACC_06_DASy_ACC_06_AliveCounter_D %=15;

      copyBitsToByteArrayBE(counter_ACC_06_DASy_ACC_06_AliveCounter_D,data,12,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ACC_06_DASy::ACC_06_AliveCounter_D_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,12,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ACC_06_DASy::ACC_06_AliveCounter_D_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_ACC_06_DASy_ACC_06_AliveCounter_D,data,12,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::ACC_06_DASy::ACC_06_CheckSum_D_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::ACC_06_DASy::ACC_06_CheckSum_D_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_ACC_06_DASy_ACC_06_CheckSum_D = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_ACC_06_DASy_ACC_06_CheckSum_D,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ACC_06_DASy::ACC_06_CheckSum_D_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ACC_06_DASy::ACC_06_CheckSum_D_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_ACC_06_DASy_ACC_06_CheckSum_D,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::ADAS2EPS_0x1C1::ADAS2EPS_0x1C1_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ADAS2EPS_0x1C1);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ADAS2EPS_0x1C1);
      }
}

void cfg_Msg_ADAS2EPS_0x1C1(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ADAS2EPS_0x1C1.DataLength;//Message Data Length
   Msg_id  = Msg_ADAS2EPS_0x1C1.id;//Message ID
   
    if (@CAN_ADAS::ADAS2EPS_0x1C1::ADAS_1C1_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::ADAS2EPS_0x1C1::ADAS_1C1_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_ADAS2EPS_0x1C1_ADAS_1C1_AliveCounter;
      counter_ADAS2EPS_0x1C1_ADAS_1C1_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_ADAS2EPS_0x1C1_ADAS_1C1_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ADAS2EPS_0x1C1::ADAS_1C1_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::ADAS2EPS_0x1C1::ADAS_1C1_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_ADAS2EPS_0x1C1_ADAS_1C1_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::ADAS2EPS_0x1C1::ADAS_1C1_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::ADAS2EPS_0x1C1::ADAS_1C1_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_ADAS2EPS_0x1C1_ADAS_1C1_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_ADAS2EPS_0x1C1_ADAS_1C1_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ADAS2EPS_0x1C1::ADAS_1C1_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::ADAS2EPS_0x1C1::ADAS_1C1_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_ADAS2EPS_0x1C1_ADAS_1C1_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::ADAS_0x4BA_HMI::ADAS_0x4BA_HMI_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ADAS_0x4BA_HMI);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_0x4BA_HMI);
      }
}

void cfg_Msg_ADAS_0x4BA_HMI(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ADAS_0x4BA_HMI.DataLength;//Message Data Length
   Msg_id  = Msg_ADAS_0x4BA_HMI.id;//Message ID
   
    if (@CAN_ADAS::ADAS_0x4BA_HMI::ADAS_4BA_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_ADAS::ADAS_0x4BA_HMI::ADAS_4BA_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_ADAS_0x4BA_HMI_ADAS_4BA_AliveCounter;
      counter_ADAS_0x4BA_HMI_ADAS_4BA_AliveCounter %=255;

      copyBitsToByteArrayLE(counter_ADAS_0x4BA_HMI_ADAS_4BA_AliveCounter,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::ADAS_0x4BA_HMI::ADAS_4BA_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::ADAS_0x4BA_HMI::ADAS_4BA_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_ADAS_0x4BA_HMI_ADAS_4BA_AliveCounter,data,16,8); //Intel / little-endian;
    }
    if (@CAN_ADAS::ADAS_0x4BA_HMI::ADAS_4BA_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_ADAS::ADAS_0x4BA_HMI::ADAS_4BA_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      chksum_ADAS_0x4BA_HMI_ADAS_4BA_CheckSum = crcTemp;

      copyBitsToByteArrayLE(chksum_ADAS_0x4BA_HMI_ADAS_4BA_CheckSum,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::ADAS_0x4BA_HMI::ADAS_4BA_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::ADAS_0x4BA_HMI::ADAS_4BA_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(chksum_ADAS_0x4BA_HMI_ADAS_4BA_CheckSum,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::ADAS_0x4BC_HMI::ADAS_0x4BC_HMI_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ADAS_0x4BC_HMI);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_0x4BC_HMI);
      }
}

void cfg_Msg_ADAS_0x4BC_HMI(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ADAS_0x4BC_HMI.DataLength;//Message Data Length
   Msg_id  = Msg_ADAS_0x4BC_HMI.id;//Message ID
   
}


on sysvar CAN_ADAS::ADAS_0x4BD_HMI::ADAS_0x4BD_HMI_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ADAS_0x4BD_HMI);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_0x4BD_HMI);
      }
}

void cfg_Msg_ADAS_0x4BD_HMI(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ADAS_0x4BD_HMI.DataLength;//Message Data Length
   Msg_id  = Msg_ADAS_0x4BD_HMI.id;//Message ID
   
}


on sysvar CAN_ADAS::ADAS_0x4BE_HMI::ADAS_0x4BE_HMI_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::ADAS_0x4BE_HMI);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::ADAS_0x4BE_HMI);
      }
}

void cfg_Msg_ADAS_0x4BE_HMI(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_ADAS_0x4BE_HMI.DataLength;//Message Data Length
   Msg_id  = Msg_ADAS_0x4BE_HMI.id;//Message ID
   
    if (@CAN_ADAS::ADAS_0x4BE_HMI::ACCplusIsActiveSubfeatureCSA_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,9,1); //Intel / little-endian

    }
    if(@CAN_ADAS::ADAS_0x4BE_HMI::ACCplusIsActiveSubfeatureCSA_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_ADAS_0x4BE_HMI_ACCplusIsActiveSubfeatureCSA = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(chksum_ADAS_0x4BE_HMI_ACCplusIsActiveSubfeatureCSA,data,9,1); //Intel / little-endian;
    }
    else if(@CAN_ADAS::ADAS_0x4BE_HMI::ACCplusIsActiveSubfeatureCSA_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,9,1); //Intel / little-endian;
    }
    else if(@CAN_ADAS::ADAS_0x4BE_HMI::ACCplusIsActiveSubfeatureCSA_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(chksum_ADAS_0x4BE_HMI_ACCplusIsActiveSubfeatureCSA,data,9,1); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::DASyToFleaTP::DASyToFleaTP_ON_OFF
{
  if (@this == 1)
  {
     ILSetMsgEvent(CAN_ADAS::DASyToFleaTP);
     @CAN_ADAS::DASyToFleaTP::DASyToFleaTP_ON_OFF = 0;
  }
}

void cfg_Msg_DASyToFleaTP(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_DASyToFleaTP.DataLength;//Message Data Length
   Msg_id  = Msg_DASyToFleaTP.id;//Message ID
   
}


on sysvar CAN_ADAS::MCAM_VMI_01::MCAM_VMI_01_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::MCAM_VMI_01);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::MCAM_VMI_01);
      }
}

void cfg_Msg_MCAM_VMI_01(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_MCAM_VMI_01.DataLength;//Message Data Length
   Msg_id  = Msg_MCAM_VMI_01.id;//Message ID
   
    if (@CAN_ADAS::MCAM_VMI_01::MCAM_VMI_01_BZ_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_ADAS::MCAM_VMI_01::MCAM_VMI_01_BZ_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_MCAM_VMI_01_MCAM_VMI_01_BZ;
      counter_MCAM_VMI_01_MCAM_VMI_01_BZ %=15;

      copyBitsToByteArrayLE(counter_MCAM_VMI_01_MCAM_VMI_01_BZ,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::MCAM_VMI_01::MCAM_VMI_01_BZ_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::MCAM_VMI_01::MCAM_VMI_01_BZ_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_MCAM_VMI_01_MCAM_VMI_01_BZ,data,8,4); //Intel / little-endian;
    }
    if (@CAN_ADAS::MCAM_VMI_01::MCAM_VMI_01_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_ADAS::MCAM_VMI_01::MCAM_VMI_01_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      crc_MCAM_VMI_01_MCAM_VMI_01_CRC = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(crc_MCAM_VMI_01_MCAM_VMI_01_CRC,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ADAS::MCAM_VMI_01::MCAM_VMI_01_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ADAS::MCAM_VMI_01::MCAM_VMI_01_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_MCAM_VMI_01_MCAM_VMI_01_CRC,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::MRR_0x1C0::MRR_0x1C0_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::MRR_0x1C0);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::MRR_0x1C0);
      }
}

void cfg_Msg_MRR_0x1C0(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_MRR_0x1C0.DataLength;//Message Data Length
   Msg_id  = Msg_MRR_0x1C0.id;//Message ID
   
    if (@CAN_ADAS::MRR_0x1C0::ADAS_1C0_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::MRR_0x1C0::ADAS_1C0_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_MRR_0x1C0_ADAS_1C0_AliveCounter;
      counter_MRR_0x1C0_ADAS_1C0_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_MRR_0x1C0_ADAS_1C0_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::MRR_0x1C0::ADAS_1C0_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::MRR_0x1C0::ADAS_1C0_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_MRR_0x1C0_ADAS_1C0_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::MRR_0x1C0::ADAS_1C0_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::MRR_0x1C0::ADAS_1C0_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_MRR_0x1C0_ADAS_1C0_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_MRR_0x1C0_ADAS_1C0_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::MRR_0x1C0::ADAS_1C0_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::MRR_0x1C0::ADAS_1C0_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_MRR_0x1C0_ADAS_1C0_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::MRR_0x254::MRR_0x254_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::MRR_0x254);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::MRR_0x254);
      }
}

void cfg_Msg_MRR_0x254(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_MRR_0x254.DataLength;//Message Data Length
   Msg_id  = Msg_MRR_0x254.id;//Message ID
   
    if (@CAN_ADAS::MRR_0x254::ADAS_254_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::MRR_0x254::ADAS_254_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_MRR_0x254_ADAS_254_AliveCounter;
      counter_MRR_0x254_ADAS_254_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_MRR_0x254_ADAS_254_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::MRR_0x254::ADAS_254_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::MRR_0x254::ADAS_254_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_MRR_0x254_ADAS_254_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::MRR_0x254::ADAS_254_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::MRR_0x254::ADAS_254_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_MRR_0x254_ADAS_254_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_MRR_0x254_ADAS_254_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::MRR_0x254::ADAS_254_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::MRR_0x254::ADAS_254_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_MRR_0x254_ADAS_254_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::MRR_0x25A::MRR_0x25A_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::MRR_0x25A);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::MRR_0x25A);
      }
}

void cfg_Msg_MRR_0x25A(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_MRR_0x25A.DataLength;//Message Data Length
   Msg_id  = Msg_MRR_0x25A.id;//Message ID
   
    if (@CAN_ADAS::MRR_0x25A::ADAS_25A_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayBE(data,8,11,4); //Motorola / Big-endian

    }
    if (@CAN_ADAS::MRR_0x25A::ADAS_25A_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_MRR_0x25A_ADAS_25A_AliveCounter;
      counter_MRR_0x25A_ADAS_25A_AliveCounter %=15;

      copyBitsToByteArrayBE(counter_MRR_0x25A_ADAS_25A_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::MRR_0x25A::ADAS_25A_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayBE(0,data,8,4); //Motorola / Big-endian
    }
    else if (@CAN_ADAS::MRR_0x25A::ADAS_25A_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayBE(counter_MRR_0x25A_ADAS_25A_AliveCounter,data,8,4); //Motorola / Big-endian
    }
    if (@CAN_ADAS::MRR_0x25A::ADAS_25A_CheckSum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayBE(data,0,7,8); //Motorola / Big-endian

    }
    if(@CAN_ADAS::MRR_0x25A::ADAS_25A_CheckSum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_MRR_0x25A_ADAS_25A_CheckSum = result_XOR_value ^ xor;

      copyBitsToByteArrayBE(chksum_MRR_0x25A_ADAS_25A_CheckSum,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::MRR_0x25A::ADAS_25A_CheckSum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayBE(0,data,0,8); //Motorola / Big-endian
    }
    else if(@CAN_ADAS::MRR_0x25A::ADAS_25A_CheckSum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayBE(chksum_MRR_0x25A_ADAS_25A_CheckSum,data,0,8); //Motorola / Big-endian
    }
}


on sysvar CAN_ADAS::MRR_0x25B::MRR_0x25B_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::MRR_0x25B);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::MRR_0x25B);
      }
}

void cfg_Msg_MRR_0x25B(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_MRR_0x25B.DataLength;//Message Data Length
   Msg_id  = Msg_MRR_0x25B.id;//Message ID
   
}


on sysvar CAN_ADAS::MRR_0x32C::MRR_0x32C_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::MRR_0x32C);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::MRR_0x32C);
      }
}

void cfg_Msg_MRR_0x32C(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_MRR_0x32C.DataLength;//Message Data Length
   Msg_id  = Msg_MRR_0x32C.id;//Message ID
   
}


on sysvar CAN_ADAS::MRR_0x33C::MRR_0x33C_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::MRR_0x33C);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::MRR_0x33C);
      }
}

void cfg_Msg_MRR_0x33C(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_MRR_0x33C.DataLength;//Message Data Length
   Msg_id  = Msg_MRR_0x33C.id;//Message ID
   
}


on sysvar CAN_ADAS::MRR_0x340::MRR_0x340_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::MRR_0x340);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::MRR_0x340);
      }
}

void cfg_Msg_MRR_0x340(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_MRR_0x340.DataLength;//Message Data Length
   Msg_id  = Msg_MRR_0x340.id;//Message ID
   
}


on sysvar CAN_ADAS::MRR_0x347::MRR_0x347_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::MRR_0x347);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::MRR_0x347);
      }
}

void cfg_Msg_MRR_0x347(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_MRR_0x347.DataLength;//Message Data Length
   Msg_id  = Msg_MRR_0x347.id;//Message ID
   
}


on sysvar CAN_ADAS::SW_ID_DASy::SW_ID_DASy_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::SW_ID_DASy);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::SW_ID_DASy);
      }
}

void cfg_Msg_SW_ID_DASy(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_SW_ID_DASy.DataLength;//Message Data Length
   Msg_id  = Msg_SW_ID_DASy.id;//Message ID
   
}


on sysvar CAN_ADAS::SW_ID_RadarFront::SW_ID_RadarFront_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::SW_ID_RadarFront);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::SW_ID_RadarFront);
      }
}

void cfg_Msg_SW_ID_RadarFront(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_SW_ID_RadarFront.DataLength;//Message Data Length
   Msg_id  = Msg_SW_ID_RadarFront.id;//Message ID
   
}


on sysvar CAN_ADAS::VMCMain11::VMCMain11_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::VMCMain11);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::VMCMain11);
      }
}

void cfg_Msg_VMCMain11(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VMCMain11.DataLength;//Message Data Length
   Msg_id  = Msg_VMCMain11.id;//Message ID
   
    if (@CAN_ADAS::VMCMain11::VMCMain11_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_ADAS::VMCMain11::VMCMain11_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VMCMain11_VMCMain11_AliveCounter;
      counter_VMCMain11_VMCMain11_AliveCounter %=15;

      copyBitsToByteArrayLE(counter_VMCMain11_VMCMain11_AliveCounter,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::VMCMain11::VMCMain11_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::VMCMain11::VMCMain11_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VMCMain11_VMCMain11_AliveCounter,data,8,4); //Intel / little-endian;
    }
    if (@CAN_ADAS::VMCMain11::VMCMain11_Checksum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_ADAS::VMCMain11::VMCMain11_Checksum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_VMCMain11_VMCMain11_Checksum = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(chksum_VMCMain11_VMCMain11_Checksum,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ADAS::VMCMain11::VMCMain11_Checksum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ADAS::VMCMain11::VMCMain11_Checksum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(chksum_VMCMain11_VMCMain11_Checksum,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::VMCMain12::VMCMain12_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::VMCMain12);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::VMCMain12);
      }
}

void cfg_Msg_VMCMain12(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_VMCMain12.DataLength;//Message Data Length
   Msg_id  = Msg_VMCMain12.id;//Message ID
   
    if (@CAN_ADAS::VMCMain12::VMCMain12_AliveCounter_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,8,4); //Intel / little-endian

    }
    if (@CAN_ADAS::VMCMain12::VMCMain12_AliveCounter_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_VMCMain12_VMCMain12_AliveCounter;
      counter_VMCMain12_VMCMain12_AliveCounter %=15;

      copyBitsToByteArrayLE(counter_VMCMain12_VMCMain12_AliveCounter,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::VMCMain12::VMCMain12_AliveCounter_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,8,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::VMCMain12::VMCMain12_AliveCounter_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_VMCMain12_VMCMain12_AliveCounter,data,8,4); //Intel / little-endian;
    }
    if (@CAN_ADAS::VMCMain12::VMCMain12_Checksum_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,8); //Intel / little-endian

    }
    if(@CAN_ADAS::VMCMain12::VMCMain12_Checksum_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      xor = initialization_value;
      for(i = 0; i < DataLength; i++)
      {
        if(i==0)
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[Data_ID_Lookup(Msg_id) ^ xor];
        else
          xor = CRC8_SAE_J1850_Poly_1D_Lookup[ data[i] ^ xor ];
      }
      chksum_VMCMain12_VMCMain12_Checksum = result_XOR_value ^ xor;

      copyBitsToByteArrayLE(chksum_VMCMain12_VMCMain12_Checksum,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ADAS::VMCMain12::VMCMain12_Checksum_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,8); //Intel / little-endian;
    }
    else if(@CAN_ADAS::VMCMain12::VMCMain12_Checksum_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(chksum_VMCMain12_VMCMain12_Checksum,data,0,8); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::ACC_06_DASy::ACC_06_DASy_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ACC_06_DASy,@this);
  //ILFaultInjectionResetMsgCycleTime(ACC_06_DASy);
}

on sysvar CAN_ADAS::MRR_0x1C0::MRR_0x1C0_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::MRR_0x1C0,@this);
  //ILFaultInjectionResetMsgCycleTime(MRR_0x1C0);
}

on sysvar CAN_ADAS::ADAS2EPS_0x1C1::ADAS2EPS_0x1C1_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ADAS2EPS_0x1C1,@this);
  //ILFaultInjectionResetMsgCycleTime(ADAS2EPS_0x1C1);
}

on sysvar CAN_ADAS::MRR_0x254::MRR_0x254_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::MRR_0x254,@this);
  //ILFaultInjectionResetMsgCycleTime(MRR_0x254);
}

on sysvar CAN_ADAS::MRR_0x25A::MRR_0x25A_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::MRR_0x25A,@this);
  //ILFaultInjectionResetMsgCycleTime(MRR_0x25A);
}

on sysvar CAN_ADAS::MRR_0x25B::MRR_0x25B_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::MRR_0x25B,@this);
  //ILFaultInjectionResetMsgCycleTime(MRR_0x25B);
}

on sysvar CAN_ADAS::MRR_0x32C::MRR_0x32C_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::MRR_0x32C,@this);
  //ILFaultInjectionResetMsgCycleTime(MRR_0x32C);
}

on sysvar CAN_ADAS::MRR_0x33C::MRR_0x33C_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::MRR_0x33C,@this);
  //ILFaultInjectionResetMsgCycleTime(MRR_0x33C);
}

on sysvar CAN_ADAS::MRR_0x340::MRR_0x340_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::MRR_0x340,@this);
  //ILFaultInjectionResetMsgCycleTime(MRR_0x340);
}

on sysvar CAN_ADAS::MRR_0x347::MRR_0x347_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::MRR_0x347,@this);
  //ILFaultInjectionResetMsgCycleTime(MRR_0x347);
}

on sysvar CAN_ADAS::MCAM_VMI_01::MCAM_VMI_01_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::MCAM_VMI_01,@this);
  //ILFaultInjectionResetMsgCycleTime(MCAM_VMI_01);
}

on sysvar CAN_ADAS::ADAS_0x4BA_HMI::ADAS_0x4BA_HMI_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ADAS_0x4BA_HMI,@this);
  //ILFaultInjectionResetMsgCycleTime(ADAS_0x4BA_HMI);
}

on sysvar CAN_ADAS::ADAS_0x4BC_HMI::ADAS_0x4BC_HMI_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ADAS_0x4BC_HMI,@this);
  //ILFaultInjectionResetMsgCycleTime(ADAS_0x4BC_HMI);
}

on sysvar CAN_ADAS::ADAS_0x4BD_HMI::ADAS_0x4BD_HMI_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ADAS_0x4BD_HMI,@this);
  //ILFaultInjectionResetMsgCycleTime(ADAS_0x4BD_HMI);
}

on sysvar CAN_ADAS::ADAS_0x4BE_HMI::ADAS_0x4BE_HMI_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::ADAS_0x4BE_HMI,@this);
  //ILFaultInjectionResetMsgCycleTime(ADAS_0x4BE_HMI);
}

on sysvar CAN_ADAS::VMCMain11::VMCMain11_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::VMCMain11,@this);
  //ILFaultInjectionResetMsgCycleTime(VMCMain11);
}

on sysvar CAN_ADAS::VMCMain12::VMCMain12_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::VMCMain12,@this);
  //ILFaultInjectionResetMsgCycleTime(VMCMain12);
}

on sysvar CAN_ADAS::SW_ID_DASy::SW_ID_DASy_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::SW_ID_DASy,@this);
  //ILFaultInjectionResetMsgCycleTime(SW_ID_DASy);
}

on sysvar CAN_ADAS::SW_ID_RadarFront::SW_ID_RadarFront_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::SW_ID_RadarFront,@this);
  //ILFaultInjectionResetMsgCycleTime(SW_ID_RadarFront);
}

void DASy_sim_SetCycleTimeOffset()
{

//  ILNodeSetPDUTimingCyclic (dbMsg dbMessage, long TrueOrFalse, long offset, long period, long disturbanceCount, long flags);
//  TrueOrFalse ; 0: denotes the False timing; 1: denotes the True timing; 3: denotes the True and the False timing.
//  offset :Defines the delay in [ms] from now when the first cyclic transmission will start.
//  period :Defines the period in [ms] for the cyclic transmission.
//  disturbanceCount :Reserved/unused; should be set to -1 (infinite).
//  flags :Reserved; should be set to 0.

}