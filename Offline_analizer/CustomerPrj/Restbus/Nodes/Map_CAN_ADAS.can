/*@!Encoding:1252*/
/**
 * @file Map_CAN_ADAS.can
 * @author ADAS_HIL_TEAM
 * @date 10-04-2022
 * @brief 
 *
 * ################################################################
 * C O P Y R I G H T S
 * ----------------------------------------------------------------
 * Copyright (c) 2022-2023 by Robert Bosch GmbH. All rights reserved.
 
 * The reproduction, distribution and utilization of this file as
 * well as the communication of its contents to others without express
 * authorization is prohibited. Offenders will be held liable for the
 * payment of damages. All rights reserved in the event of the grant
 * of a patent, utility model or design.
 *
 * ################################################################
*/

// Autogenerated by -> Platform\Classe\Scripts\Rbs_Scripts\create_nodes.py
includes
{
  #pragma library ("C:\ProgramData\Vector\AddOn Packages\Vector AddOn\vModules\CANoeILNLVector.vmodule")
  #include "CAPL\DataHandling.cin" /*DataHandling for IL*/
  #include "CAPL\E2E.cin" /*OD Specific for CRC calculation */
}

variables {
  message HDM_GF Msg_HDM_GF;
  message HDM_Curv Msg_HDM_Curv;
  message HDM_Centerline_1 Msg_HDM_Centerline_1;
  message HDM_Centerline_2 Msg_HDM_Centerline_2;
  message HDM_Central_Line_M Msg_HDM_Central_Line_M;
  message HDM_Central_Line_HighR Msg_HDM_Central_Line_HighR;
  message EHR_GNSS_POS Msg_EHR_GNSS_POS;
  message EHR_LOC_POSE Msg_EHR_LOC_POSE;
  message EHR_ReferenceLine1_0x4CA Msg_EHR_ReferenceLine1_0x4CA;
  message EHR_ReferenceLine2_0x4CB Msg_EHR_ReferenceLine2_0x4CB;
  message EHR_Ego_Lane_Info1_0x4CC Msg_EHR_Ego_Lane_Info1_0x4CC;
  message EHR_Ego_Lane_Info2_0x4CD Msg_EHR_Ego_Lane_Info2_0x4CD;
  message EHR_Left_Lane_info_0x4CE Msg_EHR_Left_Lane_info_0x4CE;
  message EHR_Right_Lane_info_0x4CF Msg_EHR_Right_Lane_info_0x4CF;

  word counter_HDM_GF_GF_AliveCtr;
  word counter_HDM_Curv_Cv_AliveCtr;
  word counter_HDM_Centerline_1_centerline_1_AliveCtr;
  word counter_HDM_Centerline_2_centerline_2_AliveCtr;
  word counter_HDM_Central_Line_M_centerline_m_AliveCtr;
  word counter_HDM_Central_Line_HighR_centerline_HR_AliveCtr;
  word counter_EHR_ReferenceLine1_0x4CA_ReferenceLine1_AliveCtr;
  word counter_EHR_ReferenceLine2_0x4CB_ReferenceLine2_AliveCtr;
  word counter_EHR_Ego_Lane_Info1_0x4CC_Ego_Lane_Info1_AliveCtr;
  word counter_EHR_Ego_Lane_Info2_0x4CD_Ego_Lane_Info2_AliveCtr;
  word counter_EHR_Left_Lane_info_0x4CE_Left_Lane_Info_AliveCtr;
  word counter_EHR_Right_Lane_info_0x4CF_Right_Lane_Info_AliveCtr;

  dword bc_HDM_Centerline_1_centerline_1_BlockCtr;
  dword bc_HDM_Centerline_2_centerline_2_BlockCtr;
  dword bc_HDM_Central_Line_M_centerline_m_BlockCtr;
  dword bc_HDM_Central_Line_HighR_centerline_HR_BlockCtr;

  dword crc_HDM_GF_GF_CRC;
  dword crc_HDM_Curv_Cv_CRC;
  dword crc_HDM_Centerline_1_centerline_1_CRC;
  dword crc_HDM_Centerline_2_centerline_2_CRC;
  dword crc_HDM_Central_Line_M_centerline_m_CRC;
  dword crc_HDM_Central_Line_HighR_centerline_HR_CRC;
  dword crc_EHR_ReferenceLine1_0x4CA_ReferenceLine1_CRC;
  dword crc_EHR_ReferenceLine2_0x4CB_ReferenceLine2_CRC;
  dword crc_EHR_Ego_Lane_Info1_0x4CC_Ego_Lane_Info1_CRC;
  dword crc_EHR_Ego_Lane_Info2_0x4CD_Ego_Lane_Info2_CRC;
  dword crc_EHR_Left_Lane_info_0x4CE_Left_Lane_Info_CRC;
  dword crc_EHR_Right_Lane_info_0x4CF_Right_Lane_Info_CRC;

}

on preStart {
  long result;
  result=ILControlInit ();//Initialization of CANoe IL,to prevent the IL autostart function.
  switch(result)
  {
    case  0   : write("ILControlInit :: Map :: No error."); break;
    case -1   : write("ILControlInit :: Map :: Momentary state of the IL does not permit this query."); break;
    case -50  : write("ILControlInit :: Map :: Nodelayer is inactive - possibly deactivated in the nodes configuration dialog.");  break;
   }

  Map_sim_Disable();
  Map_sim_SetCycleTimeOffset();
}

on start {

  ILControlSimulationOn();//Starts the simulation of the IL.
  Map_sim_SetCANFDParameter();
  ILControlStart ();//Cyclical sending starts; setting signals is now possible.
  Map_sim_Reset();
}

on stopMeasurement {

  Map_sim_DisableMsg();
  Map_sim_Disable();
  ILControlStop();//Cyclical sending is stopped; setting signals is now no longer possible.
  ILControlSimulationOff();//Stops the simulation of the IL. After that no other function to control the IL has an effect to the IL.

}

on sysvar_update hil_ctrl::map_sim
{
  Map_sim_Reset();
}

on sysvar_update hil_ctrl::variant
{
  Map_sim_Reset();
}

on sysvar_update Cus_bus::bus_CAN_ADAS_ON_OFF
{
  Map_sim_Reset();
}

void Map_sim_Reset()
{

  Map_sim_DisableMsg();
  Map_sim_Disable();

  if ((@Cus_bus::bus_CAN_ADAS_ON_OFF == 1) && (@hil_ctrl::map_sim == 1))
  {
    switch(@hil_ctrl::variant)
    {
      case a_variant:Map_sim_start_a_variant();break;
      case b_variant:Map_sim_start_b_variant();break;
    }
    if (@hil_ctrl::hil_mode == @hil_ctrl::hil_mode::Restbus) 
    {
       Map_sim_EnableEventMsg();
    }
    else
    {
       Map_sim_DisableEventMsg();
    }
  }
}

void Map_sim_start_a_variant()
{
  @CAN_ADAS::HDM_GF::HDM_GF_ON_OFF = 1;
  @CAN_ADAS::HDM_Curv::HDM_Curv_ON_OFF = 1;
  @CAN_ADAS::HDM_Centerline_1::HDM_Centerline_1_ON_OFF = 1;
  @CAN_ADAS::HDM_Centerline_2::HDM_Centerline_2_ON_OFF = 1;
  @CAN_ADAS::HDM_Central_Line_M::HDM_Central_Line_M_ON_OFF = 1;
  @CAN_ADAS::HDM_Central_Line_HighR::HDM_Central_Line_HighR_ON_OFF = 1;
  @CAN_ADAS::EHR_GNSS_POS::EHR_GNSS_POS_ON_OFF = 1;
  @CAN_ADAS::EHR_LOC_POSE::EHR_LOC_POSE_ON_OFF = 1;
  @CAN_ADAS::EHR_ReferenceLine1_0x4CA::EHR_ReferenceLine1_0x4CA_ON_OFF = 1;
  @CAN_ADAS::EHR_ReferenceLine2_0x4CB::EHR_ReferenceLine2_0x4CB_ON_OFF = 1;
  @CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC::EHR_Ego_Lane_Info1_0x4CC_ON_OFF = 1;
  @CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD::EHR_Ego_Lane_Info2_0x4CD_ON_OFF = 1;
  @CAN_ADAS::EHR_Left_Lane_info_0x4CE::EHR_Left_Lane_info_0x4CE_ON_OFF = 1;
  @CAN_ADAS::EHR_Right_Lane_info_0x4CF::EHR_Right_Lane_info_0x4CF_ON_OFF = 1;
}

void Map_sim_start_b_variant()
{
  @CAN_ADAS::HDM_GF::HDM_GF_ON_OFF = 1;
  @CAN_ADAS::HDM_Curv::HDM_Curv_ON_OFF = 1;
  @CAN_ADAS::HDM_Centerline_1::HDM_Centerline_1_ON_OFF = 1;
  @CAN_ADAS::HDM_Centerline_2::HDM_Centerline_2_ON_OFF = 1;
  @CAN_ADAS::HDM_Central_Line_M::HDM_Central_Line_M_ON_OFF = 1;
  @CAN_ADAS::HDM_Central_Line_HighR::HDM_Central_Line_HighR_ON_OFF = 1;
  @CAN_ADAS::EHR_GNSS_POS::EHR_GNSS_POS_ON_OFF = 1;
  @CAN_ADAS::EHR_LOC_POSE::EHR_LOC_POSE_ON_OFF = 1;
  @CAN_ADAS::EHR_ReferenceLine1_0x4CA::EHR_ReferenceLine1_0x4CA_ON_OFF = 1;
  @CAN_ADAS::EHR_ReferenceLine2_0x4CB::EHR_ReferenceLine2_0x4CB_ON_OFF = 1;
  @CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC::EHR_Ego_Lane_Info1_0x4CC_ON_OFF = 1;
  @CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD::EHR_Ego_Lane_Info2_0x4CD_ON_OFF = 1;
  @CAN_ADAS::EHR_Left_Lane_info_0x4CE::EHR_Left_Lane_info_0x4CE_ON_OFF = 1;
  @CAN_ADAS::EHR_Right_Lane_info_0x4CF::EHR_Right_Lane_info_0x4CF_ON_OFF = 1;
}

void Map_sim_Disable()
{
  @CAN_ADAS::HDM_GF::HDM_GF_ON_OFF = 0;
  @CAN_ADAS::HDM_Curv::HDM_Curv_ON_OFF = 0;
  @CAN_ADAS::HDM_Centerline_1::HDM_Centerline_1_ON_OFF = 0;
  @CAN_ADAS::HDM_Centerline_2::HDM_Centerline_2_ON_OFF = 0;
  @CAN_ADAS::HDM_Central_Line_M::HDM_Central_Line_M_ON_OFF = 0;
  @CAN_ADAS::HDM_Central_Line_HighR::HDM_Central_Line_HighR_ON_OFF = 0;
  @CAN_ADAS::EHR_GNSS_POS::EHR_GNSS_POS_ON_OFF = 0;
  @CAN_ADAS::EHR_LOC_POSE::EHR_LOC_POSE_ON_OFF = 0;
  @CAN_ADAS::EHR_ReferenceLine1_0x4CA::EHR_ReferenceLine1_0x4CA_ON_OFF = 0;
  @CAN_ADAS::EHR_ReferenceLine2_0x4CB::EHR_ReferenceLine2_0x4CB_ON_OFF = 0;
  @CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC::EHR_Ego_Lane_Info1_0x4CC_ON_OFF = 0;
  @CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD::EHR_Ego_Lane_Info2_0x4CD_ON_OFF = 0;
  @CAN_ADAS::EHR_Left_Lane_info_0x4CE::EHR_Left_Lane_info_0x4CE_ON_OFF = 0;
  @CAN_ADAS::EHR_Right_Lane_info_0x4CF::EHR_Right_Lane_info_0x4CF_ON_OFF = 0;
}

void Map_sim_DisableMsg()
{
   ILFaultInjectionDisableMsg(CAN_ADAS::HDM_GF);
   ILFaultInjectionDisableMsg(CAN_ADAS::HDM_Curv);
   ILFaultInjectionDisableMsg(CAN_ADAS::HDM_Centerline_1);
   ILFaultInjectionDisableMsg(CAN_ADAS::HDM_Centerline_2);
   ILFaultInjectionDisableMsg(CAN_ADAS::HDM_Central_Line_M);
   ILFaultInjectionDisableMsg(CAN_ADAS::HDM_Central_Line_HighR);
   ILFaultInjectionDisableMsg(CAN_ADAS::EHR_GNSS_POS);
   ILFaultInjectionDisableMsg(CAN_ADAS::EHR_LOC_POSE);
   ILFaultInjectionDisableMsg(CAN_ADAS::EHR_ReferenceLine1_0x4CA);
   ILFaultInjectionDisableMsg(CAN_ADAS::EHR_ReferenceLine2_0x4CB);
   ILFaultInjectionDisableMsg(CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC);
   ILFaultInjectionDisableMsg(CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD);
   ILFaultInjectionDisableMsg(CAN_ADAS::EHR_Left_Lane_info_0x4CE);
   ILFaultInjectionDisableMsg(CAN_ADAS::EHR_Right_Lane_info_0x4CF);
}
on sysvar hil_ctrl::hil_mode
{
  Map_sim_Reset();
}

void Map_sim_DisableEventMsg()
{

}

void Map_sim_EnableEventMsg()
{

}
void Map_sim_SetCANParameter()
{
  //For future purpose
  //ILFaultInjectionSetMsgDlc(dbMsg msg, dword dlc)
  //ILFaultInjectionSetMsgLength(dbMsg msg, dword msgLength)
  //ILFaultInjectionResetMsgDlc(dbMsg msg)
  //ILFaultInjectionResetMsgLength (dbMsg msg)
}

void Map_sim_SetCANFDParameter()
{
   //CAN FD Parameter Setting
   int FDF =1;
   int BRS =1;
   ILSetCANFDParam(CAN_ADAS::HDM_GF,FDF,BRS,CAN_ADAS::HDM_GF.dlc);
   ILSetCANFDParam(CAN_ADAS::HDM_Curv,FDF,BRS,CAN_ADAS::HDM_Curv.dlc);
   ILSetCANFDParam(CAN_ADAS::HDM_Centerline_1,FDF,BRS,CAN_ADAS::HDM_Centerline_1.dlc);
   ILSetCANFDParam(CAN_ADAS::HDM_Centerline_2,FDF,BRS,CAN_ADAS::HDM_Centerline_2.dlc);
   ILSetCANFDParam(CAN_ADAS::HDM_Central_Line_M,FDF,BRS,CAN_ADAS::HDM_Central_Line_M.dlc);
   ILSetCANFDParam(CAN_ADAS::HDM_Central_Line_HighR,FDF,BRS,CAN_ADAS::HDM_Central_Line_HighR.dlc);
   ILSetCANFDParam(CAN_ADAS::EHR_GNSS_POS,FDF,BRS,CAN_ADAS::EHR_GNSS_POS.dlc);
   ILSetCANFDParam(CAN_ADAS::EHR_LOC_POSE,FDF,BRS,CAN_ADAS::EHR_LOC_POSE.dlc);
   ILSetCANFDParam(CAN_ADAS::EHR_ReferenceLine1_0x4CA,FDF,BRS,CAN_ADAS::EHR_ReferenceLine1_0x4CA.dlc);
   ILSetCANFDParam(CAN_ADAS::EHR_ReferenceLine2_0x4CB,FDF,BRS,CAN_ADAS::EHR_ReferenceLine2_0x4CB.dlc);
   ILSetCANFDParam(CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC,FDF,BRS,CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC.dlc);
   ILSetCANFDParam(CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD,FDF,BRS,CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD.dlc);
   ILSetCANFDParam(CAN_ADAS::EHR_Left_Lane_info_0x4CE,FDF,BRS,CAN_ADAS::EHR_Left_Lane_info_0x4CE.dlc);
   ILSetCANFDParam(CAN_ADAS::EHR_Right_Lane_info_0x4CF,FDF,BRS,CAN_ADAS::EHR_Right_Lane_info_0x4CF.dlc);
}

dword applILTxPending (long aId, dword aDlc, byte data[])//This callback is being called before the IL sends a message to the bus
{
  switch(aId)
  {
    case CAN_ADAS::HDM_GF.id:cfg_Msg_HDM_GF(aDlc, data);break;
    case CAN_ADAS::HDM_Curv.id:cfg_Msg_HDM_Curv(aDlc, data);break;
    case CAN_ADAS::HDM_Centerline_1.id:cfg_Msg_HDM_Centerline_1(aDlc, data);break;
    case CAN_ADAS::HDM_Centerline_2.id:cfg_Msg_HDM_Centerline_2(aDlc, data);break;
    case CAN_ADAS::HDM_Central_Line_M.id:cfg_Msg_HDM_Central_Line_M(aDlc, data);break;
    case CAN_ADAS::HDM_Central_Line_HighR.id:cfg_Msg_HDM_Central_Line_HighR(aDlc, data);break;
    case CAN_ADAS::EHR_GNSS_POS.id:cfg_Msg_EHR_GNSS_POS(aDlc, data);break;
    case CAN_ADAS::EHR_LOC_POSE.id:cfg_Msg_EHR_LOC_POSE(aDlc, data);break;
    case CAN_ADAS::EHR_ReferenceLine1_0x4CA.id:cfg_Msg_EHR_ReferenceLine1_0x4CA(aDlc, data);break;
    case CAN_ADAS::EHR_ReferenceLine2_0x4CB.id:cfg_Msg_EHR_ReferenceLine2_0x4CB(aDlc, data);break;
    case CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC.id:cfg_Msg_EHR_Ego_Lane_Info1_0x4CC(aDlc, data);break;
    case CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD.id:cfg_Msg_EHR_Ego_Lane_Info2_0x4CD(aDlc, data);break;
    case CAN_ADAS::EHR_Left_Lane_info_0x4CE.id:cfg_Msg_EHR_Left_Lane_info_0x4CE(aDlc, data);break;
    case CAN_ADAS::EHR_Right_Lane_info_0x4CF.id:cfg_Msg_EHR_Right_Lane_info_0x4CF(aDlc, data);break;
    default :;//write("Node:Map ::No Cyclic event");
           break;
  }
  return 1; // don't prevent sending of the message
}

on sysvar CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC::EHR_Ego_Lane_Info1_0x4CC_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC);
      }
}

void cfg_Msg_EHR_Ego_Lane_Info1_0x4CC(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_EHR_Ego_Lane_Info1_0x4CC.DataLength;//Message Data Length
   Msg_id  = Msg_EHR_Ego_Lane_Info1_0x4CC.id;//Message ID
   
    if (@CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC::Ego_Lane_Info1_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC::Ego_Lane_Info1_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_EHR_Ego_Lane_Info1_0x4CC_Ego_Lane_Info1_AliveCtr;
      counter_EHR_Ego_Lane_Info1_0x4CC_Ego_Lane_Info1_AliveCtr %=255;

      copyBitsToByteArrayLE(counter_EHR_Ego_Lane_Info1_0x4CC_Ego_Lane_Info1_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC::Ego_Lane_Info1_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC::Ego_Lane_Info1_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_EHR_Ego_Lane_Info1_0x4CC_Ego_Lane_Info1_AliveCtr,data,16,8); //Intel / little-endian;
    }

    clearBitsInByteArrayLE(data,24,20); //Intel / little-endian

    //Msg_EHR_Ego_Lane_Info1_0x4CC.Ego_Lane_Info1_TimeStamp = @CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC::Ego_Lane_Info1_TimeStamp_FaultInject +(timeNowNS()/1000000);

      copyBitsToByteArrayLE(@CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC::Ego_Lane_Info1_TimeStamp_FaultInject +(timeNowNS()/1000000),data,24,20); //Intel / little-endian;
    if (@CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC::Ego_Lane_Info1_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC::Ego_Lane_Info1_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_EHR_Ego_Lane_Info1_0x4CC_Ego_Lane_Info1_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_EHR_Ego_Lane_Info1_0x4CC_Ego_Lane_Info1_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC::Ego_Lane_Info1_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC::Ego_Lane_Info1_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_EHR_Ego_Lane_Info1_0x4CC_Ego_Lane_Info1_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD::EHR_Ego_Lane_Info2_0x4CD_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD);
      }
}

void cfg_Msg_EHR_Ego_Lane_Info2_0x4CD(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_EHR_Ego_Lane_Info2_0x4CD.DataLength;//Message Data Length
   Msg_id  = Msg_EHR_Ego_Lane_Info2_0x4CD.id;//Message ID
   
    if (@CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD::Ego_Lane_Info2_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD::Ego_Lane_Info2_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_EHR_Ego_Lane_Info2_0x4CD_Ego_Lane_Info2_AliveCtr;
      counter_EHR_Ego_Lane_Info2_0x4CD_Ego_Lane_Info2_AliveCtr %=255;

      copyBitsToByteArrayLE(counter_EHR_Ego_Lane_Info2_0x4CD_Ego_Lane_Info2_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD::Ego_Lane_Info2_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD::Ego_Lane_Info2_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_EHR_Ego_Lane_Info2_0x4CD_Ego_Lane_Info2_AliveCtr,data,16,8); //Intel / little-endian;
    }

    clearBitsInByteArrayLE(data,24,20); //Intel / little-endian

    //Msg_EHR_Ego_Lane_Info2_0x4CD.Ego_Lane_Info2_TimeStamp = @CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD::Ego_Lane_Info2_TimeStamp_FaultInject +(timeNowNS()/1000000);

      copyBitsToByteArrayLE(@CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD::Ego_Lane_Info2_TimeStamp_FaultInject +(timeNowNS()/1000000),data,24,20); //Intel / little-endian;
    if (@CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD::Ego_Lane_Info2_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD::Ego_Lane_Info2_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_EHR_Ego_Lane_Info2_0x4CD_Ego_Lane_Info2_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_EHR_Ego_Lane_Info2_0x4CD_Ego_Lane_Info2_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD::Ego_Lane_Info2_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD::Ego_Lane_Info2_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_EHR_Ego_Lane_Info2_0x4CD_Ego_Lane_Info2_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::EHR_GNSS_POS::EHR_GNSS_POS_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::EHR_GNSS_POS);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::EHR_GNSS_POS);
      }
}

void cfg_Msg_EHR_GNSS_POS(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_EHR_GNSS_POS.DataLength;//Message Data Length
   Msg_id  = Msg_EHR_GNSS_POS.id;//Message ID
   
}


on sysvar CAN_ADAS::EHR_LOC_POSE::EHR_LOC_POSE_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::EHR_LOC_POSE);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::EHR_LOC_POSE);
      }
}

void cfg_Msg_EHR_LOC_POSE(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_EHR_LOC_POSE.DataLength;//Message Data Length
   Msg_id  = Msg_EHR_LOC_POSE.id;//Message ID
   
}


on sysvar CAN_ADAS::EHR_Left_Lane_info_0x4CE::EHR_Left_Lane_info_0x4CE_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::EHR_Left_Lane_info_0x4CE);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::EHR_Left_Lane_info_0x4CE);
      }
}

void cfg_Msg_EHR_Left_Lane_info_0x4CE(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_EHR_Left_Lane_info_0x4CE.DataLength;//Message Data Length
   Msg_id  = Msg_EHR_Left_Lane_info_0x4CE.id;//Message ID
   
    if (@CAN_ADAS::EHR_Left_Lane_info_0x4CE::Left_Lane_Info_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_ADAS::EHR_Left_Lane_info_0x4CE::Left_Lane_Info_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_EHR_Left_Lane_info_0x4CE_Left_Lane_Info_AliveCtr;
      counter_EHR_Left_Lane_info_0x4CE_Left_Lane_Info_AliveCtr %=255;

      copyBitsToByteArrayLE(counter_EHR_Left_Lane_info_0x4CE_Left_Lane_Info_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::EHR_Left_Lane_info_0x4CE::Left_Lane_Info_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::EHR_Left_Lane_info_0x4CE::Left_Lane_Info_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_EHR_Left_Lane_info_0x4CE_Left_Lane_Info_AliveCtr,data,16,8); //Intel / little-endian;
    }

    clearBitsInByteArrayLE(data,24,20); //Intel / little-endian

    //Msg_EHR_Left_Lane_info_0x4CE.Left_Lane_Info_TimeStamp = @CAN_ADAS::EHR_Left_Lane_info_0x4CE::Left_Lane_Info_TimeStamp_FaultInject +(timeNowNS()/1000000);

      copyBitsToByteArrayLE(@CAN_ADAS::EHR_Left_Lane_info_0x4CE::Left_Lane_Info_TimeStamp_FaultInject +(timeNowNS()/1000000),data,24,20); //Intel / little-endian;
    if (@CAN_ADAS::EHR_Left_Lane_info_0x4CE::Left_Lane_Info_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_ADAS::EHR_Left_Lane_info_0x4CE::Left_Lane_Info_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_EHR_Left_Lane_info_0x4CE_Left_Lane_Info_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_EHR_Left_Lane_info_0x4CE_Left_Lane_Info_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::EHR_Left_Lane_info_0x4CE::Left_Lane_Info_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::EHR_Left_Lane_info_0x4CE::Left_Lane_Info_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_EHR_Left_Lane_info_0x4CE_Left_Lane_Info_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::EHR_ReferenceLine1_0x4CA::EHR_ReferenceLine1_0x4CA_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::EHR_ReferenceLine1_0x4CA);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::EHR_ReferenceLine1_0x4CA);
      }
}

void cfg_Msg_EHR_ReferenceLine1_0x4CA(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_EHR_ReferenceLine1_0x4CA.DataLength;//Message Data Length
   Msg_id  = Msg_EHR_ReferenceLine1_0x4CA.id;//Message ID
   
    if (@CAN_ADAS::EHR_ReferenceLine1_0x4CA::ReferenceLine1_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_ADAS::EHR_ReferenceLine1_0x4CA::ReferenceLine1_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_EHR_ReferenceLine1_0x4CA_ReferenceLine1_AliveCtr;
      counter_EHR_ReferenceLine1_0x4CA_ReferenceLine1_AliveCtr %=255;

      copyBitsToByteArrayLE(counter_EHR_ReferenceLine1_0x4CA_ReferenceLine1_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::EHR_ReferenceLine1_0x4CA::ReferenceLine1_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::EHR_ReferenceLine1_0x4CA::ReferenceLine1_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_EHR_ReferenceLine1_0x4CA_ReferenceLine1_AliveCtr,data,16,8); //Intel / little-endian;
    }

    clearBitsInByteArrayLE(data,24,20); //Intel / little-endian

    //Msg_EHR_ReferenceLine1_0x4CA.ReferenceLine1_TimeStamp = @CAN_ADAS::EHR_ReferenceLine1_0x4CA::ReferenceLine1_TimeStamp_FaultInject +(timeNowNS()/1000000);

      copyBitsToByteArrayLE(@CAN_ADAS::EHR_ReferenceLine1_0x4CA::ReferenceLine1_TimeStamp_FaultInject +(timeNowNS()/1000000),data,24,20); //Intel / little-endian;
    if (@CAN_ADAS::EHR_ReferenceLine1_0x4CA::ReferenceLine1_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_ADAS::EHR_ReferenceLine1_0x4CA::ReferenceLine1_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_EHR_ReferenceLine1_0x4CA_ReferenceLine1_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_EHR_ReferenceLine1_0x4CA_ReferenceLine1_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::EHR_ReferenceLine1_0x4CA::ReferenceLine1_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::EHR_ReferenceLine1_0x4CA::ReferenceLine1_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_EHR_ReferenceLine1_0x4CA_ReferenceLine1_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::EHR_ReferenceLine2_0x4CB::EHR_ReferenceLine2_0x4CB_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::EHR_ReferenceLine2_0x4CB);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::EHR_ReferenceLine2_0x4CB);
      }
}

void cfg_Msg_EHR_ReferenceLine2_0x4CB(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_EHR_ReferenceLine2_0x4CB.DataLength;//Message Data Length
   Msg_id  = Msg_EHR_ReferenceLine2_0x4CB.id;//Message ID
   
    if (@CAN_ADAS::EHR_ReferenceLine2_0x4CB::ReferenceLine2_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_ADAS::EHR_ReferenceLine2_0x4CB::ReferenceLine2_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_EHR_ReferenceLine2_0x4CB_ReferenceLine2_AliveCtr;
      counter_EHR_ReferenceLine2_0x4CB_ReferenceLine2_AliveCtr %=255;

      copyBitsToByteArrayLE(counter_EHR_ReferenceLine2_0x4CB_ReferenceLine2_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::EHR_ReferenceLine2_0x4CB::ReferenceLine2_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::EHR_ReferenceLine2_0x4CB::ReferenceLine2_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_EHR_ReferenceLine2_0x4CB_ReferenceLine2_AliveCtr,data,16,8); //Intel / little-endian;
    }

    clearBitsInByteArrayLE(data,24,20); //Intel / little-endian

    //Msg_EHR_ReferenceLine2_0x4CB.ReferenceLine2_TimeStamp = @CAN_ADAS::EHR_ReferenceLine2_0x4CB::ReferenceLine2_TimeStamp_FaultInject +(timeNowNS()/1000000);

      copyBitsToByteArrayLE(@CAN_ADAS::EHR_ReferenceLine2_0x4CB::ReferenceLine2_TimeStamp_FaultInject +(timeNowNS()/1000000),data,24,20); //Intel / little-endian;
    if (@CAN_ADAS::EHR_ReferenceLine2_0x4CB::ReferenceLine2_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_ADAS::EHR_ReferenceLine2_0x4CB::ReferenceLine2_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_EHR_ReferenceLine2_0x4CB_ReferenceLine2_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_EHR_ReferenceLine2_0x4CB_ReferenceLine2_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::EHR_ReferenceLine2_0x4CB::ReferenceLine2_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::EHR_ReferenceLine2_0x4CB::ReferenceLine2_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_EHR_ReferenceLine2_0x4CB_ReferenceLine2_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::EHR_Right_Lane_info_0x4CF::EHR_Right_Lane_info_0x4CF_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::EHR_Right_Lane_info_0x4CF);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::EHR_Right_Lane_info_0x4CF);
      }
}

void cfg_Msg_EHR_Right_Lane_info_0x4CF(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_EHR_Right_Lane_info_0x4CF.DataLength;//Message Data Length
   Msg_id  = Msg_EHR_Right_Lane_info_0x4CF.id;//Message ID
   
    if (@CAN_ADAS::EHR_Right_Lane_info_0x4CF::Right_Lane_Info_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_ADAS::EHR_Right_Lane_info_0x4CF::Right_Lane_Info_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_EHR_Right_Lane_info_0x4CF_Right_Lane_Info_AliveCtr;
      counter_EHR_Right_Lane_info_0x4CF_Right_Lane_Info_AliveCtr %=255;

      copyBitsToByteArrayLE(counter_EHR_Right_Lane_info_0x4CF_Right_Lane_Info_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::EHR_Right_Lane_info_0x4CF::Right_Lane_Info_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::EHR_Right_Lane_info_0x4CF::Right_Lane_Info_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_EHR_Right_Lane_info_0x4CF_Right_Lane_Info_AliveCtr,data,16,8); //Intel / little-endian;
    }

    clearBitsInByteArrayLE(data,24,20); //Intel / little-endian

    //Msg_EHR_Right_Lane_info_0x4CF.Right_Lane_Info_TimeStamp = @CAN_ADAS::EHR_Right_Lane_info_0x4CF::Right_Lane_Info_TimeStamp_FaultInject +(timeNowNS()/1000000);

      copyBitsToByteArrayLE(@CAN_ADAS::EHR_Right_Lane_info_0x4CF::Right_Lane_Info_TimeStamp_FaultInject +(timeNowNS()/1000000),data,24,20); //Intel / little-endian;
    if (@CAN_ADAS::EHR_Right_Lane_info_0x4CF::Right_Lane_Info_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_ADAS::EHR_Right_Lane_info_0x4CF::Right_Lane_Info_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_EHR_Right_Lane_info_0x4CF_Right_Lane_Info_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_EHR_Right_Lane_info_0x4CF_Right_Lane_Info_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::EHR_Right_Lane_info_0x4CF::Right_Lane_Info_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::EHR_Right_Lane_info_0x4CF::Right_Lane_Info_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_EHR_Right_Lane_info_0x4CF_Right_Lane_Info_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::HDM_Centerline_1::HDM_Centerline_1_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::HDM_Centerline_1);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::HDM_Centerline_1);
      }
}

void cfg_Msg_HDM_Centerline_1(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_HDM_Centerline_1.DataLength;//Message Data Length
   Msg_id  = Msg_HDM_Centerline_1.id;//Message ID
   
    if (@CAN_ADAS::HDM_Centerline_1::centerline_1_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_ADAS::HDM_Centerline_1::centerline_1_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_HDM_Centerline_1_centerline_1_AliveCtr;
      counter_HDM_Centerline_1_centerline_1_AliveCtr %=255;

      copyBitsToByteArrayLE(counter_HDM_Centerline_1_centerline_1_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Centerline_1::centerline_1_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Centerline_1::centerline_1_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_HDM_Centerline_1_centerline_1_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_ADAS::HDM_Centerline_1::centerline_1_BlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,504,4); //Intel / little-endian

    }
    if (@CAN_ADAS::HDM_Centerline_1::centerline_1_BlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      ++bc_HDM_Centerline_1_centerline_1_BlockCtr;
      bc_HDM_Centerline_1_centerline_1_BlockCtr %=16;

      copyBitsToByteArrayLE(bc_HDM_Centerline_1_centerline_1_BlockCtr,data,504,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Centerline_1::centerline_1_BlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,504,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Centerline_1::centerline_1_BlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_HDM_Centerline_1_centerline_1_BlockCtr,data,504,4); //Intel / little-endian;
    }
    if (@CAN_ADAS::HDM_Centerline_1::centerline_1_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_ADAS::HDM_Centerline_1::centerline_1_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_HDM_Centerline_1_centerline_1_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_HDM_Centerline_1_centerline_1_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::HDM_Centerline_1::centerline_1_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::HDM_Centerline_1::centerline_1_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_HDM_Centerline_1_centerline_1_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::HDM_Centerline_2::HDM_Centerline_2_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::HDM_Centerline_2);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::HDM_Centerline_2);
      }
}

void cfg_Msg_HDM_Centerline_2(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_HDM_Centerline_2.DataLength;//Message Data Length
   Msg_id  = Msg_HDM_Centerline_2.id;//Message ID
   
    if (@CAN_ADAS::HDM_Centerline_2::centerline_2_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_ADAS::HDM_Centerline_2::centerline_2_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_HDM_Centerline_2_centerline_2_AliveCtr;
      counter_HDM_Centerline_2_centerline_2_AliveCtr %=255;

      copyBitsToByteArrayLE(counter_HDM_Centerline_2_centerline_2_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Centerline_2::centerline_2_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Centerline_2::centerline_2_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_HDM_Centerline_2_centerline_2_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_ADAS::HDM_Centerline_2::centerline_2_BlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,472,4); //Intel / little-endian

    }
    if (@CAN_ADAS::HDM_Centerline_2::centerline_2_BlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      ++bc_HDM_Centerline_2_centerline_2_BlockCtr;
      bc_HDM_Centerline_2_centerline_2_BlockCtr %=16;

      copyBitsToByteArrayLE(bc_HDM_Centerline_2_centerline_2_BlockCtr,data,472,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Centerline_2::centerline_2_BlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,472,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Centerline_2::centerline_2_BlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_HDM_Centerline_2_centerline_2_BlockCtr,data,472,4); //Intel / little-endian;
    }

    clearBitsInByteArrayLE(data,452,20); //Intel / little-endian

    //Msg_HDM_Centerline_2.Timestamp = @CAN_ADAS::HDM_Centerline_2::Timestamp_FaultInject +(timeNowNS()/1000000);

      copyBitsToByteArrayLE(@CAN_ADAS::HDM_Centerline_2::Timestamp_FaultInject +(timeNowNS()/1000000),data,452,20); //Intel / little-endian;
    if (@CAN_ADAS::HDM_Centerline_2::centerline_2_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_ADAS::HDM_Centerline_2::centerline_2_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_HDM_Centerline_2_centerline_2_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_HDM_Centerline_2_centerline_2_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::HDM_Centerline_2::centerline_2_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::HDM_Centerline_2::centerline_2_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_HDM_Centerline_2_centerline_2_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::HDM_Central_Line_HighR::HDM_Central_Line_HighR_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::HDM_Central_Line_HighR);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::HDM_Central_Line_HighR);
      }
}

void cfg_Msg_HDM_Central_Line_HighR(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_HDM_Central_Line_HighR.DataLength;//Message Data Length
   Msg_id  = Msg_HDM_Central_Line_HighR.id;//Message ID
   
    if (@CAN_ADAS::HDM_Central_Line_HighR::centerline_HR_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_ADAS::HDM_Central_Line_HighR::centerline_HR_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_HDM_Central_Line_HighR_centerline_HR_AliveCtr;
      counter_HDM_Central_Line_HighR_centerline_HR_AliveCtr %=255;

      copyBitsToByteArrayLE(counter_HDM_Central_Line_HighR_centerline_HR_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Central_Line_HighR::centerline_HR_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Central_Line_HighR::centerline_HR_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_HDM_Central_Line_HighR_centerline_HR_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_ADAS::HDM_Central_Line_HighR::centerline_HR_BlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_ADAS::HDM_Central_Line_HighR::centerline_HR_BlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      ++bc_HDM_Central_Line_HighR_centerline_HR_BlockCtr;
      bc_HDM_Central_Line_HighR_centerline_HR_BlockCtr %=16;

      copyBitsToByteArrayLE(bc_HDM_Central_Line_HighR_centerline_HR_BlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Central_Line_HighR::centerline_HR_BlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Central_Line_HighR::centerline_HR_BlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_HDM_Central_Line_HighR_centerline_HR_BlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_ADAS::HDM_Central_Line_HighR::centerline_HR_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_ADAS::HDM_Central_Line_HighR::centerline_HR_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_HDM_Central_Line_HighR_centerline_HR_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_HDM_Central_Line_HighR_centerline_HR_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::HDM_Central_Line_HighR::centerline_HR_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::HDM_Central_Line_HighR::centerline_HR_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_HDM_Central_Line_HighR_centerline_HR_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::HDM_Central_Line_M::HDM_Central_Line_M_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::HDM_Central_Line_M);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::HDM_Central_Line_M);
      }
}

void cfg_Msg_HDM_Central_Line_M(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_HDM_Central_Line_M.DataLength;//Message Data Length
   Msg_id  = Msg_HDM_Central_Line_M.id;//Message ID
   
    if (@CAN_ADAS::HDM_Central_Line_M::centerline_m_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_ADAS::HDM_Central_Line_M::centerline_m_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_HDM_Central_Line_M_centerline_m_AliveCtr;
      counter_HDM_Central_Line_M_centerline_m_AliveCtr %=255;

      copyBitsToByteArrayLE(counter_HDM_Central_Line_M_centerline_m_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Central_Line_M::centerline_m_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Central_Line_M::centerline_m_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_HDM_Central_Line_M_centerline_m_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_ADAS::HDM_Central_Line_M::centerline_m_BlockCtr_FaultInject != 3)//BC: user defined value
    {

    clearBitsInByteArrayLE(data,24,4); //Intel / little-endian

    }
    if (@CAN_ADAS::HDM_Central_Line_M::centerline_m_BlockCtr_FaultInject == 0)//BC: No Error, calculate BC
    {
      ++bc_HDM_Central_Line_M_centerline_m_BlockCtr;
      bc_HDM_Central_Line_M_centerline_m_BlockCtr %=16;

      copyBitsToByteArrayLE(bc_HDM_Central_Line_M_centerline_m_BlockCtr,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Central_Line_M::centerline_m_BlockCtr_FaultInject == 1)//BC: Error sequence: set BC = 0
    {

      copyBitsToByteArrayLE(0,data,24,4); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Central_Line_M::centerline_m_BlockCtr_FaultInject == 2)//BC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(bc_HDM_Central_Line_M_centerline_m_BlockCtr,data,24,4); //Intel / little-endian;
    }
    if (@CAN_ADAS::HDM_Central_Line_M::centerline_m_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_ADAS::HDM_Central_Line_M::centerline_m_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_HDM_Central_Line_M_centerline_m_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_HDM_Central_Line_M_centerline_m_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::HDM_Central_Line_M::centerline_m_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::HDM_Central_Line_M::centerline_m_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_HDM_Central_Line_M_centerline_m_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::HDM_Curv::HDM_Curv_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::HDM_Curv);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::HDM_Curv);
      }
}

void cfg_Msg_HDM_Curv(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_HDM_Curv.DataLength;//Message Data Length
   Msg_id  = Msg_HDM_Curv.id;//Message ID
   
    if (@CAN_ADAS::HDM_Curv::Cv_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_ADAS::HDM_Curv::Cv_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_HDM_Curv_Cv_AliveCtr;
      counter_HDM_Curv_Cv_AliveCtr %=255;

      copyBitsToByteArrayLE(counter_HDM_Curv_Cv_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Curv::Cv_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_Curv::Cv_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_HDM_Curv_Cv_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_ADAS::HDM_Curv::Cv_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_ADAS::HDM_Curv::Cv_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_HDM_Curv_Cv_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_HDM_Curv_Cv_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::HDM_Curv::Cv_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::HDM_Curv::Cv_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_HDM_Curv_Cv_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::HDM_GF::HDM_GF_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::HDM_GF);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::HDM_GF);
      }
}

void cfg_Msg_HDM_GF(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_HDM_GF.DataLength;//Message Data Length
   Msg_id  = Msg_HDM_GF.id;//Message ID
   
    if (@CAN_ADAS::HDM_GF::GF_AliveCtr_FaultInject != 3)//AC: user defined value
    {

    clearBitsInByteArrayLE(data,16,8); //Intel / little-endian

    }
    if (@CAN_ADAS::HDM_GF::GF_AliveCtr_FaultInject == 0)//AC: No Error, calculate AC
    {
      ++counter_HDM_GF_GF_AliveCtr;
      counter_HDM_GF_GF_AliveCtr %=255;

      copyBitsToByteArrayLE(counter_HDM_GF_GF_AliveCtr,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_GF::GF_AliveCtr_FaultInject == 1)//AC: Error sequence: set AC = 0
    {

      copyBitsToByteArrayLE(0,data,16,8); //Intel / little-endian;
    }
    else if (@CAN_ADAS::HDM_GF::GF_AliveCtr_FaultInject == 2)//AC: Error sequence: Freeze last valid value
    {

      copyBitsToByteArrayLE(counter_HDM_GF_GF_AliveCtr,data,16,8); //Intel / little-endian;
    }
    if (@CAN_ADAS::HDM_GF::GF_CRC_FaultInject != 3)//CRC: user defined value
    {

    clearBitsInByteArrayLE(data,0,16); //Intel / little-endian

    }
    if(@CAN_ADAS::HDM_GF::GF_CRC_FaultInject == 0)//CRC: No Error, calculate CRC
    {
      crcTemp = CRC16_INIT;
      for(i = 2; i < (DataLength+2); i++)
      {
        if(i < DataLength)
          data_byte = data[i] ;
        else if(i == DataLength)
          data_byte = (Data_ID_Lookup(Msg_id) & 0x00FF);
        else if(i == (DataLength+1))
          data_byte = (Data_ID_Lookup(Msg_id) & 0xFF00) >> 8;
        else
          write("Error: DLC exceeded in CRC calculation");
        crcTemp ^= data_byte << 8;
        crcTemp = (crcTemp << (8)) ^ CRC16_CCITT_FALSE_POLY_1021H_Lookup[(crcTemp >> (8)) & (0xFF)];
      }
      crcTemp ^= CRC16_XOR;
      crc_HDM_GF_GF_CRC = crcTemp;

      copyBitsToByteArrayLE(crc_HDM_GF_GF_CRC,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::HDM_GF::GF_CRC_FaultInject == 1)//CRC: Error, set to Zero
    {

      copyBitsToByteArrayLE(0,data,0,16); //Intel / little-endian;
    }
    else if(@CAN_ADAS::HDM_GF::GF_CRC_FaultInject == 2)//CRC: Error, Freeze last valid value
    {

      copyBitsToByteArrayLE(crc_HDM_GF_GF_CRC,data,0,16); //Intel / little-endian;
    }
}


on sysvar CAN_ADAS::HDM_GF::HDM_GF_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::HDM_GF,@this);
  //ILFaultInjectionResetMsgCycleTime(HDM_GF);
}

on sysvar CAN_ADAS::HDM_Curv::HDM_Curv_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::HDM_Curv,@this);
  //ILFaultInjectionResetMsgCycleTime(HDM_Curv);
}

on sysvar CAN_ADAS::HDM_Centerline_1::HDM_Centerline_1_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::HDM_Centerline_1,@this);
  //ILFaultInjectionResetMsgCycleTime(HDM_Centerline_1);
}

on sysvar CAN_ADAS::HDM_Centerline_2::HDM_Centerline_2_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::HDM_Centerline_2,@this);
  //ILFaultInjectionResetMsgCycleTime(HDM_Centerline_2);
}

on sysvar CAN_ADAS::HDM_Central_Line_M::HDM_Central_Line_M_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::HDM_Central_Line_M,@this);
  //ILFaultInjectionResetMsgCycleTime(HDM_Central_Line_M);
}

on sysvar CAN_ADAS::HDM_Central_Line_HighR::HDM_Central_Line_HighR_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::HDM_Central_Line_HighR,@this);
  //ILFaultInjectionResetMsgCycleTime(HDM_Central_Line_HighR);
}

on sysvar CAN_ADAS::EHR_GNSS_POS::EHR_GNSS_POS_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::EHR_GNSS_POS,@this);
  //ILFaultInjectionResetMsgCycleTime(EHR_GNSS_POS);
}

on sysvar CAN_ADAS::EHR_LOC_POSE::EHR_LOC_POSE_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::EHR_LOC_POSE,@this);
  //ILFaultInjectionResetMsgCycleTime(EHR_LOC_POSE);
}

on sysvar CAN_ADAS::EHR_ReferenceLine1_0x4CA::EHR_ReferenceLine1_0x4CA_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::EHR_ReferenceLine1_0x4CA,@this);
  //ILFaultInjectionResetMsgCycleTime(EHR_ReferenceLine1_0x4CA);
}

on sysvar CAN_ADAS::EHR_ReferenceLine2_0x4CB::EHR_ReferenceLine2_0x4CB_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::EHR_ReferenceLine2_0x4CB,@this);
  //ILFaultInjectionResetMsgCycleTime(EHR_ReferenceLine2_0x4CB);
}

on sysvar CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC::EHR_Ego_Lane_Info1_0x4CC_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::EHR_Ego_Lane_Info1_0x4CC,@this);
  //ILFaultInjectionResetMsgCycleTime(EHR_Ego_Lane_Info1_0x4CC);
}

on sysvar CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD::EHR_Ego_Lane_Info2_0x4CD_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::EHR_Ego_Lane_Info2_0x4CD,@this);
  //ILFaultInjectionResetMsgCycleTime(EHR_Ego_Lane_Info2_0x4CD);
}

on sysvar CAN_ADAS::EHR_Left_Lane_info_0x4CE::EHR_Left_Lane_info_0x4CE_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::EHR_Left_Lane_info_0x4CE,@this);
  //ILFaultInjectionResetMsgCycleTime(EHR_Left_Lane_info_0x4CE);
}

on sysvar CAN_ADAS::EHR_Right_Lane_info_0x4CF::EHR_Right_Lane_info_0x4CF_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::EHR_Right_Lane_info_0x4CF,@this);
  //ILFaultInjectionResetMsgCycleTime(EHR_Right_Lane_info_0x4CF);
}

void Map_sim_SetCycleTimeOffset()
{

//  ILNodeSetPDUTimingCyclic (dbMsg dbMessage, long TrueOrFalse, long offset, long period, long disturbanceCount, long flags);
//  TrueOrFalse ; 0: denotes the False timing; 1: denotes the True timing; 3: denotes the True and the False timing.
//  offset :Defines the delay in [ms] from now when the first cyclic transmission will start.
//  period :Defines the period in [ms] for the cyclic transmission.
//  disturbanceCount :Reserved/unused; should be set to -1 (infinite).
//  flags :Reserved; should be set to 0.

}