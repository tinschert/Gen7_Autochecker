/*@!Encoding:1252*/
/**
 * @file IMU_CAN_ADAS.can
 * @author ADAS_HIL_TEAM
 * @date 10-04-2022
 * @brief 
 *
 * ################################################################
 * C O P Y R I G H T S
 * ----------------------------------------------------------------
 * Copyright (c) 2022-2023 by Robert Bosch GmbH. All rights reserved.
 
 * The reproduction, distribution and utilization of this file as
 * well as the communication of its contents to others without express
 * authorization is prohibited. Offenders will be held liable for the
 * payment of damages. All rights reserved in the event of the grant
 * of a patent, utility model or design.
 *
 * ################################################################
*/

// Autogenerated by -> Platform\Classe\Scripts\Rbs_Scripts\create_nodes.py
includes
{
  #pragma library ("C:\ProgramData\Vector\AddOn Packages\Vector AddOn\vModules\CANoeILNLVector.vmodule")
  #include "CAPL\DataHandling.cin" /*DataHandling for IL*/
  #include "CAPL\E2E.cin" /*OD Specific for CRC calculation */
}

variables {
  message IMU_TX1 Msg_IMU_TX1;
  message IMU_TX2 Msg_IMU_TX2;

}

on preStart {
  long result;
  result=ILControlInit ();//Initialization of CANoe IL,to prevent the IL autostart function.
  switch(result)
  {
    case  0   : write("ILControlInit :: IMU :: No error."); break;
    case -1   : write("ILControlInit :: IMU :: Momentary state of the IL does not permit this query."); break;
    case -50  : write("ILControlInit :: IMU :: Nodelayer is inactive - possibly deactivated in the nodes configuration dialog.");  break;
   }

  IMU_sim_Disable();
  IMU_sim_SetCycleTimeOffset();
}

on start {

  ILControlSimulationOn();//Starts the simulation of the IL.
  IMU_sim_SetCANFDParameter();
  ILControlStart ();//Cyclical sending starts; setting signals is now possible.
  IMU_sim_Reset();
}

on stopMeasurement {

  IMU_sim_DisableMsg();
  IMU_sim_Disable();
  ILControlStop();//Cyclical sending is stopped; setting signals is now no longer possible.
  ILControlSimulationOff();//Stops the simulation of the IL. After that no other function to control the IL has an effect to the IL.

}

on sysvar_update hil_ctrl::imu_sim
{
  IMU_sim_Reset();
}

on sysvar_update hil_ctrl::variant
{
  IMU_sim_Reset();
}

on sysvar_update Cus_bus::bus_CAN_ADAS_ON_OFF
{
  IMU_sim_Reset();
}

void IMU_sim_Reset()
{

  IMU_sim_DisableMsg();
  IMU_sim_Disable();

  if ((@Cus_bus::bus_CAN_ADAS_ON_OFF == 1) && (@hil_ctrl::imu_sim == 1))
  {
    switch(@hil_ctrl::variant)
    {
      case a_variant:IMU_sim_start_a_variant();break;
      case b_variant:IMU_sim_start_b_variant();break;
    }
    if (@hil_ctrl::hil_mode == @hil_ctrl::hil_mode::Restbus) 
    {
       IMU_sim_EnableEventMsg();
    }
    else
    {
       IMU_sim_DisableEventMsg();
    }
  }
}

void IMU_sim_start_a_variant()
{
  @CAN_ADAS::IMU_TX1::IMU_TX1_ON_OFF = 1;
  @CAN_ADAS::IMU_TX2::IMU_TX2_ON_OFF = 1;
}

void IMU_sim_start_b_variant()
{
  @CAN_ADAS::IMU_TX1::IMU_TX1_ON_OFF = 1;
  @CAN_ADAS::IMU_TX2::IMU_TX2_ON_OFF = 1;
}

void IMU_sim_Disable()
{
  @CAN_ADAS::IMU_TX1::IMU_TX1_ON_OFF = 0;
  @CAN_ADAS::IMU_TX2::IMU_TX2_ON_OFF = 0;
}

void IMU_sim_DisableMsg()
{
   ILFaultInjectionDisableMsg(CAN_ADAS::IMU_TX1);
   ILFaultInjectionDisableMsg(CAN_ADAS::IMU_TX2);
}
on sysvar hil_ctrl::hil_mode
{
  IMU_sim_Reset();
}

void IMU_sim_DisableEventMsg()
{

}

void IMU_sim_EnableEventMsg()
{

}
void IMU_sim_SetCANParameter()
{
  //For future purpose
  //ILFaultInjectionSetMsgDlc(dbMsg msg, dword dlc)
  //ILFaultInjectionSetMsgLength(dbMsg msg, dword msgLength)
  //ILFaultInjectionResetMsgDlc(dbMsg msg)
  //ILFaultInjectionResetMsgLength (dbMsg msg)
}

void IMU_sim_SetCANFDParameter()
{
   //CAN FD Parameter Setting
   int FDF =1;
   int BRS =1;
   ILSetCANFDParam(CAN_ADAS::IMU_TX1,FDF,BRS,CAN_ADAS::IMU_TX1.dlc);
   ILSetCANFDParam(CAN_ADAS::IMU_TX2,FDF,BRS,CAN_ADAS::IMU_TX2.dlc);
}

dword applILTxPending (long aId, dword aDlc, byte data[])//This callback is being called before the IL sends a message to the bus
{
  switch(aId)
  {
    case CAN_ADAS::IMU_TX1.id:cfg_Msg_IMU_TX1(aDlc, data);break;
    case CAN_ADAS::IMU_TX2.id:cfg_Msg_IMU_TX2(aDlc, data);break;
    default :;//write("Node:IMU ::No Cyclic event");
           break;
  }
  return 1; // don't prevent sending of the message
}

on sysvar CAN_ADAS::IMU_TX1::IMU_TX1_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::IMU_TX1);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::IMU_TX1);
      }
}

void cfg_Msg_IMU_TX1(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_IMU_TX1.DataLength;//Message Data Length
   Msg_id  = Msg_IMU_TX1.id;//Message ID
   
}


on sysvar CAN_ADAS::IMU_TX2::IMU_TX2_ON_OFF
{
  if (@this == 1)
  {
    ILFaultInjectionEnableMsg(CAN_ADAS::IMU_TX2);
  }
  else{
         ILFaultInjectionDisableMsg(CAN_ADAS::IMU_TX2);
      }
}

void cfg_Msg_IMU_TX2(dword aDlc, byte data[])
{
   int64 i,k;//For looping
   byte xor,data_byte;
   dword crcTemp;
   byte DataLength;
   dword Msg_id;
   
   DataLength = Msg_IMU_TX2.DataLength;//Message Data Length
   Msg_id  = Msg_IMU_TX2.id;//Message ID
   
}


on sysvar CAN_ADAS::IMU_TX1::IMU_TX1_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::IMU_TX1,@this);
  //ILFaultInjectionResetMsgCycleTime(IMU_TX1);
}

on sysvar CAN_ADAS::IMU_TX2::IMU_TX2_CycleTime
{
  ILFaultInjectionSetMsgCycleTime(CAN_ADAS::IMU_TX2,@this);
  //ILFaultInjectionResetMsgCycleTime(IMU_TX2);
}

void IMU_sim_SetCycleTimeOffset()
{

//  ILNodeSetPDUTimingCyclic (dbMsg dbMessage, long TrueOrFalse, long offset, long period, long disturbanceCount, long flags);
//  TrueOrFalse ; 0: denotes the False timing; 1: denotes the True timing; 3: denotes the True and the False timing.
//  offset :Defines the delay in [ms] from now when the first cyclic transmission will start.
//  period :Defines the period in [ms] for the cyclic transmission.
//  disturbanceCount :Reserved/unused; should be set to -1 (infinite).
//  flags :Reserved; should be set to 0.

}