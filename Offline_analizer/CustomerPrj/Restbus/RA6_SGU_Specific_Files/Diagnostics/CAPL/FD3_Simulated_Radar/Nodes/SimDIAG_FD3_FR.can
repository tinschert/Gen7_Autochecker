/*@!Encoding:1252*/
/*******************************************************************************
	MODULEFILE_DESCRIPTION:SimDIAG_FD3_FR
	COPYRIGHT:
	Robert Bosch GmbH reserves all rights even in the event of industrial
	property. We reserve all rights of disposal such as copying and passing
	on to third parties.
	COPYRIGHT_END:

	PROJECT:		  Implements Basic UDS functionality as a simulated Ecu Node
	FILENAME:		  SimDIAG_FD3_FR.cin

	DESCRIPTION:  CAPL-Program for DIAG/UDS over CAN/CAN-FD simulation via OSEK_TP.
        REFERENCE  :  Sample Osek Configuration [Vector standards  ]

	HISTORY:
        Version1: 15.11.2023 ; DUE1KOR ; Initial Version 

*****************************************************************************/
includes
{
  #include "CAPL\SimDIAG_FD3_FR.cin"
}

variables
{  
    byte      emptyString[kBufferSizeJumbo];
   
    //Transmit
    const int txSize = 4096;
    byte      TxDataBuffer[kBufferSizeJumbo];
    int       TxLength;
    byte      TxDataBuffer_temp[3]={22,22,22};
    
    dword filehandle_fr = 0;
    char buffer[32000];
    char text[512];
    char path[250] = "..\\CSV\\SimDIAG_FD3_FR_UDS_DTC_map.csv"; //"C:\\_RBS TEAM\\Vishal\\Project 2\\CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FD3_Simulated_Radar\\CSV\\SimDIAG_FD3_FR_UDS_DTC_map.csv"; //"C:\\_RBS TEAM\\Vishal\\Project 2\\CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FD3_Simulated_Radar\\CSV\\New Microsoft Excel Worksheet.xlsx"; //"C:\\_RBS TEAM\\Vishal\\Project 2\\CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FD3_Simulated_Radar\\Database\\Sysvar_SimDiagFD3.xml";// "C:\\_RBS TEAM\\Vishal\\Project 2\\CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FD3_Simulated_Radar\\CSV\\SimDIAG_FD3_FC.csv";  //"..\\CSV\\SimDIAG_FD3_FC.csv";

    //Receive
    const int rxSize = 4098;
    byte      RxDataBuffer[kBufferSizeJumbo];
    int       RxBufferIndex;
    int       RxLength_CAN;        
    char      hexaStr[6];

    //My evaluate
    int 	NrNeededRespBytes = 0;
    int 	ReceiveBufferLength;

    char	MVbuffer[500] = "";
    char	MVbuffer2[500] = "0x";   	

    // Variables for Requests
    int		DirectTxDataLen  = 0;
    int		CurrentDiagServ  = 0;
    int		SId              = 0;
    float 	RespTime         = 0.0;

    //Constants for Diag Switch
    const int TESTER_PRESENT_ON = 0;
    const int DEFAULT_SESSION   = 1;
    const int PROGRAM_SESSION   = 2;
    const int EXTENDED_SESSION	= 3;
    const int BOSCH_SESSION     = 4;
    
    const int ECU_HARD_RESET    = 5;
    const int ECU_SOFT_RESET    = 6;
    const int READ_DTC_BY_ST    = 7;
    const int CLEAR_DTC			    = 8;
    const int DIRECT_RQ			    = 9;
    
//  const int READ_DTC_BY_ST_RBEOL = 89;   

//  const int READ_DTC_PASS     = 13;

    
//  	const int EN_NOR_MSG_TX		= 3;
//  	const int ECU_ID			    = 4;
//  	const int ECU_DEV_ST    	= 5;
//  	const int RD_CAMERA_LEFT    = 8;
//  	const int RD_CAMERA_RIGHT   = 9;
//  	const int RD_SW_VER         = 10;
//  	const int TEST				      = 11;
  
//  	const int RD_SERIAL_NR      = 14;
//  	const int RESET             = 15;
//  	const int START_IR_TEST     = 16;
//  	const int STOP_IR_TEST      = 17;
//  	const int START_IMG_TEST    = 18;
//  	const int STOP_IMG_TEST     = 19;
//  	const int GET_SYS_RUNTIME	  = 20;
//  	const int RESET_RUNTIME		  = 21;
//  	const int SHOW_ENG_INFO		  = 22;
//  	const int ENV_DATA			= 23;
//  	const int RD_CAN_SIG		= 24;
//  	const int RD_TEMP    		= 25;
//  	const int RD_CALIB_DATA     = 26;
//  	const int RD_ECU_ST			= 27;
//  	const int RD_TEMP_PROF		= 28;
//    const int SKIP_CALIB		= 29;
//  	const int CALIB_SHIFT_UP	= 30;
//  	const int CALIB_SHIFT_DOWN	= 31;
//  	const int CALIB_SHIFT_LEFT	= 32;
//  	const int CALIB_SHIFT_RIGHT = 33;
//  	const int CALIB_DATA_SAVE   = 34;
//  	const int RD_MAX_CALIB_DATA = 35;
//  	const int CALIB_AUTO        = 36;
//  	const int CALIB_DATA_DEL    = 37;
//  	const int READ_HIST_DTC    =  38;
//  	const int CLEAR_HIST_DTC	= 39;
//  	const int HIST_ENV_DATA		= 40;
//  	const int START_CAM_ON		= 41;
//  	const int START_CAM_OFF		= 42;
//  	const int RQ_RES_CALIB_AUTO	= 43;
//  	const int RQ_RES_SELFTEST	= 44;
//  	const int RQ_RES_CHECKSUM	= 45;
//
//    const int READ_HIST_DTC_BY_ST    = 47;
//    const int FINGERPRINT       = 48;
//    const int PROGDATE          = 49;
//    const int  READ_EWB_ACT      = 54;
//    const int  READ_DEACT_FUNC   = 55;
//    const int  PRE_WRITE         = 56;
//    const int  DEACT_FUNC_FLA    = 57;
//    const int  DEACT_FUNC_CCP    = 58;
//    const int  DEACT_FUNC_VZE    = 59; 
//    const int  ACT_EWB_VZF =61;
//    const int  ACT_EWB_EHR =62;
//    const int  ACT_EWB_FLA =63;
//    const int  ACT_EWB_MOD =64;
//    const int  ACT_EWB_HCA =65;
//    const int  ACT_EWBs = 79; //MI
//    const int  ACT_XCP =84;//MI 
    //Anpassung Identifiers  all starting with 0x05
//    const int EWB_VZE_ID=0x32;
//    const int EWB_VZF_ID=0x33;
//    const int EWB_EHR_ID=0x34;
//    const int EWB_HCA_ID=0x35;
//    const int EWB_MOD_ID=0x36;
//    const int EWB_FLA_ID=0x37;
//    const int DEACT_CCP_ID= 0x30;
//    const int DEACT_FLA_ID= 0x19;
//    const int DEACT_VZE_ID= 0x18;
//    const int MASK_FAULT_CLASS_ID= 0x3C;
//    const int MASK_ERR_RCTN_ID= 0x3B;
//    const int BAP_PERS_ID= 0xA4;
//    const int XCP_ID=0x30;//MI
    //Anpassung Identifiers  all starting with 0x09 //MI
//    const int EWBs_ID=0x02; //MI
    //Anpassung Identifiers  all starting with 0x3B
//    const int V_THRESHOLD_MAINBEAM_OFF_ID= 0x23;
//    const int V_THRESHOLD_MAINBEAM_ON_ID= 0x24;
//    const int  READ_V_THRESHOLD_MAINBEAM_ON =72; 
//    const int  WRITE_V_THRESHOLD_MAINBEAM_ON =73; 
//    const int  READ_V_THRESHOLD_MAINBEAM_OFF =74; 
//    const int  WRITE_V_THRESHOLD_MAINBEAM_OFF =75; 
    
    const int ALIGNMENT_START       =51; 
    const int ALIGNMENT_STOP        =52;
    const int ALIGNMENT_STATUS      =53;
    const int ALIGNMENT_RUN_STATUS  =54;
    const int ALIGNMENT_MEAR_RES    =55;
    const int ALIGNMENT_DATA_R      =56;
    const int ALIGNMENT_DATA_W      =57;
    const int ALIGNMENT_TOL_R       =58;
    const int ALIGNMENT_TOL_W       =59;
    const int ALIGNMENT_CURR_VAL    =60;
    
    //ITC
    const int ITC_READ              =61;
    const int ITC_CLEAR             =62;
    
    //BOSCH_CODING
    const int READ_BOSCH_CODING     =63;
  	const int WRITE_BOSCH_CODING    =64;
    
    //Bosch Security Access
    const int SEEDNKEYBOSCHREQUEST  =65;
    const int SEEDNKEYBOSCHRESP     =66;

    
    //PSA Security Access
    const int SEEDNKEYPSAREQUEST    =68;
    const int SEEDNKEYPSARESP       =79;
    
/*
    const int VIN_LEARN_START = 92;
    const int VIN_LEARN_STATUS = 94;
    const int VIN_LEARN_STOP = 82;

    const int READ_BOSCH_CODING  = 85;
  	const int WRITE_BOSCH_CODING = 86;
  	const int CAMERA_RESET       = 87;
  	const int SEEDNKEYRESP       = 88;





    const int  READ_MASK_FAULT_CLASS =66; 
    const int  WRITE_MASK_FAULT_CLASS =67; 
    const int  READ_MASK_ERR_RCTN =68; 
    const int  WRITE_MASK_ERR_RCTN =69; 

    const int  READ_BAP_PERS =70; 
    const int  WRITE_BAP_PERS =71; 

    const int MINICODEREQUEST = 76;
    const int PRE_WRITE_MINICODE = 77;
    const int SEEDNKEYREPROGREQUESTWRITEKEY = 78;
    const int READ_Software_version    = 79;*/
   
    int InnerTempValue = 0;

    long copiedBytes ;

   
    //Stringbuffer
    char 	  Stringbuffer[4098];
   	char	  StringAux[4098];	

    //read dtc variables
   	dword 	  errorDTC[256];
   	dword 	  errorStatus[256]; 
   	int  	  CurrentDTC = 0;
   	int  	  NrOfReadDTC ;   
	
	  dword 	  errorHistDTC[256];
   	byte 	  errorHistStatus[256]; 
   	int  	  CurrentHistDTC = 0;
   	int  	  NrOfHistDTC;  
   	int  	  NrOfReadHistDTC;   

	  // Tester Present Handling
   	msTimer   TesterPresentTimer;
   	const int TesterPresentTime = 2000;
   	const int FirstTesterPresentTime = 20;
    
  	/*   
   	message   TST_PhysicalReqCCM_UN msgDiagRequest = {
   				dword(0) = 0xffffffff,
   				dword(4) = 0xffffffff};

    
    message   TST_PhysicalRespCCM_UN ReqDiagMsgGlobal = {
   				dword(0) = 0x00000000,
   				dword(4) = 0x00000000}; 
    */
   	   
 	 
   	int 	  DiagActive = 0;       

//    msTimer   UpdateRuntime;
	  const int UpdateCycle = 1000;
    
    //to doors-automate-tests

    int readTimeValue;          //elapsed time counter (ms)
    char DTCValue [255];        //internal container for error codes  
//    msTimer readDtcTimer;       //for repeat the reading process
    int CNTR_VALUE=200;         //default timer resolution (ms)
    char readString[255];       //to store the read DTC command
    byte readRequest[255];      //to store the read DTC command
    int requestSize;            //
    char msString[30];          //for the information string
    byte ErrValue [4098];       //the representation of RxDataBuffer
    char ErrString [4098];      //the characteric representation of RxDataBuffer
    char tempString [4098];     //for internal use

    //Seed&key

    byte Fingerprint[9]={0x2e,0xf1,0x98,0x01,0x02,0x03,0x04,0x05,0x06};
    byte ProgrammingDate[6]={0x2e,0xf1,0x99,0x19,0x01,0x09};
    byte SeednKeyFBLRequest[2] = {0x27,0x61};
    byte SeednKeyJLREOLRequest[2] = {0x27,0x01};
    byte MinicodeRequest[2]= {0x27,0x21};
    dword seedReprogValue,  keyLowReprogValue, keyUpperReprogValue;
    dword keyReprogValue;
    dword authKey;
    byte     pufferEOL[10]={0,0,0,0,0,0,0,0,0,0};
    dword keyMaxReprogValue = 0xFFFFFFFF;
    dword WLA, WLAaktiv, WLApassiv; 

    byte whichlogin=0;
    dword result=0; 
    byte resultarray[6]={0x27,0,0,0,0,0};
    byte resultarra[5] = {0x27,0,0,0,0};
 
    // For new security Implementation
    char seedList[600][600];
    char keyList[2048][2048];
    char seedListJLR[600][600];
    char keyListJLR[2048][2048];
    int dynamicKeyLen;
    //int securityType = SEEDNKEYREQUEST;
    //int securityTypeJLR = SEEDNKEYJLRREQUEST;
    byte SecurityBuffer[1];
    int i, j, c_index, bin;
    byte input[8];
    int challenge[64], position_one[24], position_two[24];
    int init_array[24] = {1,0,0,1,0,1,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,1};
    byte sendKey[1024];

    int DynamicFlag = 0;
    char temp1[5];

    char DynamicKey[2052];
    byte defaultsec[1];
    int Seed_buf[4]={0,0,0,0};
    int Seed_buf_Bosch[5]={0,0,0,0,0};
//    msTimer JLRUnlockTimer;
//    msTimer BoschUnlockTimer;

    char gstatusITC[22];

    int tempInt;
    //RadarFC
    const K_TxId_RadarFC = 0x76C;
    const K_RxId_RadarFC = 0x764;
   
    //RadarFL:
    const K_TxId_RadarFL  = 0x76C;//0x6FA;
    const K_RxId_RadarFL  = 0x764;//0x6F2;
    
    //RadarFR:
    const K_TxId_RadarFR  = 0x76C;//0x6FB;
    const K_RxId_RadarFR  = 0x764;//0x6F3;
    
    //RadarRL:
    const K_TxId_RadarRL  = 0x76C;//0x7CC;
    const K_RxId_RadarRL  = 0x764;//0x7C4;
    
    //RadarRR:
    const K_TxId_RadarRR  = 0x76C;//0x7CE;
    const K_RxId_RadarRR  = 0x764;//0x7C6;
    
    const APPLICATIONKEY_FRONT  = 0xBDE3   ;// Value of Application Key for FRONT RADAR
    const APPLICATIONKEY_CORNER = 0xB77B   ;// Value of Application Key for CORNER RADAR 
      
    byte g_seed_value_psa[4];
    byte g_key_value_psa[4];
    
    byte g_seed_value_bosch[6];
    byte g_key_value_bosch[6];
    char unknownReq[256] = "Diag Req doesn't exist";
}

on preStart
{

  char absPath[256];
  char absPathsecurity[250];
  
  // registerUserFile("CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FD3\\CSV\\SimDIAG_FD3_FR_UDS_DTC_map.csv", 0);
  getUserFilePath("SimDIAG_FD3_FR_UDS_DTC_map.csv", absPath, 256);
  write("SimDIAG_FD3_FR::on preStart::absPath = %s", absPath);
  
  filehandle_fr = openFileRead("SimDIAG_FD3_FR_UDS_DTC_map.csv", 0);
  write("SimDIAG_FD3_FR::on preStart::filehandle_fr = %d", filehandle_fr);
  
  if (!filehandle_fr) 
  {
    write("SimDIAG_FD3_FR::on preStart::Error reading CSV file!!!, path = %s", absPath);
  }
  else
  {
    write("SimDIAG_FD3_FR::on preStart::read successfully!!!!, path = %s", absPath);
  }
  
//  if(0!=  ReadDTCTableFile_Kamera(absPath))
//  {
//   write("Error reading CSV file!!!");
//   }

  //write("##############%s",absPath);
  @sysvar::SimDIAG_FD3_FR::GeneralSettings::sysTxIdentifier=K_TxId_RadarFR;
  @sysvar::SimDIAG_FD3_FR::GeneralSettings::sysRxIdentifier=K_RxId_RadarFR;
}

void StartDiagService( byte ServiceId )
{ 
    int64 i;
    long copiedBytes;
    byte l_Key_value[4],l_Seed_value[4];
    byte l_Key_value_bosch[6],l_Seed_value_bosch[6];
  
    for(i=0;i<4;i++)
    {
      l_Key_value[i]=l_Seed_value[i]=0;//Reset
    }
    for(i=0;i<6;i++)
    {
      l_Key_value_bosch[i]=l_Seed_value_bosch[i]=0;//Reset
    }


    CurrentDiagServ = ServiceId;
  
//    if(ServiceId!=TESTER_PRESENT_ON)
         // sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "...");
         sysSetVariableFloat(sysvar::SimDIAG_FD3_FR::sysDataReceived_Time, 0.0);
    
   if(@hil_ctrl::radar_fr_loc_sim == 1)
   {
     //Diag Switch
     switch ( ServiceId )
     {
      case DIRECT_RQ:
                      TxLength = DirectTxDataLen;
                      TransmitTxBuffer();
  							      break;
  	  }
    }
}   

MyEvaluateResponse ()
{
	int i;
	int RespLength;

	char buffer[255];
	char buffer2[255]="0";

//  write("MyEvaluateResponse::Here3");
	strncpy(buffer2, "0", 6);
	strncpy(MVbuffer2, "",6);
	strncpy(MVbuffer, "",6);

	if( ReceiveBufferLength > 255 )
	{
	    strncpy(buffer, "Answer length too big!",99);//English
            //strncpy(buffer, "Antwortlaenge zu gross!",99);//German
	    //write("An error %s has occurred!", buffer)//English
	    //write("Fehler '%s' ist aufgetreten!", buffer);an error has occurred
	}

	if( NrNeededRespBytes != 0 )
	{
		RespLength = NrNeededRespBytes;
	}
	else
	{
		RespLength = ReceiveBufferLength;
	}
	
	for(i=0; i < RespLength; i++)
	{
		ltoa(RxDataBuffer[i], MVbuffer2, 16);
		if( strlen( MVbuffer2 ) == 1 )
		{
			strncat(buffer2, MVbuffer2, 254);
			strncat(MVbuffer, buffer2, 254);
			strncpy(buffer2, "0", 6);
		}
		else
		{
			strncat(MVbuffer, MVbuffer2, 254);
		}
	}
//  write("MyEvaluateResponse::MVbuffer = %s", MVbuffer);
  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataReceived_String ,MVbuffer);
  GetDiagResponse(MVbuffer);
}

void EvaluateRxData( int Length )
{
   int      DtcNr;  
   dword    auxRT;
   float    convert_rad_grad = 57.295779513082320876798154814105;

   dword    resultarray_32[6]={0,0,0,0,0,0};

   dword    REP_RBA_CBB_AKEY_VALUE  = 0x41916668;
   dword    REP_RBA_CBB_BKEY_VALUE  = 0x12774118;
   dword    REP_RBA_CBB_CKEY_VALUE  = 0x86905668;
   dword    REP_RBA_CBB_DKEY_VALUE  = 0x10371229;


   dword    WERK_RBA_CBB_AKEY_VALUE = 0x52917768;  //Minicode 2703/2704
   dword    WERK_RBA_CBB_BKEY_VALUE = 0x12774118;   // Porsche
   dword    WERK_RBA_CBB_CKEY_VALUE = 0x86905668;  // Porsche
   dword    WERK_RBA_CBB_DKEY_VALUE = 0x21482338;  // Porsche

   dword    DEV_RBA_CBB_AKEY_VALUE  = 0x46947376; //Minicode 2721/2722
   dword    DEV_RBA_CBB_BKEY_VALUE  = 0x12774118;  // Porsche
   dword    DEV_RBA_CBB_CKEY_VALUE  = 0x86905668;  // Porsche
   dword    DEV_RBA_CBB_DKEY_VALUE  = 0x45982573;   // Porsche

   dword    RBEOLPin = 0x42444441; //It has been derived from the ASCII values of "Bosch Diagnostics for Driver Assistance"
   dword    PMARequest = 0x80FA1108; //Plant mode activation part request

   dword    keytemp;
   char    buffer[50],tempbuffer[50];
   Byte    ByteValue[1];
   int     IdentifierId;
   int     IdentifierValue;

   int      i;
   dword j,m,k;
   
   char     Seed[1024];
   byte     puffer[128];
   byte securityRespBuffer[1100];
   char pufferStr[2200];
   char temp[5];
   char IMBuffer[4];
   int responseLen;
  
    //*****************************************************************//
    byte First_MID[4096];  
    byte Last_MID[4096];
    char	MVbuffer[4096] = "";
    char	MVbuffer2[4096] = "";
    char  buffer2[4096]="0"; 
    char	MVbuffer5[4096] = "";
    char	MVbuffer6[4096] = "";
    char  buffer5[4096]="0";
    dword bufferSize;
    int RBflag1 =0;
    int RBflag2 = 0;
    
    strncpy(buffer2, "0", 4);
	  strncpy(MVbuffer2, "",4);
	  strncpy(MVbuffer, "",4);
    strncpy(buffer5, "0", 4);
	  strncpy(MVbuffer6, "",4);
	  strncpy(MVbuffer5, "",4);


//    write("EvaluateRxData::Here1");
    //**************************************************************// 
    
    EvaluateResponse( );  
  
    switch ( CurrentDiagServ )  
    {
      
     default : break;

  }

}  

int EvaluateResponse()
{  
   int ret; 
   ret = 0;
   
//   write("EvaluateResponse::Here2");
   if ( RxDataBuffer[0] == 0x7F )
   {
   
      switch ( RxDataBuffer[2] ) 
      {
         case 0x10:
                  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "General reject");
                  break;

         case 0x11: 
                  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Service not supported");
                  break;

         case 0x12: 
                  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "SubFunction Not Supported");
                  break;

         case 0x13: 
                  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, " InCorrect Message Length-invalid Format");
                  break;

         case 0x21: 
                  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Busy Repeat Request");
                  break;

         case 0x22: 
                  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Conditions Not Correct");
                  break;

     //    case 0x23: 
     //           sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Routine not complete");
     //           break;

         case 0x24: 
                  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Request Sequence Error");
                  break;

         case 0x26: 
                  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Failure Prevents Execution of requested action");
				  break;

         case 0x31: 
				  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Request Out Of Range");
				  break;

         case 0x33: 
				  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Security Access Denied");
				  break;

         case 0x35: 
				  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Invalid key");
				  break;

         case 0x36: 
				  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Exceed number of attempts");
				  break;

         case 0x37: 
				  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Time delay not expired");
				  break;

         case 0x78: 
				  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Request Correctly Received-Response Pending");
				  // Wait
				  ret = 0; 
				  break;

      //   case 0x80: 
      //      sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Service not supported in active mode");
      //   break;

         case 0x7E: 
				  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "SubFunction Not Supported In Active Diagnostic Session");
				  break;

         case 0x7F: 
				  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Service Not Supported In Active Diagnosic Session");
				  break;
             
         case 0x83: 
				  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Condition not correct - Engine running");
				  break;
         
         case 0x88: 
				  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Vehicle Speed Too High");
				  break;

         case 0x89: 
				  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Negative Response:ESP_v_Signal<= 50 km/h");
				  break;
         
        case 0x93:
				  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "VoltageTooLow");
				  break;

        case 0x92:
				  sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "VoltageTooHigh");
				  break;


         default:   
				 sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, "Negative Response: Acknowledge not defined");
				 break;
         }
   }
   else
   {
      if ( RxDataBuffer[0] == ( SId + 0x40 ) )        
      {
         // Positive response
         sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status,"OK! Positive response");
         ret = 1; 
      }
      else                      
      {
        sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status ,"Unknown response");
        ret = 0; 
      }
   }

   return ( ret ); 
}

void TransmitTxBuffer (void)
{ 
  // OSEK TP supports up to 4 GiB with Jumbo frames, but limit that to a much lower value for this demo
  int fd_dlc;
  int temp_sysMaxFDFrameLen;

  temp_sysMaxFDFrameLen = @sysvar::SimDIAG_FD3_FR::GeneralSettings::sysMaxFDFrameLen;
    
  if (TxLength > kBufferSizeJumbo)
      TxLength = kBufferSizeJumbo;
  
  fd_dlc=TxLength+2;
  
  if((fd_dlc>8) && (fd_dlc<13))
    set_sysMaxFDFrameLen(12);
  else if((fd_dlc>12) && (fd_dlc<17))
    set_sysMaxFDFrameLen(16);
  else if((fd_dlc>16) && (fd_dlc<21))
    set_sysMaxFDFrameLen(20);
  else if((fd_dlc>20) && (fd_dlc<25))
    set_sysMaxFDFrameLen(24);
  else if((fd_dlc>24) && (fd_dlc<33))
    set_sysMaxFDFrameLen(32);
  else if((fd_dlc>32) && (fd_dlc<49))
    set_sysMaxFDFrameLen(48);
  else if((fd_dlc>48) && (fd_dlc<64))
    set_sysMaxFDFrameLen(64);
  
  writeDbgLevel(1,"%s, connection %d: Send request for %d data bytes",gECU, kIdTester1, TxLength);
  
  setTimerCyclic(tFlashTxLEDTester1, kDuration_LEDFlash_ms);
  setTimer(tSwitchOffTxLEDTester1, kDuration_RxLEDFlashOff_ms);
  
  CanTpSendData(gHandleTester1, TxDataBuffer, TxLength);
  
//  if(TxDataBuffer[0] != 0x3E)
//   {
//     sysSetVariableData(sysvar::SimDIAG_FD3_FR::sysDataReceived,emptyString,0);
//     sysSetVariableInt(sysvar::SimDIAG_FD3_FR::sysNoOfBytesReceived,0);
//     sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataReceived_String,"");// delete old value from receive 
  
     sysSetVariableData(sysvar::SimDIAG_FD3_FR::sysDataToTransmit,TxDataBuffer,TxLength);
//   }
  SId = TxDataBuffer[0];
   
   @sysvar::SimDIAG_FD3_FR::GeneralSettings::sysMaxFDFrameLen=temp_sysMaxFDFrameLen;//Reset

}

OSEKTL_DataCon(long status)
{
    if (status != 0) 
    {
       RespTime = ( (float) timeNow() * (-1.0) );	
     }
     else
     {
        write("Tx error, status is %d", status);
     }
}


FillErrString (int length)
{
  //to create string representation of (bin)ErrValue[] in (char)ErrString[]

  char temp[3];
  int i;
  strncpy(ErrString,"",0);
  if (length!=0)
  {
  for (i=0;i<length;i++) 
      {
      strncpy(tempString,"",0);
      ltoa(ErrValue[i],temp,16);
      if (strlen(temp)==1) strncpy(tempString,"0",2);
      strncat(tempString,temp,(strlen(tempString)+strlen(temp))+1);
      //if (i<10) write("%d.%s->%s",i,temp,tempString);
      strncat(ErrString,tempString,strlen(tempString)+strlen(ErrString)+1);
      }
  length=0;
  //write("***At %f ErrString= %s",timeNowFloat()/100000,ErrString);
  }
}

void GetDiagResponse (char RxdataReceived[])
{
  char DiagResp [256] = "";
  char DiagReqDescr[256] = ""; 
  long res;
  int v; 
  
//  for (v = 0; v < elcount(DiagResp); v++)
//  {
//      DiagResp[v] = 'W';
//  }
  
//  write("GetDiagResponse::DiagResp = %s", DiagResp);
  strncpy(DiagResp, " ", elcount(DiagResp));
  write("GetDiagResponse::DiagResp = %s", DiagResp);
  
//  for (v = 0; v < elcount(DiagReqDescr); v++)
//  {
//      DiagReqDescr[v] = ' ';
//  }
  
  strncpy(DiagReqDescr, " ", elcount(DiagReqDescr));
  write("GetDiagResponse::DiagReqDescr = %s", DiagReqDescr);
  
  res=GetResponseDetail(RxdataReceived, DiagResp, DiagReqDescr);
  write("GetDiagResponse::RxdataReceived = %s, DiagResp = %s, DiagReqDescr = %s", RxdataReceived, DiagResp, DiagReqDescr);
  // writelineex(0, 1, "GetDiagResponse::RxdataReceived = %s, DiagResp = %s, DiagReqDescr = %s", RxdataReceived, DiagResp, DiagReqDescr);
  
  if(res == 0)
  {
      //snprintf( DiagResp, 255,"Unknown Error: %d", error);
  }
  else
  {
//    write("DTCText::%s",DTCText);
//		res=sysSetVariableString(sysvar::DIAG_FD3::DTC_INFO::DTC_Name,DTCText);
	}
}

long GetResponseDetail(char DiagReq[], char DiagResp[], char DiagReqDescription[])
{
//  char str1[100]; 
//  char str[100]; 
  long pos;
  int k, m;
  filehandle_fr = 0;
  k = 0;
  
//  ltoa(DiagReq, str1, 16); // dword to string
//  toUpper(str, str1, elcount(str));
  toUpper(DiagReq, DiagReq, elcount(DiagReq));
  
  filehandle_fr = openFileRead("SimDIAG_FD3_FR_UDS_DTC_map.csv", 0);
  write("SimDIAG_FD3_FR::GetResponseDetail::filehandle_fr = %d", filehandle_fr);
  
  if (filehandle_fr != 0) 
  {   
     while (fileGetString(buffer, elcount(buffer), filehandle_fr) != 0) // till end of file ...
  	 {        
         pos = strstr(buffer, DiagReq);
      	 write("SimDIAG_FD3_FR::GetResponseDetail::buffer = %s", buffer);
         write("SimDIAG_FD3_FR::GetResponseDetail::DiagReq = %s", DiagReq);
         write("SimDIAG_FD3_FR::GetResponseDetail::pos = %d", pos);
      
         if (pos != -1)
         {
          	 for (i = pos; i < elcount(buffer); i++)
             {
                if (buffer[i] == ';')
                {
                    for (j = i+1; j < elcount(buffer); j++)
                    {
                        if (buffer[j] != ';')
                				{
                           DiagResp[k++] = buffer[j];
                           continue;
                        }
                        else
                        {
                           break;
                        }
                    }
                    //write("SimDIAG_FD3_FR::GetResponseDetail::i = %d, j = %d, elcount(buffer) = %d", i, j, elcount(buffer));
                    write("SimDIAG_FD3_FR::GetResponseDetail::DiagResp = %s", DiagResp);
                    sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_String, DiagResp);
                    @sysvar::SimDIAG_FD3_FR::GeneralSettings::sysSendData = 1;
                    k = 0;
                    for (m = j+1; m < elcount(buffer); m++)
                    {
                        if (buffer[m] != ';')
                        {
                            DiagReqDescription[k++] = buffer[m];
                        }
                        else
                        {
                           break;
                        }
                    }
                    
                    if( !strncmp( DiagReq,"3E80",strlen(DiagReq)) )
                    {
                      //strncpy(DiagResp, " ", elcount(DiagResp));
                      //strncpy(DiagReqDescription, " ", elcount(DiagReqDescription));
                      sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_String, ""); //DiagResp
                      write("Length of sysvar::SimDIAG_FD3_FR::sysDataToTransmit_String = %d", elcount(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_String));
                      write("Length of DiagResp = %d", elcount(DiagResp));
                      sysSetVariableData(sysvar::SimDIAG_FD3_FR::sysDataToTransmit, emptyString, 0);
                      @sysvar::SimDIAG_FD3_FR::GeneralSettings::sysSendData = 1;
                      sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, DiagReqDescription); //DiagReqDescription
                      return 1;
                    }
                    
                    write("SimDIAG_FD3_FR::GetResponseDetail::i = %d, j = %d, m = %d, elcount(buffer) = %d", i, j, m, elcount(buffer));
                    write("SimDIAG_FD3_FR::GetResponseDetail::DiagReqDescription = %s", DiagReqDescription);
                    sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, DiagReqDescription);
                    write("SimDIAG_FD3_FR::GetResponseDetail::return 1");
                    return 1;
                 }               
          	  }	  
          }
      }
      
      strncpy(DiagResp, " ", elcount(DiagResp));
      strncpy(DiagReqDescription, " ", elcount(DiagReqDescription));
      strncpy(DiagReqDescription, unknownReq, elcount(unknownReq));
      sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_String, ""); //DiagResp
      write("Length of sysvar::SimDIAG_FD3_FR::sysDataToTransmit_String = %d", elcount(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_String));
      write("Length of DiagResp = %d", elcount(DiagResp));
      sysSetVariableData(sysvar::SimDIAG_FD3_FR::sysDataToTransmit, emptyString, 0);
      @sysvar::SimDIAG_FD3_FR::GeneralSettings::sysSendData = 1;
      sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_Status, DiagReqDescription); //DiagReqDescription
  }
  write("SimDIAG_FD3_FR::GetResponseDetail::return 0");
  return 0;  
}

on busOff
{
   resetCan();
}

on sysvar_update sysvar::SimDIAG_FD3_FR::sysDataToTransmit_String
{
  dword i,length;
  dword 	SendBufferSize;
  char	MVbuffer[130000] = "";
  char	MVbuffer2[130000] = "0x"; 
  byte 	TransmitBuffer[65000];

  sysGetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_String, MVbuffer, elcount(MVbuffer));
  SendBufferSize = strlen(MVbuffer)+1;

  if( !strncmp(MVbuffer,"Idle",strlen(MVbuffer)) )
  {
//     write("on sysvar sysDataToTransmit_String::if::MVbuffer = %s", MVbuffer);
     @sysvar::SimDIAG_FD3_FR::GeneralSettings::sysSendData=0;
  }
  else
  {
//     write("on sysvar sysDataToTransmit_String::else::MVbuffer = %s", MVbuffer);
     strncpy(MVbuffer2, "0x",3);
     for(i=0; i<= SendBufferSize-3; i+=2)
     {
        MVbuffer2[2] = MVbuffer[i];
        MVbuffer2[3] = MVbuffer[i+1];
        MVbuffer2[4] = 0;
        TransmitBuffer[i/2] = atol( MVbuffer2 );
     }
     length = (SendBufferSize - 1)/2;
     sysSetVariableData(sysvar::SimDIAG_FD3_FR::sysDataToTransmit,TransmitBuffer,length);
      
     sysSetVariableString(sysvar::SimDIAG_FD3_FR::sysDataToTransmit_String,"Idle");
  }
}