/*@!Encoding:1252*/
/*******************************************************************************
	MODULEFILE_DESCRIPTION:DIAG_FD3
	COPYRIGHT:
	Robert Bosch GmbH reserves all rights even in the event of industrial
	property. We reserve all rights of disposal such as copying and passing
	on to third parties.
	COPYRIGHT_END:

	PROJECT:		  Implements Basic UDS functionality as a Tester Node
	FILENAME:		  DIAG_FD3.cin

	DESCRIPTION:  CAPL-Program for DIAG/UDS over CAN/CAN-FD simulation via OSEK_TP.
  REFERENCE  :  Sample Osek Configuration [Vector standards  ]

	HISTORY:
        Version1: 28.08.2021 ; DUE1KOR ; Initial Version 

*****************************************************************************/


includes
{
  #include "CAPL\Tester_On_Fuction.cin"

}

variables
{  
    byte      emptyString[kBufferSizeJumbo];

   
   	//Transmit
    const int txSize = 4096;
	  byte 	  TxDataBuffer[kBufferSizeJumbo];
   	int       TxLength;
    byte      TxDataBuffer_temp[3]={22,22,22};
    
    dword filehandle = 0;
    char buffer[32000];
    char text[512];
    char path[50] = "..\\CSV\\FD3_UDS_DTC_map.csv";

    //Receive
    const int rxSize = 4098;
	  byte 	  RxDataBuffer[kBufferSizeJumbo];
   	int  	  RxBufferIndex;
   	int  	  RxLength_CAN;        
    char      hexaStr[6];

    //My evaluate
    int 	NrNeededRespBytes = 0;
	  int 	ReceiveBufferLength;

	  char	MVbuffer[500] = "";
	  char	MVbuffer2[500] = "0x";   	

    // Variables for Requests
	  int 	  DirectTxDataLen  = 0;
   	int   	  CurrentDiagServ  = 0;
	  int		  SId              = 0;
   	float 	  RespTime         = 0.0;

    //Constants for Diag Switch
    const int TESTER_PRESENT_ON = 0;
    const int DEFAULT_SESSION   = 1;
    const int PROGRAM_SESSION   = 2;
  	const int EXTENDED_SESSION	= 3;
    const int BOSCH_SESSION     = 4;
    
    const int ECU_HARD_RESET    = 5;
    const int ECU_SOFT_RESET    = 6;
    
  	const int READ_DTC_BY_ST    = 7;
  	const int CLEAR_DTC			    = 8;
    const int DIRECT_RQ			    = 9;
    
//  const int READ_DTC_BY_ST_RBEOL = 89;   

//  const int READ_DTC_PASS     = 13;

    
//  	const int EN_NOR_MSG_TX		= 3;
//  	const int ECU_ID			    = 4;
//  	const int ECU_DEV_ST    	= 5;
//  	const int RD_CAMERA_LEFT    = 8;
//  	const int RD_CAMERA_RIGHT   = 9;
//  	const int RD_SW_VER         = 10;
//  	const int TEST				      = 11;
  
//  	const int RD_SERIAL_NR      = 14;
//  	const int RESET             = 15;
//  	const int START_IR_TEST     = 16;
//  	const int STOP_IR_TEST      = 17;
//  	const int START_IMG_TEST    = 18;
//  	const int STOP_IMG_TEST     = 19;
//  	const int GET_SYS_RUNTIME	  = 20;
//  	const int RESET_RUNTIME		  = 21;
//  	const int SHOW_ENG_INFO		  = 22;
//  	const int ENV_DATA			= 23;
//  	const int RD_CAN_SIG		= 24;
//  	const int RD_TEMP    		= 25;
//  	const int RD_CALIB_DATA     = 26;
//  	const int RD_ECU_ST			= 27;
//  	const int RD_TEMP_PROF		= 28;
//    const int SKIP_CALIB		= 29;
//  	const int CALIB_SHIFT_UP	= 30;
//  	const int CALIB_SHIFT_DOWN	= 31;
//  	const int CALIB_SHIFT_LEFT	= 32;
//  	const int CALIB_SHIFT_RIGHT = 33;
//  	const int CALIB_DATA_SAVE   = 34;
//  	const int RD_MAX_CALIB_DATA = 35;
//  	const int CALIB_AUTO        = 36;
//  	const int CALIB_DATA_DEL    = 37;
//  	const int READ_HIST_DTC    =  38;
//  	const int CLEAR_HIST_DTC	= 39;
//  	const int HIST_ENV_DATA		= 40;
//  	const int START_CAM_ON		= 41;
//  	const int START_CAM_OFF		= 42;
//  	const int RQ_RES_CALIB_AUTO	= 43;
//  	const int RQ_RES_SELFTEST	= 44;
//  	const int RQ_RES_CHECKSUM	= 45;
//
//    const int READ_HIST_DTC_BY_ST    = 47;
//    const int FINGERPRINT       = 48;
//    const int PROGDATE          = 49;
//    const int  READ_EWB_ACT      = 54;
//    const int  READ_DEACT_FUNC   = 55;
//    const int  PRE_WRITE         = 56;
//    const int  DEACT_FUNC_FLA    = 57;
//    const int  DEACT_FUNC_CCP    = 58;
//    const int  DEACT_FUNC_VZE    = 59; 
//    const int  ACT_EWB_VZF =61;
//    const int  ACT_EWB_EHR =62;
//    const int  ACT_EWB_FLA =63;
//    const int  ACT_EWB_MOD =64;
//    const int  ACT_EWB_HCA =65;
//    const int  ACT_EWBs = 79; //MI
//    const int  ACT_XCP =84;//MI 
    //Anpassung Identifiers  all starting with 0x05
//    const int EWB_VZE_ID=0x32;
//    const int EWB_VZF_ID=0x33;
//    const int EWB_EHR_ID=0x34;
//    const int EWB_HCA_ID=0x35;
//    const int EWB_MOD_ID=0x36;
//    const int EWB_FLA_ID=0x37;
//    const int DEACT_CCP_ID= 0x30;
//    const int DEACT_FLA_ID= 0x19;
//    const int DEACT_VZE_ID= 0x18;
//    const int MASK_FAULT_CLASS_ID= 0x3C;
//    const int MASK_ERR_RCTN_ID= 0x3B;
//    const int BAP_PERS_ID= 0xA4;
//    const int XCP_ID=0x30;//MI
    //Anpassung Identifiers  all starting with 0x09 //MI
//    const int EWBs_ID=0x02; //MI
    //Anpassung Identifiers  all starting with 0x3B
//    const int V_THRESHOLD_MAINBEAM_OFF_ID= 0x23;
//    const int V_THRESHOLD_MAINBEAM_ON_ID= 0x24;
//    const int  READ_V_THRESHOLD_MAINBEAM_ON =72; 
//    const int  WRITE_V_THRESHOLD_MAINBEAM_ON =73; 
//    const int  READ_V_THRESHOLD_MAINBEAM_OFF =74; 
//    const int  WRITE_V_THRESHOLD_MAINBEAM_OFF =75; 
    
    const int ALIGNMENT_START       =51; 
    const int ALIGNMENT_STOP        =52;
    const int ALIGNMENT_STATUS      =53;
    const int ALIGNMENT_RUN_STATUS  =54;
    const int ALIGNMENT_MEAR_RES    =55;
    const int ALIGNMENT_DATA_R      =56;
    const int ALIGNMENT_DATA_W      =57;
    const int ALIGNMENT_TOL_R       =58;
    const int ALIGNMENT_TOL_W       =59;
    const int ALIGNMENT_CURR_VAL    =60;
    
    //ITC
    const int ITC_READ              =61;
    const int ITC_CLEAR             =62;
    
    //BOSCH_CODING
    const int READ_BOSCH_CODING     =63;
  	const int WRITE_BOSCH_CODING    =64;
    
    //Bosch Security Access
    const int SEEDNKEYBOSCHREQUEST  =65;
    const int SEEDNKEYBOSCHRESP     =66;

    
    //PSA Security Access
    const int SEEDNKEYPSAREQUEST    =68;
    const int SEEDNKEYPSARESP       =79;
    
/*
    const int VIN_LEARN_START = 92;
    const int VIN_LEARN_STATUS = 94;
    const int VIN_LEARN_STOP = 82;

    const int READ_BOSCH_CODING  = 85;
  	const int WRITE_BOSCH_CODING = 86;
  	const int CAMERA_RESET       = 87;
  	const int SEEDNKEYRESP       = 88;





    const int  READ_MASK_FAULT_CLASS =66; 
    const int  WRITE_MASK_FAULT_CLASS =67; 
    const int  READ_MASK_ERR_RCTN =68; 
    const int  WRITE_MASK_ERR_RCTN =69; 

    const int  READ_BAP_PERS =70; 
    const int  WRITE_BAP_PERS =71; 

    const int MINICODEREQUEST = 76;
    const int PRE_WRITE_MINICODE = 77;
    const int SEEDNKEYREPROGREQUESTWRITEKEY = 78;
    const int READ_Software_version    = 79;*/
   
    int InnerTempValue = 0;

    long copiedBytes ;

   
    //Stringbuffer
    char 	  Stringbuffer[4098];
   	char	  StringAux[4098];	

    //read dtc variables
   	dword 	  errorDTC[256];
   	dword 	  errorStatus[256]; 
   	int  	  CurrentDTC = 0;
   	int  	  NrOfReadDTC ;   
	
	  dword 	  errorHistDTC[256];
   	byte 	  errorHistStatus[256]; 
   	int  	  CurrentHistDTC = 0;
   	int  	  NrOfHistDTC;  
   	int  	  NrOfReadHistDTC;   

	  // Tester Present Handling
   	msTimer   TesterPresentTimer;
   	const int TesterPresentTime = 2000;
   	const int FirstTesterPresentTime = 20;
    
  	/*   
   	message   TST_PhysicalReqCCM_UN msgDiagRequest = {
   				dword(0) = 0xffffffff,
   				dword(4) = 0xffffffff};

    
    message   TST_PhysicalRespCCM_UN ReqDiagMsgGlobal = {
   				dword(0) = 0x00000000,
   				dword(4) = 0x00000000}; 
    */
   	   
 	 
   	int 	  DiagActive = 0;       

//    msTimer   UpdateRuntime;
	  const int UpdateCycle = 1000;
    
    //to doors-automate-tests

    int readTimeValue;          //elapsed time counter (ms)
    char DTCValue [255];        //internal container for error codes  
//    msTimer readDtcTimer;       //for repeat the reading process
    int CNTR_VALUE=200;         //default timer resolution (ms)
    char readString[255];       //to store the read DTC command
    byte readRequest[255];      //to store the read DTC command
    int requestSize;            //
    char msString[30];          //for the information string
    byte ErrValue [4098];       //the representation of RxDataBuffer
    char ErrString [4098];      //the characteric representation of RxDataBuffer
    char tempString [4098];     //for internal use

    //Seed&key

    byte Fingerprint[9]={0x2e,0xf1,0x98,0x01,0x02,0x03,0x04,0x05,0x06};
    byte ProgrammingDate[6]={0x2e,0xf1,0x99,0x19,0x01,0x09};
    byte SeednKeyFBLRequest[2] = {0x27,0x61};
    byte SeednKeyJLREOLRequest[2] = {0x27,0x01};
    byte MinicodeRequest[2]= {0x27,0x21};
    dword seedReprogValue,  keyLowReprogValue, keyUpperReprogValue;
    dword keyReprogValue;
    dword authKey;
    byte     pufferEOL[10]={0,0,0,0,0,0,0,0,0,0};
    dword keyMaxReprogValue = 0xFFFFFFFF;
    dword WLA, WLAaktiv, WLApassiv; 

    byte whichlogin=0;
    dword result=0; 
    byte resultarray[6]={0x27,0,0,0,0,0};
    byte resultarra[5] = {0x27,0,0,0,0};
 
    // For new security Implementation
    char seedList[600][600];
    char keyList[2048][2048];
    char seedListJLR[600][600];
    char keyListJLR[2048][2048];
    int dynamicKeyLen;
    //int securityType = SEEDNKEYREQUEST;
    //int securityTypeJLR = SEEDNKEYJLRREQUEST;
    byte SecurityBuffer[1];
    int i, j, c_index, bin;
    byte input[8];
    int challenge[64], position_one[24], position_two[24];
    int init_array[24] = {1,0,0,1,0,1,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,1};
    byte sendKey[1024];

    int DynamicFlag = 0;
    char temp1[5];

    char DynamicKey[2052];
    byte defaultsec[1];
    int Seed_buf[4]={0,0,0,0};
    int Seed_buf_Bosch[5]={0,0,0,0,0};
//    msTimer JLRUnlockTimer;
//    msTimer BoschUnlockTimer;

    char gstatusITC[22];
    msTimer VINTimer;
    
    int VINFlag;
    int ALIGNFlag;

    int tempInt;
    
    msTimer alignmentTimer;

    msTimer ITCTimer_Read; //ITC timer
//    msTimer ITCTimer_Clear; //ITC timer
	  byte BoschCodingBuffer[50];
    

    //Alignment::Default value
    const K_Align_RID_Sta  =  0x0402;//Static Alignment
    const K_Align_RID_Dyn  =  0x0403;//Dynamic Alignment    
    
    const K_Align_IN_Plant  =  0x01;//Plant Alignment
    const K_Align_IN_After  =  0x02;//After sale Alignment 
    
    word G_Align_RID =  K_Align_RID_Sta;//Project-Routine Identifier (RID)
    byte G_Align_IN  =  K_Align_IN_Plant;
    
    word G_Align_Data      =  0xD406;//Alignment Data
    word G_Align_Tolerance =  0xD413;//DID::Alignment Tolerance
    word G_Align_Meas_Res  =  0xD414;//DID::Alignment Measure Result
    word G_Align_Curr_Val  =  0xD415;//DID::Current Misalignment Value
    
    //BOSCH CODING DATA::ITC::Default value
    const K_ITC_DiD  =  0xFB09;
    const K_ITC_FR_Mask_lng  =  54;//Front length
    const K_ITC_CR_Mask_lng  =  50;//Corner length
    
    byte  G_ITC_Mask_lng    =  K_ITC_FR_Mask_lng;//Default


    //RadarFC
    const K_TxId_RadarFC = 0x788;//0x764
    const K_RxId_RadarFC = 0x789;//0x76C
   
    //RadarFL:
    const K_TxId_RadarFL  = 0x78B;//0x764;
    const K_RxId_RadarFL  = 0x78C;//0x76C;
    
    //RadarFR:
    const K_TxId_RadarFR  = 0x78E;//0x764;
    const K_RxId_RadarFR  = 0x78F;//0x76C;
    
    //RadarRL:
    const K_TxId_RadarRL  = 0x791;//0x764;
    const K_RxId_RadarRL  = 0x792;//0x76C;
    
    //RadarRR:
    const K_TxId_RadarRR  = 0x794;//0x764;
    const K_RxId_RadarRR  = 0x795;//0x76C;
    
    const APPLICATIONKEY_FRONT  = 0xBDE3   ;// Value of Application Key for FRONT RADAR
    const APPLICATIONKEY_CORNER = 0xB77B   ;// Value of Application Key for CORNER RADAR 
      
    byte g_seed_value_psa[4];
    byte g_key_value_psa[4];
    
    byte g_seed_value_bosch[6];
    byte g_key_value_bosch[6];
}

on preStart
{

	char absPath[256];
  char absPathsecurity[250];
  
  // registerUserFile("CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FD3\\CSV\\FD3_UDS_DTC_map.csv", 0);
  getUserFilePath("FD3_UDS_DTC_map.csv", absPath, 256);
  write("DIAG_FD3 -FR::on preStart::absPath = %s", absPath);
  
  filehandle = openFileRead("FD3_UDS_DTC_map.csv", 0);
  write("DIAG_FD3 -FR::on preStart::filehandle = %d", filehandle);
  
  if (!filehandle) 
  {
    write("DIAG_FD3 -FR::on preStart::Error reading CSV file!!!, path = %s", absPath);
  }
  else
  {
    write("DIAG_FD3 -FR::on preStart::read successfully!!!!, path = %s", absPath);
  }
  
//  if(0!=  ReadDTCTableFile_Kamera(absPath))
//  {
//   write("Error reading CSV file!!!");
//   }
  
  sysSetVariableString(sysvar::DIAG_FD3::PSA_SecAcc::Display,"");
  sysSetVariableString(sysvar::DIAG_FD3::Bosch_SecAcc::Display,"");
  //write("##############%s",absPath);

}
void StartDiagService( byte ServiceId )
{ 
    int64 i;
    long copiedBytes;
    byte l_Key_value[4],l_Seed_value[4];
    byte l_Key_value_bosch[6],l_Seed_value_bosch[6];
  
    for(i=0;i<4;i++)
    {
      l_Key_value[i]=l_Seed_value[i]=0;//Reset
    }
    for(i=0;i<6;i++)
    {
      l_Key_value_bosch[i]=l_Seed_value_bosch[i]=0;//Reset
    }


    CurrentDiagServ = ServiceId;
  
    if(ServiceId!=TESTER_PRESENT_ON)
         sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "...");
         sysSetVariableFloat(sysvar::DIAG_FD3::sysDataReceived_Time, 0.0);   

   //Diag Switch
   switch ( ServiceId )
   {
	  case TESTER_PRESENT_ON:
							TxDataBuffer[0] = 0x3E;	
							TxDataBuffer[1] = 0x00;
							TxLength = 2;  
							if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
							{
							TransmitTxBuffer();
							}
							break;
	  case DEFAULT_SESSION:
							TxDataBuffer[0] = 0x10;
							TxDataBuffer[1] = 0x01;	
							TxLength = 2;  
							if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
							{
							TransmitTxBuffer();
							}
							break;
	  case PROGRAM_SESSION:
							TxDataBuffer[0] = 0x10;
							TxDataBuffer[1] = 0x02;	
							TxLength = 2;  
							if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
							{
							TransmitTxBuffer();
							}
							break;
	  case EXTENDED_SESSION:
							TxDataBuffer[0] = 0x10;
							TxDataBuffer[1] = 0x03;	//Extended diag session
							TxLength = 2;  
							if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
							{
							TransmitTxBuffer();
							}
							break;
    case BOSCH_SESSION: 
							TxDataBuffer[0] = 0x10;
							TxDataBuffer[1] = 0x60; 
							TxLength = 2; 
							if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
							{
							TransmitTxBuffer();
							}
							break; 
    case ECU_HARD_RESET:
							TxDataBuffer[0] = 0x11;
							TxDataBuffer[1] = 0x01;	//Extended diag session
							TxLength = 2;  
							if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
							{
							TransmitTxBuffer();
							}
							break;
    case ECU_SOFT_RESET:
							TxDataBuffer[0] = 0x11;
							TxDataBuffer[1] = 0x03;	//Extended diag session
							TxLength = 2;  
							if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
							{
							TransmitTxBuffer();
							}
							break;
    case READ_DTC_BY_ST: 
							TxDataBuffer[0] = 0x19;
							TxDataBuffer[1] = 0x02;
							TxDataBuffer[2] = 0x09;  
							TxLength = 3; 
							if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
							{
							TransmitTxBuffer();
							}
							break;
    case CLEAR_DTC: 
							TxDataBuffer[0] = 0x14;
							TxDataBuffer[1] = 0xFF;  
							TxDataBuffer[2] = 0xFF;
							TxDataBuffer[3] = 0xFF;   
							TxLength = 4;
							if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
							{
							TransmitTxBuffer();
							}
							break;
    case DIRECT_RQ: 
							TxLength = DirectTxDataLen;
							if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
							{
							TransmitTxBuffer();
							}
							break;
/*
    case VIN_LEARN_START:
							TxDataBuffer[0] = 0x31;
							TxDataBuffer[1] = 0x01;
      
							TxDataBuffer[2] = 0x04;  
							TxDataBuffer[3] = 0x04; 
							TxLength = 4; 
							if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
							{
							TransmitTxBuffer();
							}
							break;
    case VIN_LEARN_STOP:
							TxDataBuffer[0] = 0x31;
							TxDataBuffer[1] = 0x02;
							TxDataBuffer[2] = 0x04;  
							TxDataBuffer[3] = 0x04; 
							TxLength = 4; 
							if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
							{
							TransmitTxBuffer();
							}
							break;
    case VIN_LEARN_STATUS:
							TxDataBuffer[0] = 0x31;
							TxDataBuffer[1] = 0x03;
							TxDataBuffer[2] = 0x04;  
							TxDataBuffer[3] = 0x04; 
							TxLength = 4; 
							if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
							{
							TransmitTxBuffer();
							}
							break;

*/
	case ALIGNMENT_START:
          	  TxDataBuffer[0] = 0x31;//Diagnostic Routine Service
          	  TxDataBuffer[1] = 0x01;//Sub-functions::Start Routine
          	  TxDataBuffer[2] = G_Align_RID>>8;//Project-Routine Identifier (RID)
          	  TxDataBuffer[3] = G_Align_RID;//Project-Routine Identifier (RID)
              TxDataBuffer[4] = G_Align_IN;
              TxLength = 5;
              if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
				break;
	case ALIGNMENT_STOP:
          		TxDataBuffer[0] = 0x31;//Diagnostic Routine Service
          		TxDataBuffer[1] = 0x02;//Sub-functions::Stop Routine
          		TxDataBuffer[2] = G_Align_RID>>8;//Project-Routine Identifier (RID)
          		TxDataBuffer[3] = G_Align_RID;//Project-Routine Identifier (RID)
          		TxLength = 4;
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
							break;
  case ALIGNMENT_STATUS:
          		TxDataBuffer[0] = 0x31;//Diagnostic Routine Service
          		TxDataBuffer[1] = 0x03;//Sub-functions::Request Routine Results
          		TxDataBuffer[2] = G_Align_RID>>8;//Project-Routine Identifier (RID)
          		TxDataBuffer[3] = G_Align_RID;//Project-Routine Identifier (RID)
          		TxLength = 4;
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
							break;
	case ALIGNMENT_RUN_STATUS:
          		TxDataBuffer[0] = 0x22;
          		TxDataBuffer[1] = 0xA2;//Project
          		TxDataBuffer[2] = 0x29;//Project
          		TxLength = 3;
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
							break;
	case ALIGNMENT_MEAR_RES:
              TxDataBuffer[0] = 0x22;//RDBI
            	TxDataBuffer[1] = G_Align_Meas_Res>>8;
            	TxDataBuffer[2] = G_Align_Meas_Res;
              TxLength = 3;
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
							break;
	case ALIGNMENT_DATA_R:
              TxDataBuffer[0] = 0x22;//RDBI
            	TxDataBuffer[1] = G_Align_Data>>8;
            	TxDataBuffer[2] = G_Align_Data;
              TxLength = 3;
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
							break;
	case ALIGNMENT_DATA_W:
              Alignment_Data_Write();
							break;
	case ALIGNMENT_TOL_R:
              TxDataBuffer[0] = 0x22;//RDBI
            	TxDataBuffer[1] = G_Align_Tolerance>>8;
            	TxDataBuffer[2] = G_Align_Tolerance;
              TxLength = 3;
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
							break;
	case ALIGNMENT_TOL_W:
              Alignment_Tolerance_Write();
							break;
	case ALIGNMENT_CURR_VAL:
              TxDataBuffer[0] = 0x22;//RDBI
            	TxDataBuffer[1] = G_Align_Curr_Val>>8;
            	TxDataBuffer[2] = G_Align_Curr_Val;
              TxLength = 3;
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
							break;
    case ITC_READ:
							TxDataBuffer[0] = 0x22;
							TxDataBuffer[1] = 0xFD;//Pending
							TxDataBuffer[2] = 0x09;//Pending
							TxLength = 3;
							if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
							{
								TransmitTxBuffer();
							}
							break;
    case ITC_CLEAR:
							TxDataBuffer[0] = 0x31;
							TxDataBuffer[1] = 0x01; 
							TxDataBuffer[2] = 0xF0;//Pending
							TxDataBuffer[3] = 0x01;//Pending
							TxLength = 4;
							if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
							{
								TransmitTxBuffer();
							}
							break;
  case READ_BOSCH_CODING:
							TxDataBuffer[0] = 0x22;
          	  TxDataBuffer[1] = K_ITC_DiD>>8;
          	  TxDataBuffer[2] = K_ITC_DiD;
              TxLength = 3;
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
							break;
  case WRITE_BOSCH_CODING: 
							bosch_coding_Write();
							break;
	case SEEDNKEYBOSCHREQUEST: 
							TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x61;
							TxLength = 2;
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
							break;
  case SEEDNKEYBOSCHRESP: 
              TxDataBuffer[0] = 0x27;
              TxDataBuffer[1] = 0x62;
              TxLength = sysGetVariableData(sysvar::DIAG_FD3::Bosch_SecAcc::Key_value, l_Key_value_bosch ,copiedBytes);
              for (i = 0 ; i < 6 ; i++)
              {
                  TxDataBuffer[i+2] = g_key_value_bosch[i];
              }
              for (i = 8 ; i < 2050 ; i++)
              {
                  TxDataBuffer[i] = 0x00;
              }
  						TxLength = 2050;//TxLength = 6;
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
							break;
  case SEEDNKEYPSAREQUEST: 
              sysSetVariableData(sysvar::DIAG_FD3::PSA_SecAcc::Seed_value,l_Seed_value,elCount(l_Seed_value));//Reset
							TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x03;
							TxLength = 2;
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
							break; 
  case SEEDNKEYPSARESP: 
              @sysvar::DIAG_FD3::PSA_SecAcc::Trigger_Status=0;//Rest
							TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x04;
							TxLength = sysGetVariableData(sysvar::DIAG_FD3::PSA_SecAcc::Key_value, l_Key_value ,copiedBytes);
              for(i=0;i<4;i++)
              {
                 TxDataBuffer[i+2] =l_Key_value[i];
              }
							TxLength = 6;
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
							break;      
/*

  case SEEDNKEYRESP: 
							TxLength = 5;
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
							//write("))))))))))))))))))) %d",TxLength);
							break; 
  case READ_Software_version: 
							TxDataBuffer[0] = 0x22;
							TxDataBuffer[1] = 0xF1;
							TxDataBuffer[2] = 0x88;  
							TxLength = 3; 
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
							break;
*/
  }
}   

MyEvaluateResponse ()
{
	int i;
	int RespLength;

	char buffer[255];
	char buffer2[255]="0";

 
	strncpy(buffer2, "0", 6);
	strncpy(MVbuffer2, "",6);
	strncpy(MVbuffer, "",6);

	if( ReceiveBufferLength > 255 )
	{
		strncpy(buffer, "Answer length too big!",99);//English
    //strncpy(buffer, "Antwortlaenge zu gross!",99);//German
		//write("An error %s has occurred!", buffer)//English
		//write("Fehler '%s' ist aufgetreten!", buffer);an error has occurred
	}

	if( NrNeededRespBytes != 0 )
	{
		RespLength = NrNeededRespBytes;
	}
	else
	{
		RespLength = ReceiveBufferLength;
	}
	
	for(i=0; i < RespLength; i++)
	{
		ltoa(RxDataBuffer[i], MVbuffer2, 16);
		if( strlen( MVbuffer2 ) == 1 )
		{
			strncat(buffer2, MVbuffer2, 254);
			strncat(MVbuffer, buffer2, 254);
			strncpy(buffer2, "0", 6);
		}
		else
		{
			strncat(MVbuffer, MVbuffer2, 254);
		}
	}
  sysSetVariableString(sysvar::DIAG_FD3::sysDataReceived_String ,MVbuffer);
}

void EvaluateRxData( int Length )
{
   int      DtcNr;  
   dword    auxRT;
   float    convert_rad_grad = 57.295779513082320876798154814105;

   dword    resultarray_32[6]={0,0,0,0,0,0};

   dword    REP_RBA_CBB_AKEY_VALUE  = 0x41916668;
   dword    REP_RBA_CBB_BKEY_VALUE  = 0x12774118;
   dword    REP_RBA_CBB_CKEY_VALUE  = 0x86905668;
   dword    REP_RBA_CBB_DKEY_VALUE  = 0x10371229;


   dword    WERK_RBA_CBB_AKEY_VALUE = 0x52917768;  //Minicode 2703/2704
   dword    WERK_RBA_CBB_BKEY_VALUE = 0x12774118;   // Porsche
   dword    WERK_RBA_CBB_CKEY_VALUE = 0x86905668;  // Porsche
   dword    WERK_RBA_CBB_DKEY_VALUE = 0x21482338;  // Porsche

   dword    DEV_RBA_CBB_AKEY_VALUE  = 0x46947376; //Minicode 2721/2722
   dword    DEV_RBA_CBB_BKEY_VALUE  = 0x12774118;  // Porsche
   dword    DEV_RBA_CBB_CKEY_VALUE  = 0x86905668;  // Porsche
   dword    DEV_RBA_CBB_DKEY_VALUE  = 0x45982573;   // Porsche

   dword    RBEOLPin = 0x42444441; //It has been derived from the ASCII values of "Bosch Diagnostics for Driver Assistance"
   dword    PMARequest = 0x80FA1108; //Plant mode activation part request

   dword    keytemp;
   char    buffer[50],tempbuffer[50];
   Byte    ByteValue[1];
   int     IdentifierId;
   int     IdentifierValue;

   int      i;
   dword j,m,k;
   
   char     Seed[1024];
   byte     puffer[128];
   byte securityRespBuffer[1100];
   char pufferStr[2200];
   char temp[5];
   char IMBuffer[4];
   int responseLen;
  
    //*****************************************************************//
    byte First_MID[4096];  
    byte Last_MID[4096];
    char	MVbuffer[4096] = "";
    char	MVbuffer2[4096] = "";
    char  buffer2[4096]="0"; 
    char	MVbuffer5[4096] = "";
    char	MVbuffer6[4096] = "";
    char  buffer5[4096]="0";
    dword bufferSize;
    int RBflag1 =0;
    int RBflag2 = 0;
    
    strncpy(buffer2, "0", 4);
	  strncpy(MVbuffer2, "",4);
	  strncpy(MVbuffer, "",4);
    strncpy(buffer5, "0", 4);
	  strncpy(MVbuffer6, "",4);
	  strncpy(MVbuffer5, "",4);


  
    //**************************************************************// 
    
    EvaluateResponse( );  
  
    switch ( CurrentDiagServ )  
    {
      
     case READ_DTC_BY_ST:  
          if ( RxDataBuffer[0] == 0x59 )
          {
            RxBufferIndex  = 3;
            NrOfReadDTC    = (Length - 3)/4;  
            DtcNr        = 1; 
            for (i = 0; i < NrOfReadDTC; i++)
            {
                  errorDTC[DtcNr]      = (dword)RxDataBuffer[RxBufferIndex++] << 16;
                  errorDTC[DtcNr]      += (dword)RxDataBuffer[RxBufferIndex++] << 8;
                  errorDTC[DtcNr]      += (dword)RxDataBuffer[RxBufferIndex++]; 
                  errorStatus[DtcNr++] = RxDataBuffer[RxBufferIndex++];
			   
            }
            if ( (NrOfReadDTC == 0) )
            {
              sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "No DTCs");
            }else{
                   sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "All DTCs received");
                  }

               CurrentDTC = 1;
               ShowDTCs();
            }
          break;
      /*
      case VIN_LEARN_STATUS:
      
             if(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x01)
             {
                putvalue(Env_VIN_Display,"Specified VIN already stored");
             }
             else if(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x00)
				     {
					      putvalue(Env_VIN_Display,"VIN Learn Successful");
				     } 
             else if(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0xFF)
				     {
					      putvalue(Env_VIN_Display,"VIN Learn Not Successful");
				     }
            else
            {
                putvalue(Env_VIN_Display,"Unknown Status");
            }
      break;
            
      case VIN_LEARN_START:
      
             if(RxDataBuffer[0] == 0x71 && RxDataBuffer[4] == 0x7B)
             {
                putvalue(Env_VIN_Display,"VIN Learn started");
             }  
             else
             {
                putvalue(Env_VIN_Display,"Unknown Status");
             }
      break;
            
      case VIN_LEARN_STOP:
      
             if(RxDataBuffer[0] == 0x71 && RxDataBuffer[4] == 0x7A)
             {
                putvalue(Env_VIN_Display,"VIN Learn Stopped");
             }  
             else if(RxDataBuffer[0] == 0x71 && RxDataBuffer[4] == 0x78)
             {
                putvalue(Env_VIN_Display,"VIN Learn Stopped before completion");
             }
             else
             {
                putvalue(Env_VIN_Display,"Unknown Status");
             }
      break;
      
            
      case SEEDNKEYJLRREQUEST: 
                Seed_buf[0] = RxDataBuffer[2];
                Seed_buf[1] = RxDataBuffer[3];
                Seed_buf[2] = RxDataBuffer[4];
                Key_Calculation();
                StartDiagService( SEEDNKEYRESP);
         break;     
    case ALIGNMENT_RUN_STATUS:
    case ALIGNMENT_STATUS:
          //write("^^^^^^^^ %x %x %x",RxDataBuffer[0],RxDataBuffer[3],RxDataBuffer[5]);
      
          if((RxDataBuffer[3] != 0x0F)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] != 0x0F))
          {
             if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x09)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x09))
             {
                sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Target Not Found");
             }
             else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x07)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x07))
				     {
					      sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Alignment Successful");
				     }
				     else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x08)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x08))
				     {
					      sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Alignment Aborted");
				     }
             else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x0A)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x0A))
				     {
					      sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Invalid Input Value");
				     }
             else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x06)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x06))
				     {
					      sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Alignment Not Executed");
				     }
             else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x0B)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x0B))
				     {
					      sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Horizontal Bad Angle");
				     }
             else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x0C)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x0C))
				     {
					      sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Vertical Bad Angle");
				     }
				     else
				     {
					      sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Unknown Error");
				     }
                  cancelTimer(alignmentTimer);
        }
				else
				{
					sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Alignment in progress");
				}
				
	  break;*/
	case ALIGNMENT_START:
              Alignment_start_Evaluate();
							break;
	case ALIGNMENT_STOP:
              Alignment_stop_Evaluate();
							break;
	case ALIGNMENT_STATUS:
              Alignment_status_Evaluate();
							break;
	case ALIGNMENT_MEAR_RES:
              Alignment_Current_Value_Read_Evaluate();
							break;
	case ALIGNMENT_DATA_R:
              Alignment_Data_Read_Evaluate();
							break;
	case ALIGNMENT_DATA_W:
              Alignment_Data_Write_Evaluate();
							break;
	case ALIGNMENT_TOL_R:
              Alignment_Data_Read_Evaluate();
							break;
	case ALIGNMENT_TOL_W:
              Alignment_Data_Write_Evaluate();
							break;
	case ALIGNMENT_CURR_VAL:
              Alignment_Current_Value_Read_Evaluate();
							break;
  case ITC_READ:  
              parseITCData(RxDataBuffer,Length);
              break;
  case READ_BOSCH_CODING:
              Bosch_coding_Read_Evaluate();
							break;
  case WRITE_BOSCH_CODING:
              Bosch_coding_Write_Evaluate();
							break;
  case SEEDNKEYBOSCHREQUEST: 
              Bosch_seed_req_Evaluate();
              break; 
  case SEEDNKEYBOSCHRESP: 
              Bosch_key_req_Evaluate();
              break; 
  case SEEDNKEYPSAREQUEST: 
              PSA_seed_req_Evaluate();
							break; 
  case SEEDNKEYPSARESP: 
              PSA_key_req_Evaluate();
							break; 
	  /*
	  case READ_BOSCH_CODING:
        for(i = 0; i<elcount(BoschCodingBuffer); i++)
    		{
    			BoschCodingBuffer[i] = RxDataBuffer[i];
    		}
    		
    		BoschCodingRead(RxDataBuffer);
    		break;
  */
  }

}  

int EvaluateResponse()
{  
   int ret; 
   ret = 0;

   if ( RxDataBuffer[0] == 0x7F )
   {
   
      switch ( RxDataBuffer[2] ) 
      {
         case 0x10:
                  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "General reject");
                  break;

         case 0x11: 
                  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Service not supported");
                  break;

         case 0x12: 
                  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "SubFunction Not Supported");
                  break;

         case 0x13: 
                  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, " InCorrect Message Length-invalid Format");
                  break;

         case 0x21: 
                  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Busy Repeat Request");
                  break;

         case 0x22: 
                  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Conditions Not Correct");
                  break;

     //    case 0x23: 
     //           sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Routine not complete");
     //           break;

         case 0x24: 
                  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Request Sequence Error");
                  break;

         case 0x26: 
                  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Failure Prevents Execution of requested action");
				  break;

         case 0x31: 
				  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Request Out Of Range");
				  break;

         case 0x33: 
				  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Security Access Denied");
				  break;

         case 0x35: 
				  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Invalid key");
				  break;

         case 0x36: 
				  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Exceed number of attempts");
				  break;

         case 0x37: 
				  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Time delay not expired");
				  break;

         case 0x78: 
				  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Request Correctly Received-Response Pending");
				  // Wait
				  ret = 0; 
				  break;

      //   case 0x80: 
      //      sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Service not supported in active mode");
      //   break;

         case 0x7E: 
				  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "SubFunction Not Supported In Active Diagnostic Session");
				  break;

         case 0x7F: 
				  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Service Not Supported In Active Diagnosic Session");
				  break;
             
         case 0x83: 
				  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Condition not correct - Engine running");
				  break;
         
         case 0x88: 
				  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Vehicle Speed Too High");
				  break;

         case 0x89: 
				  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Negative Response:ESP_v_Signal<= 50 km/h");
				  break;
         
        case 0x93:
				  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "VoltageTooLow");
				  break;

        case 0x92:
				  sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "VoltageTooHigh");
				  break;


         default:   
				 sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status, "Negative Response: Acknowledge not defined");
				 break;
         }
   }
   else
   {
      if ( RxDataBuffer[0] == ( SId + 0x40 ) )        
      {
         // Positive response
         sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status,"OK! Positive response");
         ret = 1; 
      }
      else                      
      {
        sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_Status ,"Unknown response");
        ret = 0; 
      }
   }

   return ( ret ); 
}

void TransmitTxBuffer (void)
{ 
  // OSEK TP supports up to 4 GiB with Jumbo frames, but limit that to a much lower value for this demo
  int fd_dlc;
  int temp_sysMaxFDFrameLen;
  temp_sysMaxFDFrameLen = @sysvar::DIAG_FD3::GeneralSettings::sysMaxFDFrameLen;
  
  if (TxLength > kBufferSizeJumbo)
      TxLength = kBufferSizeJumbo;
  
  fd_dlc=TxLength+2;
  
  if((fd_dlc>8) && (fd_dlc<13))
    set_sysMaxFDFrameLen(12);
  else if((fd_dlc>12) && (fd_dlc<17))
    set_sysMaxFDFrameLen(16);
  else if((fd_dlc>16) && (fd_dlc<21))
    set_sysMaxFDFrameLen(20);
  else if((fd_dlc>20) && (fd_dlc<25))
    set_sysMaxFDFrameLen(24);
  else if((fd_dlc>24) && (fd_dlc<33))
    set_sysMaxFDFrameLen(32);
  else if((fd_dlc>32) && (fd_dlc<49))
    set_sysMaxFDFrameLen(48);
  else if((fd_dlc>48) && (fd_dlc<64))
    set_sysMaxFDFrameLen(64);
  
  writeDbgLevel(1,"%s, connection %d: Send request for %d data bytes",gECU, kIdTester1, TxLength);

  setTimerCyclic(tFlashTxLEDTester1, kDuration_LEDFlash_ms);
  setTimer(tSwitchOffTxLEDTester1, kDuration_RxLEDFlashOff_ms);

  CanTpSendData(gHandleTester1, TxDataBuffer, TxLength);
 
	if(TxDataBuffer[0] != 0x3E)
  {
    sysSetVariableData(sysvar::DIAG_FD3::sysDataReceived,emptyString,0);
    sysSetVariableInt(sysvar::DIAG_FD3::sysNoOfBytesReceived,0);
    sysSetVariableString(sysvar::DIAG_FD3::sysDataReceived_String,"");// delete old value from receive 

    sysSetVariableData(sysvar::DIAG_FD3::sysDataToTransmit,TxDataBuffer,TxLength);
  }
	SId = TxDataBuffer[0];
  
  @sysvar::DIAG_FD3::GeneralSettings::sysMaxFDFrameLen=temp_sysMaxFDFrameLen;//Reset
}

OSEKTL_DataCon(long status)
{
	if (status != 0) 
	{
		RespTime = ( (float) timeNow() * (-1.0) );	
       	
	}
	else
	{
		write("Tx error, status is %d", status);
	}
}

on sysvar_update sysvar::DIAG_FD3::SESSION::TESTER_PRESENT
{ 
    if ( @this ) 
    {
        StartDiagService( TESTER_PRESENT_ON );
        setTimer (TesterPresentTimer, FirstTesterPresentTime);//First time
    }
    else
    {
        cancelTimer (TesterPresentTimer);
    } 
}

on timer TesterPresentTimer
{
   StartDiagService( TESTER_PRESENT_ON );
   // reStart timer
   setTimer (TesterPresentTimer, TesterPresentTime);
} 

on sysvar_update sysvar::DIAG_FD3::SESSION::DEF_SESS
{ 
    if ( @this ) 
    {
      StartDiagService( DEFAULT_SESSION );
    }
     
}

on sysvar_update sysvar::DIAG_FD3::SESSION::PRO_SESS
{ 
    if (@this ) 
    {
      StartDiagService( PROGRAM_SESSION );
    }
    
}

on sysvar_update sysvar::DIAG_FD3::SESSION::EXT_SESS
{ 
    if ( @this ) 
    {
      StartDiagService( EXTENDED_SESSION );
    }  
}

on sysvar_update sysvar::DIAG_FD3::SESSION::BOS_SESS
{ 
    if ( @this ) 
    {
      StartDiagService( BOSCH_SESSION );
    }  
}

on sysvar_update sysvar::DIAG_FD3::ECU_RESET::Hard_Rest
{ 
    if ( @this ) 
    {
      StartDiagService( ECU_HARD_RESET );
    }
     
}

on sysvar_update sysvar::DIAG_FD3::ECU_RESET::Soft_Rest
{ 
    if ( @this ) 
    {
      StartDiagService( ECU_SOFT_RESET );
    }
     
}
/*
on timer readDtcTimer
{
    int i;
    readTimeValue+=CNTR_VALUE;

    if (readTimeValue < 1000)   //try to read until 1000ms
    {
        //putValue(EnvDirectSend,readString);
		TxLength = (requestSize - 1)/2;
        for (i=0; i<TxLength; i++) TxDataBuffer[i]=readRequest[i];
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}


        strncpy(DTCValue,ErrString,strlen(ErrString)+1);
        //write("At %f DTCValue=%s",timeNowFloat()/100000,DTCValue);

        // if NOT "Busy Repeat Request", NOT "OK", NOT "Response Pending"
        if ( strncmp(DTCValue,"7f1921",6)!=0 &&     
             strncmp(DTCValue,"54",2)    !=0 &&
             strncmp(DTCValue,"7f1978",6)!=0 &&
             strlen(DTCValue)            !=0 )      
        {
            putValue(EnvErrValueOutput,DTCValue);
        } 
        else
        {
            //else (if "Busy...") do nothing
        }

        setTimer(readDtcTimer,CNTR_VALUE);
    }
    else  // time elapsed
    {
        cancelTimer(readDtcTimer);
        if (getValue(EnvErrValueOutput,DTCValue)==0)
        {
            putValue(EnvErrValueOutput,"No answer received.");
        }

        //syncronise the environmental variables
        putValue(EnvErrValueOutput,DTCValue);
        //write("***At %f EnvErrValueOutput= %s",timeNowFloat()/100000,DTCValue);

    }

}

on sysvar sysvar::DIAG_FD3::DTC_INFO::DTC_SetReadDTC
{
    int i;

    getValue(this,readString);

    if (strlen(readString)!=0) {

        //initialization
        requestSize = getValueSize(EnvSetReadDTC);
        strncpy(DTCValue,"",255);
        readTimeValue=0;
        putValue(EnvErrValueOutput,"");
        for (i=0;i<2048;i++) ErrValue[i]=0;
        //write("***At %fs (timer=%ims) request= %s",timeNowFloat()/100000,CNTR_VALUE,readString);

        //start timer at first time
        setTimer(readDtcTimer,CNTR_VALUE);

    } //end if
    //putValue(EnvDirectSend,readString);

	//getValue(EnvSetReadDTC,readString);
	if( strlen(readString) == 0 )
	{
		//write("Variable neu initialisiert");
		//putValue(EnvSendBuffer_1,0);
	}
	else
	{
		strncpy(tempString, "0x",3);

		for(i=0; i<= requestSize-3; i+=2)
		{
			tempString[2] = readString[i];
			tempString[3] = readString[i+1];
			tempString[4] = 0;
			readRequest[i/2] = atol( tempString );
		}
		//putValue(EnvTxData_1CAN, TransmitBuffer, length);
		//putValue(EnvTransferCAN, length);
		//putValue(EnvSendBuffer_1,1);

		TxLength = (requestSize - 1)/2;
        for (i=0; i<TxLength; i++) TxDataBuffer[i]=readRequest[i];
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
	}

    putValue(EnvSetReadDTC,"");

}
*/
on sysvar_update sysvar::DIAG_FD3::DTC_INFO::DTC_Read
{ 
    if ( @this ) 
    {
        ClearDtcDisplay();
        StartDiagService( READ_DTC_BY_ST );
    }
}

on sysvar_update sysvar::DIAG_FD3::DTC_INFO::DTC_Clear
{ 
    if ( @this ) 
    {
      StartDiagService( CLEAR_DTC );
	    ClearDtcDisplay();
    }
}

on sysvar_update sysvar::DIAG_FD3::DTC_INFO::DTC_CountDown
{ 
    if ( @this ) 
    {
            CurrentDTC--;
            ShowDTCs(); 
        }
}

on sysvar_update sysvar::DIAG_FD3::DTC_INFO::DTC_CountUP
{ 
    if ( @this ) 
    {
            CurrentDTC++;
            ShowDTCs(); 
        }
}

void GetDtcName (dword error,int DTC_or_historical)
{	
	char DTCText [256] = "";
  long res;
  int v;

  // Hole DTC Beschreibung aus Tabelle
  // res=GetDTCdescription_Kamera(error, DTCText); 
  
  for (v = 0; v < elcount(DTCText); v++)
  {
      DTCText[v] = ' ';
  }
  
  res=GetDTCdescription(error, DTCText);
  
  write("GetDtcName::%d",res);
  if(res == 0) // DTC in Tabelle nicht gefunden
  {
      snprintf( DTCText, 255,"Unknown Error: %d",error);
  }

 	if (DTC_or_historical==1)  //ReadDTC
	{
    write("DTCText::%s",DTCText);
		res=sysSetVariableString(sysvar::DIAG_FD3::DTC_INFO::DTC_Name,DTCText);
	}
   
} 

long GetDTCdescription(dword error, char DTCText[])
{
  char str1[100]; 
  char str[100]; 
  long pos;
  int k, m;
  filehandle = 0;
  k = 0;
  
  ltoa(error, str1, 16); // dword to string
  toUpper(str, str1, elcount(str));
  
  filehandle = openFileRead("FD3_UDS_DTC_map.csv", 0);

  if (filehandle != 0) 
  {   
     while (fileGetString(buffer, elcount(buffer), filehandle) != 0) // till end of file ...
  	 {        
         pos = strstr(buffer, str);
      	 
         if (pos != -1)
         {
          	 for (i = pos; i > 0 ; i--)
             {
                if (buffer[i] == ';')
                {
                    for (j = i-1; j > 0; j--)
                    {
                        if (buffer[j] != ';')
                				{
                           continue;
                        }
                        else
                        {
                           break;
                        }
                    }
                    
                    for (m = j+1; m <= i-1; m++)
                    {
                        DTCText[k++] = buffer[m];
                    }
                    
                    return 1;
                }               
          	  }	  
          }
      }
  }
  
  return 0;  
}

void ClearDtcDisplay (void)
{
   NrOfReadDTC = 0;
   CurrentDTC  = 0;
  
   ShowDTCs();
}

void ShowDTCs (void)
{
   char buffer[50];
   long buffer_dec;
   
   if ( CurrentDTC > NrOfReadDTC )
   {
      CurrentDTC = NrOfReadDTC;
   } 
   else if ( (CurrentDTC < 1) && (NrOfReadDTC) )
   {
      CurrentDTC = 1;
   }
   else if ( (CurrentDTC < 0) && (!NrOfReadDTC) )
   {
      CurrentDTC = 0;
   } 

   snprintf (buffer, 49, "%02d/%02d", CurrentDTC, NrOfReadDTC);
   sysSetVariableString(sysvar::DIAG_FD3::DTC_INFO::DTC_Position,buffer);

   if ( CurrentDTC )
   {
      // DTC No
      snprintf (buffer, 49, "%06x",   errorDTC[CurrentDTC]);
      sysSetVariableString(sysvar::DIAG_FD3::DTC_INFO::DTC_Nr,buffer);

      //DTC Status
      snprintf (buffer, 49, "%02x", errorStatus[CurrentDTC]);
      sysSetVariableString(sysvar::DIAG_FD3::DTC_INFO::DTC_State,buffer);
      GetDtcName (errorDTC[CurrentDTC],1);
      

   }
   else
   {
      sysSetVariableString(sysvar::DIAG_FD3::DTC_INFO::DTC_Nr,"----");
      sysSetVariableString(sysvar::DIAG_FD3::DTC_INFO::DTC_State,"--");
      sysSetVariableString(sysvar::DIAG_FD3::DTC_INFO::DTC_Name,"----");
   } 

}

FillErrString (int length)
{
  //to create string representation of (bin)ErrValue[] in (char)ErrString[]

  char temp[3];
  int i;
  strncpy(ErrString,"",0);
  if (length!=0)
  {
  for (i=0;i<length;i++) 
      {
      strncpy(tempString,"",0);
      ltoa(ErrValue[i],temp,16);
      if (strlen(temp)==1) strncpy(tempString,"0",2);
      strncat(tempString,temp,(strlen(tempString)+strlen(temp))+1);
      //if (i<10) write("%d.%s->%s",i,temp,tempString);
      strncat(ErrString,tempString,strlen(tempString)+strlen(ErrString)+1);
      }
  length=0;
  //write("***At %f ErrString= %s",timeNowFloat()/100000,ErrString);
  }


}

//on timer ActPMode
//{
//    StartDiagService( P_MODE_ACT_P2 );
//}

/*

on timer UpdateRuntime
{
	StartDiagService( GET_SYS_RUNTIME );
	SetTimer( UpdateRuntime, UpdateCycle);
}


on start
{
    defaultsec[0] = 0x61;
    putvalue(Env_Doip_Security_SubFunctionCAN,defaultsec);
    defaultsec[0] = 0x01;
    putvalue(Env_Doip_Security_SubFunction2CN,defaultsec);
    // Default Suche nach DTC 000124
    putValue(Env_ITC_Display,"");
    putValue(Env_VIN_Display,"");
    putValue(Env_Alignment_Display,"");
    putValue(EnvTesterPresentOnOffCAN,0);
  
}

On envVar Env_VINLearn
{
  if ( getValue (this) )
  {
     putvalue(Env_JLRSecurity_CCM,1);
     setTimer(VINTimer,300);
     VINFlag = 1;
  }
}

On envVar Env_VINLearn_Stop
{
  if ( getValue (this) )
  {
     putvalue(Env_JLRSecurity_CCM,1);
     setTimer(VINTimer,300);
     VINFlag = 2;
  }
}

On envVar Env_VINLearn_Status
{
  if ( getValue (this) )
  {
     putvalue(Env_JLRSecurity_CCM,1);
     setTimer(VINTimer,300);
     VINFlag = 3;
  }
}
*/
on timer VINTimer
{
  /*
  if(VINFlag == 1)
  {
    StartDiagService( VIN_LEARN_START );
  }
  else if(VINFlag == 2)
  {
    StartDiagService( VIN_LEARN_STOP );
  }
  else if(VINFlag == 3)
  {
    StartDiagService( VIN_LEARN_STATUS );
  }
  else if(VINFlag == 4)
  {
    StartDiagService( ECU_HARD_RESET );
  }
  else */
}

on timer alignmentTimer
{
  switch(ALIGNFlag)
  {
    case 1:
          StartDiagService( ALIGNMENT_START );
          break;
    case 2:
          StartDiagService( ALIGNMENT_STOP );
          break;
    case 3:
          StartDiagService( ALIGNMENT_STATUS );
          break;
    case 4:
          StartDiagService(ALIGNMENT_RUN_STATUS);
          break;
  }
  ALIGNFlag=0;//Reset
  /*
  if((ALIGNFlag!=0) && (ALIGNFlag!=4))
  {
    ALIGNFlag=4;
    setTimerCyclic(alignmentTimer,500);
  }
  */
}

/*
on envVar Env_JLRSecurity_CCM
{
   if ( getValue (this) )
    {
        
      StartDiagService( EXTENDED_SESSION );
      setTimer(JLRUnlockTimer,100);
      putvalue(Env_JLRSecurity_CCM,0);
    }
}

On timer JLRUnlockTimer
{
  StartDiagService( SEEDNKEYJLRREQUEST );
}

on envVar Env_BoschCoding_Read
{
	if ( getValue (this) )
    {
      StartDiagService( READ_BOSCH_CODING );
    }
}

on envVar Env_BoschCoding_Write
{
	if ( getValue (this) && (BoschCodingBuffer[0] == 0x62))
    {
		BoschCodingWrite();
		for(i = 0; i<elcount(BoschCodingBuffer);i++)
		{
			TxDataBuffer[i] = BoschCodingBuffer[i];
		}
		StartDiagService( WRITE_BOSCH_CODING );
    }
}

CalculateKey (dword SeedValue,dword RBA_CBB_AKEY_VALUE, dword RBA_CBB_BKEY_VALUE, dword RBA_CBB_CKEY_VALUE, dword RBA_CBB_DKEY_VALUE)
{

        int      j;
        dword    keytemp;
      
        
        	keyReprogValue = SeedValue;

        	for(j = 0; j <8 ; j++)
        	{

            	keytemp = keyReprogValue ;
            	keyReprogValue = keyReprogValue + RBA_CBB_AKEY_VALUE;
	       		  // write(" keytemp and keyReprogValue  for j value %i beginning loop: %lx, %lx ",j, keytemp, keyReprogValue );    
    
    			if((keyMaxReprogValue - RBA_CBB_AKEY_VALUE) < keytemp)
    			{
    	  		//Rotate Right by 10 
 	       		keyLowReprogValue = keyReprogValue & (0x000001FF);
 	    			keyUpperReprogValue = keyLowReprogValue << 23;
 	    			keyReprogValue = keyReprogValue >> 9;
 	    			keyReprogValue = keyReprogValue | keyUpperReprogValue;
       			keyReprogValue = keyReprogValue ^ RBA_CBB_BKEY_VALUE;

           }
    			else
    			{
 	    		//Rotate Left by 13 
 	    		  keyUpperReprogValue = keyReprogValue & (0xFFF80000);
 			      keyLowReprogValue   = keyUpperReprogValue >> 19;
 			    	keyReprogValue      = keyReprogValue << 13;
		 	    	keyReprogValue      = keyReprogValue | keyLowReprogValue;
		        keyReprogValue      = keyReprogValue ^ RBA_CBB_CKEY_VALUE;

           }
         }
 
         keyReprogValue = keyReprogValue - RBA_CBB_DKEY_VALUE;
              
           
         //Key Algo end 
			    //   write(" final  keyReprogValue %lx",keyReprogValue ); 
}

void BoschCodingWrite()
{
	BoschCodingBuffer[0] = 0x2E;
	BoschCodingBuffer[1] = 0xFD;
	BoschCodingBuffer[2] = 0x07;

	BoschCodingBuffer[9] = @Env_DMonitoring_1>>8;
	BoschCodingBuffer[10] = @Env_DMonitoring_1;
	
	BoschCodingBuffer[11] = @Env_DMonitoring_2>>8;
	BoschCodingBuffer[12] = @Env_DMonitoring_2;
	
	BoschCodingBuffer[13] = @Env_DMonitoring_3>>8;
	BoschCodingBuffer[14] = @Env_DMonitoring_3;
	
	BoschCodingBuffer[15] = @Env_DMonitoring_4>>8;
	BoschCodingBuffer[16] = @Env_DMonitoring_4;
	
	BoschCodingBuffer[17] = @Env_DMonitoring_5>>8;
	BoschCodingBuffer[18] = @Env_DMonitoring_5;
	
	BoschCodingBuffer[19] = @Env_DMonitoring_6>>8;
	BoschCodingBuffer[20] = @Env_DMonitoring_6;
	
	BoschCodingBuffer[21] = @Env_DMonitoring_7>>8;
	BoschCodingBuffer[22] = @Env_DMonitoring_7;
	
	BoschCodingBuffer[23] = @Env_DMonitoring_8>>8;
	BoschCodingBuffer[24] = @Env_DMonitoring_8;
	
	BoschCodingBuffer[25] = @Env_DMonitoring_9>>8;
	BoschCodingBuffer[26] = @Env_DMonitoring_9;
	
	BoschCodingBuffer[27] = @Env_DMonitoring_10>>8;
	BoschCodingBuffer[28] = @Env_DMonitoring_10;
	
	BoschCodingBuffer[29] = @Env_DMonitoring_11>>8;
	BoschCodingBuffer[30] = @Env_DMonitoring_11;
	
	BoschCodingBuffer[31] = @Env_DMonitoring_12>>8;
	BoschCodingBuffer[32] = @Env_DMonitoring_12;
	
	BoschCodingBuffer[33] = @Env_DMonitoring_13>>8;
	BoschCodingBuffer[34] = @Env_DMonitoring_13;
	
	BoschCodingBuffer[35] = @Env_DMonitoring_14>>8;
	BoschCodingBuffer[36] = @Env_DMonitoring_14;
	
	BoschCodingBuffer[37] = @Env_DMonitoring_15>>8;
	BoschCodingBuffer[38] = @Env_DMonitoring_15;
	
	BoschCodingBuffer[39] = @Env_DMonitoring_16>>8;
	BoschCodingBuffer[40] = @Env_DMonitoring_16;
	
	BoschCodingBuffer[41] = @Env_DMonitoring_17>>8;
	BoschCodingBuffer[42] = @Env_DMonitoring_17;
	
	BoschCodingBuffer[43] = @Env_DMonitoring_18>>8;
	BoschCodingBuffer[44] = @Env_DMonitoring_18;
	
	BoschCodingBuffer[45] = @Env_DMonitoring_19>>8;
	BoschCodingBuffer[46] = @Env_DMonitoring_19;
	
	BoschCodingBuffer[47] = @Env_DMonitoring_20>>8;
	BoschCodingBuffer[48] = @Env_DMonitoring_20;
}

void BoschCodingRead(byte RxData1[])
{
  if(@Env_ReadBoschCode_Check == 1)
  {
    //Do nothing
  }
  else
  {
	@Env_DMonitoring_1 = (RxData1[9]<<8)+RxData1[10];
	@Env_DMonitoring_2 = (RxData1[11]<<8)+RxData1[12];
	@Env_DMonitoring_3 = (RxData1[13]<<8)+RxData1[14];
	@Env_DMonitoring_4 = (RxData1[15]<<8)+RxData1[16];
	@Env_DMonitoring_5 = (RxData1[17]<<8)+RxData1[18];
	@Env_DMonitoring_6 = (RxData1[19]<<8)+RxData1[20];
	@Env_DMonitoring_7 = (RxData1[21]<<8)+RxData1[22];
	@Env_DMonitoring_8 = (RxData1[23]<<8)+RxData1[24];
	@Env_DMonitoring_9 = (RxData1[25]<<8)+RxData1[26];
	@Env_DMonitoring_10 = (RxData1[27]<<8)+RxData1[28];
	@Env_DMonitoring_11 = (RxData1[29]<<8)+RxData1[30];
	@Env_DMonitoring_12 = (RxData1[31]<<8)+RxData1[32];
	@Env_DMonitoring_13 = (RxData1[33]<<8)+RxData1[34];
	@Env_DMonitoring_14 = (RxData1[35]<<8)+RxData1[36];
	@Env_DMonitoring_15 = (RxData1[37]<<8)+RxData1[38];
	@Env_DMonitoring_16 = (RxData1[39]<<8)+RxData1[40];
	@Env_DMonitoring_17 = (RxData1[41]<<8)+RxData1[42];
	@Env_DMonitoring_18 = (RxData1[43]<<8)+RxData1[44];
	@Env_DMonitoring_19 = (RxData1[45]<<8)+RxData1[46];
	@Env_DMonitoring_20 = (RxData1[47]<<8)+RxData1[48];
  }
	
}

void Key_Calculation()
{

 long request,response; // message handles
 byte KeyArray1, KeyArray2, KeyArray3;
 byte gChallengebyte[8];
 // Declare and initialize the temporary variables 
	long InitialVal ;
    //long challengebyte = 0X5E4D3C2B1A;
	byte Index, ModVal, RefIndex, BitValue,temp1,temp2,mask;

  InitialVal = 0XC541A9;request=0;response=0;Index=0; 
  ModVal=0; RefIndex=0; BitValue=0;temp1=0;temp2=0;mask=0;
  
  //Initialize the Challenge Bytes 
	gChallengebyte[7] = 0x34;//0x4D;
	gChallengebyte[6] = 0x31;//0x52;
	gChallengebyte[5] = 0x52;//0x52;
	gChallengebyte[4] = 0x52;//0x31;
	gChallengebyte[3] = 0x4D;//0x34;0

	// MSB of the Seed is stored in the least byte of the array 
	gChallengebyte[0] = Seed_buf[0];
	gChallengebyte[1] = Seed_buf[1];
	gChallengebyte[2] = Seed_buf[2];
   
  for (Index = 0; Index < 64; Index++)
	{
        ModVal = (Index % 8);
  
		if((ModVal == 0) && (Index != 0))
		{
   
          RefIndex++;
    }
        temp1 = (InitialVal & 0x000001);
        temp2= gChallengebyte[RefIndex] & (0x000001);
        gChallengebyte[RefIndex]= gChallengebyte[RefIndex]>>1;
        BitValue = temp1 ^ temp2;
        InitialVal = ( InitialVal >> 1);
      
        if(BitValue != 0)
        {
            InitialVal ^= 0x909028;
        }
	}
 //Byte R1 - Most Significant Byte of the Key 
	KeyArray1 = ((InitialVal & 0x000000F0) >> 4);
	KeyArray1 |= ((InitialVal & 0x00000F00) >> 4);

	// Byte R2 
	KeyArray2 = ((InitialVal & 0x00F00000) >> 20);
	KeyArray2 |=((InitialVal & 0x0000F000) >> 8);

	// Byte R3 - Least Significant Byte of the Key 
	KeyArray3 = ((InitialVal & 0x000F0000) >> 16);
	KeyArray3 |= ((InitialVal & 0x0000000F) << 4);
  TxDataBuffer[0] = 0x27;
  TxDataBuffer[1] = 0x04;
  TxDataBuffer[2] =KeyArray1;
  TxDataBuffer[3]=KeyArray2;
  TxDataBuffer[4]=KeyArray3;

}



On EnvVar EnvReadswversion
{
    
        if ( getValue ( this ) )
        {
            ClearDtcDisplay();
            StartDiagService( READ_Software_version );
        }

}

void statusParser(byte status)
{
  strncpy(gstatusITC,"",22);
  if(status == 0x11)
  {
    strncpy(gstatusITC,"FAILED_FIRST        ",22);
  }
  else if(status == 0x32)
  {
    strncpy(gstatusITC,"HEALED_AFTER_FAILED ",22);
  }
  else if(status == 0x31)
  {
    strncpy(gstatusITC,"FAILED_AFTER_HEALED ",22);
  }
  else
  {
    strncpy(gstatusITC,"NO_ITC              ",22);
  }
}

EvaluateEnvData()
{
  snprintf( StringAux,99,"Environment data:                ");
  strncpy( Stringbuffer, StringAux,255);

  switch( ( (word)RxDataBuffer[2] << 8 ) | (word)RxDataBuffer[3] )
  {
    default:
    {
    }
    break;
  }

  putValue( EnvEnvDataDisplay, Stringbuffer);

}

void GetSupplier(byte Code, char Supplier[])
{
   switch ( Code )
   {
	  case 0x03: 
	  	strncpy(Supplier,"Bosch",10);
	  break; 

      default:   
	  	strncpy(Supplier,"Error!!",10);
      break; 
   }
}


*/

on busOff
{
   resetCan();
}

double raw_to_phy(dword raw_value,float factor,float offset)
{
  double phy_value;
  
  phy_value=((raw_value*factor)+offset);

  return phy_value;
}

dword phy_to_raw(double phy_value,float factor,float offset)
{
  dword raw_value; 
  
  raw_value =(phy_value-offset)/factor;
  
  return raw_value;
}

on sysvar_update sysvar::DIAG_FD3::Alignment::Type
{
  switch(@this)
  {
    case 0:G_Align_RID=K_Align_RID_Sta;break;
    case 1:G_Align_RID=K_Align_RID_Dyn;break;
  }
  write("DIAG_FD3::Alignment::Type::%X",G_Align_RID);
}

on sysvar_update sysvar::DIAG_FD3::Alignment::In
{
  switch(@this)
  {
    case 0:G_Align_IN=K_Align_IN_Plant;break;
    case 1:G_Align_IN=K_Align_IN_After;break;
  }
  write("DIAG_FD3::Alignment::In::%X",G_Align_IN);
}

on sysvar_update sysvar::DIAG_FD3::Alignment::`Start
{
  if ( @this) 
  {
    //putvalue(Env_JLRSecurity_CCM,1);
    
    ALIGNFlag = 1;//ALIGNMENT_START   
    Alignment_Display_clear();
    setTimer(alignmentTimer,300);
  }
}

on sysvar_update sysvar::DIAG_FD3::Alignment::`Stop
{
  if ( @this) 
  {
    //putvalue(Env_JLRSecurity_CCM,1);
    
    ALIGNFlag = 2;//ALIGNMENT STOP
    Alignment_Display_clear();
    setTimer(alignmentTimer,300);
  }
}

on sysvar_update sysvar::DIAG_FD3::Alignment::`Status
{
  if ( @this) 
  {
     //putvalue(Env_JLRSecurity_CCM,1);

     ALIGNFlag = 3;//ALIGNMENT STATUS
     Alignment_Display_clear();
     setTimer(alignmentTimer,300);
  }
}

void Alignment_Display_clear()
{
    @sysvar::DIAG_FD3::Alignment::Trigger_Status=0;
    sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"");
}

void Alignment_start_Evaluate()
{
  word Align_RID;
  
  Align_RID=RxDataBuffer[2]<<8;
  Align_RID=RxDataBuffer[3];
 
  if((RxDataBuffer[0] == 0x71)&&(RxDataBuffer[1] == 0x01))
  {
    if(Align_RID==K_Align_RID_Sta)//Static Alignment
    {
      if((RxDataBuffer[4] == 0x01) && (RxDataBuffer[5] == 0x06))
      {
        sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Routine in progress");
        @sysvar::DIAG_FD3::Alignment::Trigger_Status=1;
      }else if((RxDataBuffer[4] == 0xFE)&&(RxDataBuffer[5] == 0xFE))
      {
        sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Alignment Aborted");
        @sysvar::DIAG_FD3::Alignment::Trigger_Status=-1;
      }
    }else if(Align_RID==K_Align_RID_Dyn)//Dynamic Alignment 
    {
      if((RxDataBuffer[4] == 0x01) && (RxDataBuffer[5] == 0x00) && (RxDataBuffer[6] == 0x01) && (RxDataBuffer[7] == 0x00))
      {
        sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Routine in progress");
        @sysvar::DIAG_FD3::Alignment::Trigger_Status=1;
      }
    }
  }
  else if((RxDataBuffer[0] == 0x7F)&&(RxDataBuffer[1] == 0x31))
      {
          switch(RxDataBuffer[2])
          {
            case 0x22:sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Initial Conditions not correct");;
                      break;
            case 0x83:
            case 0x84:sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"IF Engine running");;
                      break;
          }
        @sysvar::DIAG_FD3::Alignment::Trigger_Status=-1;
      }
}

void Alignment_stop_Evaluate()
{
  char display[100];
  char xx[50],yy[50];
  int lpl=31;//Letter/column per line
  
  word Align_RID;
  
  Align_RID=RxDataBuffer[2]<<8;
  Align_RID=RxDataBuffer[3];

  if((RxDataBuffer[0] == 0x71))
  {
    if((RxDataBuffer[1] == 0x02)&&(RxDataBuffer[2] == 0x04) && (RxDataBuffer[3] == 0xFE)&&(RxDataBuffer[4] == 0xFE))//Static Alignment
    {
      sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Alignment Aborted");
      @sysvar::DIAG_FD3::Alignment::Trigger_Status=1;
      
    }else if((RxDataBuffer[1] == 0x01)&&(Align_RID == K_Align_RID_Dyn) &&(RxDataBuffer[4] == 0xFE)&&(RxDataBuffer[6] == 0x05))//Dynamic Alignment 
        {
          if( RxDataBuffer[5]<10)
          {
                  i = snprintf(xx,elcount(xx),"Dynamic Calibration %:%d        ", RxDataBuffer[5]);
          }else if(( RxDataBuffer[5]>9)&&( RxDataBuffer[5]<99))
          {
                  i = snprintf(xx,elcount(xx),"Dynamic Calibration %:%d       ", RxDataBuffer[5]);
          }
          else if( RxDataBuffer[5]==100){
                  i = snprintf(xx,elcount(xx),"Dynamic Calibration %:%d      ", RxDataBuffer[5]);
               }
          
          strncat(display,xx,lpl); 
          
          if( RxDataBuffer[7]<=0xF)
          {
                  i = snprintf(yy,elcount(yy),"SDA Driving profile %:0x%X       ", RxDataBuffer[7]);
          }else if(( RxDataBuffer[5]>0xF)&&( RxDataBuffer[5]<=0XFF))
          {
                  i = snprintf(yy,elcount(yy),"SDA Driving profile %:0x%X       ", RxDataBuffer[7]);
          }
          
          strncat(display,yy, strlen(display)+lpl); 
          
          sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,display);
          
          @sysvar::DIAG_FD3::Alignment::Trigger_Status=1;
        }
  }
  else {
        @sysvar::DIAG_FD3::Alignment::Trigger_Status=-1;
       }
}

void Alignment_status_Evaluate()
{
  word Align_RID;
  
  char display[200];
  char aa[50],bb[50],cc[70],dd[50];
  
  int lpl=31;//Letter/column per line
  
  long i;
     
  if((RxDataBuffer[0] == 0x71)&&(RxDataBuffer[1] == 0x03))
  {
    Align_RID=RxDataBuffer[2]<<8;
    Align_RID=RxDataBuffer[3];
    
    if(Align_RID==K_Align_RID_Sta)//Static Alignment
    {
      if((RxDataBuffer[4] == 0x01)&& (RxDataBuffer[5] == 0x06))
      {
        sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Routine in progress");
         @sysvar::DIAG_FD3::Alignment::Trigger_Status=1;
      }
      if(RxDataBuffer[4] == 0x02)
      {
        switch(RxDataBuffer[6])
        {
          case 0x00:sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Status::Finished-OK           Measure in PSA Tolerences");
                    break;
          case 0x01:sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Status::Finished-OK           Measure in PSA Tolerences     But with in Bosch Tolerences");
                    break;
          case 0x02:sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Status::Finished-OK           Measure out of Bosch Tolerence");
                    break;
        }
        @sysvar::DIAG_FD3::Alignment::Trigger_Status=1;
      }
      if(RxDataBuffer[4] == 0x03)
      {
        switch(RxDataBuffer[6])
        {
          case 0x03:sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Status::Finished-NOK          Modulation Mode NOK");
                    break;
          case 0x01:sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Status::Finished-NOK          No Target Found");
                    break;
          case 0x02:sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,"Status::Finished-NOK          No Target within Threshold");
                    break;
        }
        @sysvar::DIAG_FD3::Alignment::Trigger_Status=-1;
      }
    }
    else if(Align_RID==K_Align_RID_Dyn)//Dynamic Alignment
    {
      switch(RxDataBuffer[4])
      {
        case 0x01:strncpy(aa, "Routine control in progress    ", lpl);
                  @sysvar::DIAG_FD3::Alignment::Trigger_Status=1;
                  break;
        case 0x02:strncpy(aa, "Routine control finished OK    ", lpl);
                  @sysvar::DIAG_FD3::Alignment::Trigger_Status=1;
                  break;
        case 0x03:strncpy(aa, "Routine control finished NOK   ", lpl);
                  @sysvar::DIAG_FD3::Alignment::Trigger_Status=-1;
                  break;
      }
      strncat(display,aa, lpl); 
      
      if( RxDataBuffer[5]<10)
      {
              i = snprintf(bb,elcount(bb),"Dynamic Calibration %:%d        ", RxDataBuffer[5]);
      }else if(( RxDataBuffer[5]>9)&&( RxDataBuffer[5]<99))
      {
              i = snprintf(bb,elcount(bb),"Dynamic Calibration %:%d       ", RxDataBuffer[5]);
      }
      else if( RxDataBuffer[5]==100){
              i = snprintf(bb,elcount(bb),"Dynamic Calibration %:%d      ", RxDataBuffer[5]);
           }
      
      strncat(display,bb, strlen(display)+lpl); 
      
      switch(RxDataBuffer[6])
      {
        case 0x00:strncpy(cc, "SDA not running                ", lpl);
                  break;
        case 0x01:strncpy(cc, "SDA running                    ", lpl);
                  break;
        case 0x02:strncpy(cc, "Measure in PSA tolerances      ", lpl);
                  break;
        case 0x03:strncpy(cc, "Measure in PSA Tolerences     But with in Bosch Tolerences   ", lpl*2);
                  break;
        case 0x04:strncpy(cc, "Measure out of BOSCH tolerance ", lpl);
                  break;
        case 0x05:strncpy(cc, "Aborted                        ", lpl);
                  break;
      }
      
      strncat(display,cc, strlen(display)+strlen(cc)); 

      if( RxDataBuffer[7]<=0xF)
      {
              i = snprintf(dd,elcount(dd),"SDA Driving profile %:0x%X       ", RxDataBuffer[7]);
      }else if(( RxDataBuffer[5]>0xF)&&( RxDataBuffer[5]<=0XFF))
      {
              i = snprintf(dd,elcount(dd),"SDA Driving profile %:0x%X       ", RxDataBuffer[7]);
      }
      
      strncat(display,dd, strlen(display)+lpl); 
      
      sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,display);
    }
  }else if((RxDataBuffer[0] == 0x71) && (RxDataBuffer[1] == 0x01))
        {
          if((Align_RID == K_Align_RID_Dyn) &&(RxDataBuffer[4] == 0x01)&&(RxDataBuffer[6] == 0x01))//Dynamic Alignment 
              {
                if( RxDataBuffer[5]<10)
                {
                        i = snprintf(aa,elcount(aa),"Dynamic Calibration %:%d        ", RxDataBuffer[5]);
                }else if(( RxDataBuffer[5]>9)&&( RxDataBuffer[5]<99))
                {
                        i = snprintf(aa,elcount(aa),"Dynamic Calibration %:%d       ", RxDataBuffer[5]);
                }
                else if( RxDataBuffer[5]==100){
                        i = snprintf(aa,elcount(aa),"Dynamic Calibration %:%d      ", RxDataBuffer[5]);
                     }
                
                strncat(display,aa,lpl); 
                
                if( RxDataBuffer[7]<=0xF)
                {
                        i = snprintf(bb,elcount(bb),"SDA Driving profile %:0x%X       ", RxDataBuffer[7]);
                }else if(( RxDataBuffer[5]>0xF)&&( RxDataBuffer[5]<=0XFF))
                {
                        i = snprintf(bb,elcount(bb),"SDA Driving profile %:0x%X       ", RxDataBuffer[7]);
                }
                
                strncat(display,bb, strlen(display)+lpl); 
                
                sysSetVariableString(sysvar::DIAG_FD3::Alignment::Display,display);
                
                @sysvar::DIAG_FD3::Alignment::Trigger_Status=1;
              }
        }
}

//Current Misalignment Value
void Alignment_Current_Value_clear()
{
  @sysvar::DIAG_FD3::Align_Curr_Value::Azimuth=0;
  @sysvar::DIAG_FD3::Align_Curr_Value::Elevation=0;
  @sysvar::DIAG_FD3::Align_Curr_Value::Trigger_Status=0;
}

void Alignment_Current_Value_Read_Evaluate()
{
  byte DID[2];
  word temp;
  
  DID[0]=G_Align_Curr_Val>>8;
  DID[1]=G_Align_Curr_Val;
  
  if((RxDataBuffer[0] == 0x62)&&(RxDataBuffer[1] == DID[0]) && (RxDataBuffer[2] == DID[1]))
  {
    temp=0;//Clear;
    temp=RxDataBuffer[3];
    temp=temp|(RxDataBuffer[4]<<8);
    @sysvar::DIAG_FD3::Align_Curr_Value::Azimuth=raw_to_phy(temp,0.01,-50);//raw_to_phy(raw_value,factor,offset)Factor: 0.01;Offset: -50
    
    temp=0;//Clear;
    temp=RxDataBuffer[5];
    temp=temp|(RxDataBuffer[6]<<8);
    @sysvar::DIAG_FD3::Align_Curr_Value::Elevation=raw_to_phy(temp,0.01,-50);//raw_to_phy(raw_value,factor,offset)Factor: 0.01;Offset: -50
    
    @sysvar::DIAG_FD3::Align_Curr_Value::Trigger_Status=1;
  }
  else{
          @sysvar::DIAG_FD3::Align_Curr_Value::Trigger_Status=-1;
      }
}

on sysvar sysvar::DIAG_FD3::Align_Curr_Value::Trigger
{
  if(@this)
  {
    Alignment_Current_Value_clear();
    StartDiagService(ALIGNMENT_CURR_VAL);
  }
}

//Alignment Tolerance
void Alignment_Tolerance_clear()
{
  @sysvar::DIAG_FD3::Align_Tolerance_R::Azimuth=0;
  @sysvar::DIAG_FD3::Align_Tolerance_R::Elevation=0;
  @sysvar::DIAG_FD3::Align_Tolerance_R::Trigger_Status=0;
}

void Alignment_Tolerance_Read_Evaluate()
{
  byte DID[2];
  byte x;
  
  DID[0]=G_Align_Tolerance>>8;
  DID[1]=G_Align_Tolerance;
  if((RxDataBuffer[0] == 0x62)&&(RxDataBuffer[1] == DID[0]) && (RxDataBuffer[2] == DID[1]))
  {
    x=RxDataBuffer[3];
    @sysvar::DIAG_FD3::Align_Tolerance_R::Azimuth=raw_to_phy(x,0.1,0);//raw_to_phy(raw_value,factor,offset)Factor: 0.1;Offset: 0
    
    x=RxDataBuffer[4];
    @sysvar::DIAG_FD3::Align_Tolerance_R::Elevation=raw_to_phy(x,0.1,0);//raw_to_phy(raw_value,factor,offset)Factor: 0.1;Offset: 0
    
    @sysvar::DIAG_FD3::Align_Tolerance_R::Trigger_Status=1;
  }
  else{
          @sysvar::DIAG_FD3::Align_Tolerance_R::Trigger_Status=-1;
      }
}

on sysvar sysvar::DIAG_FD3::Align_Tolerance_R::Trigger//Read
{
  if(@this)
  {
    Alignment_Tolerance_clear();
    StartDiagService(ALIGNMENT_TOL_R);
  }
}

void Alignment_Tolerance_Write()
{
  float a,b;
  TxDataBuffer[0] = 0x2E;//WDBI
	TxDataBuffer[1] = G_Align_Tolerance>>8;
	TxDataBuffer[2] = G_Align_Tolerance;
  
  //Factor : 0.1
  //Offset : 0
  a=@sysvar::DIAG_FD3::Align_Tolerance_W::Azimuth;
  TxDataBuffer[3] = phy_to_raw(a,0.1,0);//Azimuth(Y axis)
  
  b=@sysvar::DIAG_FD3::Align_Tolerance_W::Elevation;
  TxDataBuffer[4] = phy_to_raw(b,0.1,0);//Elevation(Z axis)

  TxLength = 5;
  
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
}

void Alignment_Tolerance_Write_Evaluate()
{
  byte DID[2];
  word temp;
  byte x,y,z;
  
  DID[0]=G_Align_Tolerance>>8;
  DID[1]=G_Align_Tolerance;
  if((RxDataBuffer[0] == 0x6E)&&(RxDataBuffer[1] == DID[0]) && (RxDataBuffer[2] == DID[1]))
  {
    @sysvar::DIAG_FD3::Align_Tolerance_W::Trigger_Status=1;
  }
  else{
          @sysvar::DIAG_FD3::Align_Tolerance_W::Trigger_Status=-1;
      }
}

on sysvar sysvar::DIAG_FD3::Align_Tolerance_W::Trigger//Read
{
  if(@this)
  {
    @sysvar::DIAG_FD3::Align_Tolerance_W::Trigger_Status=0;
    StartDiagService(ALIGNMENT_TOL_W);
  }
}

//Factory EOL Alignment Data
void Alignment_Data_clear()
{
  @sysvar::DIAG_FD3::Align_Data_R::FVC_FL_wheel=0;
  @sysvar::DIAG_FD3::Align_Data_R::FVC_FR_wheel=0;
  @sysvar::DIAG_FD3::Align_Data_R::FVC_RL_wheel=0;
  @sysvar::DIAG_FD3::Align_Data_R::FVC_RR_wheel=0;
  @sysvar::DIAG_FD3::Align_Data_R::Target_Dist_X=0;
  @sysvar::DIAG_FD3::Align_Data_R::Target_Type=0;
  @sysvar::DIAG_FD3::Align_Data_R::Thrust_Axis=0;
  @sysvar::DIAG_FD3::Align_Data_R::Trigger_Status=0;
}

void Alignment_Data_Read_Evaluate()
{
  byte DID[2];
  word temp;
  byte x,y,z;
  
  DID[0]=G_Align_Data>>8;
  DID[1]=G_Align_Data;
  if((RxDataBuffer[0] == 0x62)&&(RxDataBuffer[1] == DID[0]) && (RxDataBuffer[2] == DID[1]))
  {
    x=RxDataBuffer[3];
    @sysvar::DIAG_FD3::Align_Data_R::Thrust_Axis=raw_to_phy(x,0.01,0);//raw_to_phy(raw_value,factor,offset)Factor: 0.01;Offset: 0
    
    x=RxDataBuffer[4];//Target_Type+ Target_Dist_X
    x=x&0xF0;//Target_Type[7-4]
    x=x>>4;
    @sysvar::DIAG_FD3::Align_Data_R::Target_Type=x;
    
    x=RxDataBuffer[4];//Target_Type+ Target_Dist_X
    x=x&0x0F;//Target_Dist_X [0-3]
    
    temp=0;//Clear
    temp=RxDataBuffer[5];//Target_Dist_X[4-11]
    temp=temp|x<<8;
    @sysvar::DIAG_FD3::Align_Data_R::Target_Dist_X=raw_to_phy(temp,1,0);//raw_to_phy(raw_value,factor,offset)Factor: 1;Offset: 0
    
    temp=0;//Clear
    temp=RxDataBuffer[6];//FVC_FL_wheel [0-7]
    
    x=RxDataBuffer[7];//FVC_FL_wheel+FVC_FR_wheel
    x=x&0xF0;//FVC_FL_wheel[8-11]
    x=x>>4;
    temp=temp|(x<<8);
    
    @sysvar::DIAG_FD3::Align_Data_R::FVC_FL_wheel=raw_to_phy(temp,1,0);//raw_to_phy(raw_value,factor,offset)Factor: 1;Offset: 0
    
    x=RxDataBuffer[7];//FVC_FL_wheel+FVC_FR_wheel
    x=x&0x0F;//FVC_FR_wheel[0-3]
    
    temp=0;//Clear
    temp=RxDataBuffer[8]<<4;//FVC_FR_wheel[4-11]
    temp=temp|x;
    @sysvar::DIAG_FD3::Align_Data_R::FVC_FR_wheel=raw_to_phy(temp,1,0);//raw_to_phy(raw_value,factor,offset)Factor: 1;Offset: 0
    
    temp=0;//Clear
    temp=RxDataBuffer[9];//FVC_RL_wheel [0-7]
    
    x=RxDataBuffer[10];//FVC_RL_wheel+FVC_RR_wheel
    x=x&0xF0;//FVC_RL_wheel[8-11]
    x=x>>4;
    temp=temp|(x<<8);
    
    @sysvar::DIAG_FD3::Align_Data_R::FVC_RL_wheel=raw_to_phy(temp,1,0);//raw_to_phy(raw_value,factor,offset)Factor: 1;Offset: 0
    
    x=RxDataBuffer[10];//FVC_RL_wheel+FVC_RR_wheel
    x=x&0x0F;//FVC_RR_wheel[0-3]
    
    temp=0;//Clear
    temp=RxDataBuffer[11]<<4;//FVC_RR_wheel[4-11]
    temp=temp|x;
    @sysvar::DIAG_FD3::Align_Data_R::FVC_RR_wheel=raw_to_phy(temp,1,0);//raw_to_phy(raw_value,factor,offset)Factor: 1;Offset: 0
    
    @sysvar::DIAG_FD3::Align_Data_R::Trigger_Status=1;
  }
  else{
          @sysvar::DIAG_FD3::Align_Data_R::Trigger_Status=-1;
      }
}

on sysvar sysvar::DIAG_FD3::Align_Data_R::Trigger//Read
{
  if(@this)
  {
    Alignment_Data_clear();
    StartDiagService(ALIGNMENT_DATA_R);
  }
}

void Alignment_Data_Write()
{
  byte x,y,z;
  word a,b;
  TxDataBuffer[0] = 0x2E;//WDBI
	TxDataBuffer[1] = G_Align_Data>>8;
	TxDataBuffer[2] = G_Align_Data;
  
  //Factor : 0.01
  //Offset : 0
  TxDataBuffer[3] = phy_to_raw(@sysvar::DIAG_FD3::Align_Data_W::Thrust_Axis,0.01,0);//Thrust_Axis
  
  x=@sysvar::DIAG_FD3::Align_Data_W::Target_Type;
  x=x<<4;
  
  //Factor : 1
  //Offset : 0
  a=phy_to_raw(@sysvar::DIAG_FD3::Align_Data_W::Target_Dist_X,1,0);
  
  y=(a&0xF00)>>8;
  z=x|y;
  
  TxDataBuffer[4]=z;//Target_Type+Target_Dist_X
  
  y=a&0x0FF;
  TxDataBuffer[5]=y;//Target_Dist_X
  
  a=phy_to_raw(@sysvar::DIAG_FD3::Align_Data_W::FVC_FL_wheel,1,0);
  x=a;
  
  TxDataBuffer[6]=x;//FVC_FL_wheel
  
  x=(a&0xF00)>>8;
  x=x<<4;
  
  a=phy_to_raw(@sysvar::DIAG_FD3::Align_Data_W::FVC_FR_wheel,1,0);
  y=a&0xF;
  
  z=x|y;
  
  TxDataBuffer[7]=x;//FVC_FL_wheel+FVC_FR_wheel
  
  y=(a&0xFF0)>>4;
  TxDataBuffer[8]=y;//FVC_FR_wheel
  
  a=phy_to_raw(@sysvar::DIAG_FD3::Align_Data_W::FVC_RL_wheel,1,0);
  x=a;
  
  TxDataBuffer[9]=x;//FVC_RL_wheel
  
  x=(a&0xF00)>>8;
  x=x<<4;
  
  a=phy_to_raw(@sysvar::DIAG_FD3::Align_Data_W::FVC_RR_wheel,1,0);
  y=a&0xF;
  
  z=x|y;
  
  TxDataBuffer[10]=x;//FVC_RL_wheel+FVC_RR_wheel
  
  y=(a&0xFF0)>>4;
  TxDataBuffer[11]=y;//FVC_RR_wheel
  
  TxLength = 12;
  
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
}

void Alignment_Data_Write_Evaluate()
{
  byte DID[2];
  word temp;
  byte x,y,z;
  
  DID[0]=G_Align_Data>>8;
  DID[1]=G_Align_Data;
  if((RxDataBuffer[0] == 0x6E)&&(RxDataBuffer[1] == DID[0]) && (RxDataBuffer[2] == DID[1]))
  {
    @sysvar::DIAG_FD3::Align_Data_W::Trigger_Status=1;
  }
  else{
          @sysvar::DIAG_FD3::Align_Data_W::Trigger_Status=-1;
      }
}

on sysvar sysvar::DIAG_FD3::Align_Data_W::Trigger//Write
{
  if(@this)
  {
    @sysvar::DIAG_FD3::Align_Data_W::Trigger_Status=0;
    StartDiagService(ALIGNMENT_DATA_W);
  }
}

//Factory EOL Alignment Measure
void Alignment_Measure_Result_clear()
{
  @sysvar::DIAG_FD3::Align_Meas_Res::Azimuth=0;
  @sysvar::DIAG_FD3::Align_Meas_Res::Elevation=0;
  @sysvar::DIAG_FD3::Align_Meas_Res::Trigger_Status=0;
  sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::description,"");
  sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::Meas_Status,"");
}

void Alignment_Measure_Result_Evaluate()
{
  byte DID[2];
  word temp;
  DID[0]=G_Align_Meas_Res>>8;
  DID[1]=G_Align_Meas_Res;
  if((RxDataBuffer[0] == 0x62)&&(RxDataBuffer[1] == DID[0]) && (RxDataBuffer[2] == DID[1]))
  {
    //Flag EOL radar misalignment measure status
    switch(RxDataBuffer[3])
    {
      case 0x00:
                sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::Meas_Status, "Request never done, alignment routine never launched");
                break;
      case 0x01:
                sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::Meas_Status, "Request done, with results in PSA tolerance");
                break;
      case 0x02:
                sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::Meas_Status, "Request done, with results out of PSA tolerance but within Bosch tolerance");
                break;
      case 0x03:
                sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::Meas_Status, "Request done, with results out of Bosch tolerance");
                break;
      case 0x04:
                sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::Meas_Status, "Request not done or aborted");
                break; 
       default :
                sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::Meas_Status, "Invalid");
                break; 
    }
    
    temp =RxDataBuffer[4];
    temp =temp|(RxDataBuffer[5]<<8);
    
    @sysvar::DIAG_FD3::Align_Meas_Res::Azimuth=raw_to_phy(temp,0.01,-50);//raw_to_phy(raw_value,factor,offset)//Factor: 0.01; Offset: -50
    
    temp =RxDataBuffer[6];
    temp =temp|(RxDataBuffer[7]<<8);
    
    @sysvar::DIAG_FD3::Align_Meas_Res::Elevation=raw_to_phy(temp,0.01,-50);//raw_to_phy(raw_value,factor,offset)//Factor: 0.01; Offset: -50
    
    //Def Descr (Default description)
    switch(RxDataBuffer[8])
    {
      case 0x00:
                sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::description, "No specific error");
                break;
      case 0x01:
                sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::description, "Target not found ");
                break;
      case 0x03:
                sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::description, "No Target within the threshold limits");
                break;
      case 0x04:
                sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::description, "Modulation Mode Not Ok");
                break;
      case 0x05:
                sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::description, "Sensor Blind");
                break;
      case 0x06:
                sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::description, "Internal Failure");
                break;
      case 0x07:
                sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::description, "SW Timeout");
                break;
      case 0xFF:
                sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::description, "Routine not launched");
                break;
       default :
                sysSetVariableString(sysvar::DIAG_FD3::Align_Meas_Res::description, "Invalid");
                break; 
    }
    @sysvar::DIAG_FD3::Align_Meas_Res::Trigger_Status=1;
  }
  else{
          @sysvar::DIAG_FD3::Align_Meas_Res::Trigger_Status=-1;
      }
}

on sysvar sysvar::DIAG_FD3::Align_Meas_Res::Trigger//Read
{
  if(@this)
  {
    Alignment_Measure_Result_clear();
    StartDiagService(ALIGNMENT_MEAR_RES);
  }
}

on sysVar sysvar::DIAG_FD3::GeneralSettings::sysECUvariant
{
  switch(@this) {
    case 2://RadarFR:
           @sysvar::DIAG_FD3::GeneralSettings::sysTxIdentifier=K_TxId_RadarFR;
           @sysvar::DIAG_FD3::GeneralSettings::sysRxIdentifier=K_RxId_RadarFR;
           G_ITC_Mask_lng=K_ITC_CR_Mask_lng;
           break;
}
  write("DIAG_FD3::BOSCH_CODING::Length::%d",G_ITC_Mask_lng);
}

on sysvar_update sysvar::DIAG_FD3::BOSCH_CODING::Write
{
  if(@this)
  {
    @sysvar::DIAG_FD3::BOSCH_CODING::Trigger_Status=0;
    StartDiagService( WRITE_BOSCH_CODING );
  }
}

on sysvar_update sysvar::DIAG_FD3::BOSCH_CODING::Read
{
  if(@this)
  {
    @sysvar::DIAG_FD3::BOSCH_CODING::Trigger_Status=0;
    StartDiagService( READ_BOSCH_CODING );
  }
}

on sysvar_update sysvar::DIAG_FD3::BOSCH_CODING::reset
{
  int i;
  if(@this)
  {
    for(i=0;i<20;i++)
    {
      @sysvarMember::DIAG_FD3::BOSCH_CODING::ITC_NO[i]=-1;//Reset
    }
  }
}

void bosch_coding_Write()
{
	  int i;
    int64 Maskbit;
    int byte_index;
    int bit_index;
    int powerof2;//Power of 2
  
    byte  ITC_Mask_data[K_ITC_FR_Mask_lng];
  
    TxDataBuffer[0] = 0x2E;
	  TxDataBuffer[1] = K_ITC_DiD>>8;
	  TxDataBuffer[2] = K_ITC_DiD;
 
    for(i=0;i<G_ITC_Mask_lng;i++)
    {
      ITC_Mask_data[i]=0;//Clear
    }
    
    for(i=0;i<20;i++)
    {
      Maskbit=@sysvarMember::DIAG_FD3::BOSCH_CODING::ITC_NO[i];
      byte_index=Maskbit/8;
      bit_index=Maskbit%8;
      powerof2=_pow(2.0, bit_index);
      ITC_Mask_data[byte_index]=ITC_Mask_data[byte_index]|powerof2;
    }
    
    for(i=0;i<G_ITC_Mask_lng;i++)
    {
      TxDataBuffer[3+i]=ITC_Mask_data[i];//copy to tx
    }
    
    TxLength = 3 + G_ITC_Mask_lng;
          		if(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant == 2)
				{
				TransmitTxBuffer();
				}
}

void Bosch_coding_Write_Evaluate()
{
  word ITC_DID;
  
  ITC_DID=RxDataBuffer[1]<<8;
  ITC_DID=ITC_DID|RxDataBuffer[2];
  //write("RxDataBuffer[0]:%X,RxDataBuffer[1]:%X,RxDataBuffer[2]:%X,ITC_DID:%X",RxDataBuffer[0],RxDataBuffer[1],RxDataBuffer[2],ITC_DID);
  if((RxDataBuffer[0] == 0x6E)&&(ITC_DID == K_ITC_DiD))//2E+40=6E
  {
    @sysvar::DIAG_FD3::BOSCH_CODING::Trigger_Status=1;
  }
  else if(RxDataBuffer[0] == 0x7F)
      {
        @sysvar::DIAG_FD3::BOSCH_CODING::Trigger_Status=-1;
      }
}

void Bosch_coding_Read_Evaluate()
{
	int64 i,k;
  byte mask = 1; // Bit mask
  byte temp= 00;// Read from file
  
  word  ITC_Mask_index[K_ITC_FR_Mask_lng*8];
  word  ITC_DID;
  
  ITC_DID=RxDataBuffer[1]<<8;
  ITC_DID=ITC_DID|RxDataBuffer[2];
  
  //write("RxDataBuffer[0]:%X,RxDataBuffer[1]:%X,RxDataBuffer[2]:%X,ITC_DID:%X",RxDataBuffer[0],RxDataBuffer[1],RxDataBuffer[2],ITC_DID);
 
  if((RxDataBuffer[0] == 0x62)&&(ITC_DID == K_ITC_DiD))//22+40=62
  {
    if(@sysvar::DIAG_FD3::BOSCH_CODING::Read_Check!=1)
    {
      for(i=0;i<20;i++)
      {
        @sysvarMember::DIAG_FD3::BOSCH_CODING::ITC_NO[i]=-1;//Reset
      }
      
      for(i=0;i<K_ITC_FR_Mask_lng*8;i++)
      {
        ITC_Mask_index[i]=-1;//Reset
      }
      
      k=0;
      
      for(i=0;i<G_ITC_Mask_lng;i++)
      {
        temp=RxDataBuffer[3+i];
        for ( j= 0; j < 8; j++) 
        {
          if((temp >> j) & mask)
          {
            ITC_Mask_index[k]=(i*8)+j;
            k++;
          }  
        }
      }
    
      for ( i = 0; (i < k)&&(i < 20); i++) 
      {
        @sysvarMember::DIAG_FD3::BOSCH_CODING::ITC_NO[i]=ITC_Mask_index[i];
      }
    }

    @sysvar::DIAG_FD3::BOSCH_CODING::Trigger_Status=1;
  
  }else if(RxDataBuffer[0] == 0x7F)
        {
          @sysvar::DIAG_FD3::BOSCH_CODING::Trigger_Status=-1;
        }
}

on sysvar_update sysvar::DIAG_FD3::ITC::Read
{
   if ( @this) 
   {
        sysSetVariableString(sysvar::DIAG_FD3::ITC::Display,"");
        setTimer(ITCTimer_Read,1);      
    }
}

on sysvar_update sysvar::DIAG_FD3::ITC::Clear
{
   if ( @this) 
   {
        sysSetVariableString(sysvar::DIAG_FD3::ITC::Display,"");
        StartDiagService( ITC_CLEAR );
        setTimer(ITCTimer_Read,300);
    }
}

on timer ITCTimer_Read
{
  StartDiagService( ITC_READ );
}

void parseITCData(byte ITCList[],int Length)
{
  
  int ITCCount;
  int i,byteCount;
  char output[816];
  int temp;
  //cha
  
  ITCCount = (Length-3)/19;
  byteCount = 3;
  
  strncpy(output,"STATUS               Occ  VehSpd Volt   Temp EVID  AGE    Unique_ID --------------------------------------------------------------------",elcount(output));
  
  for(i=0;i<ITCCount;i++)
  {
   
    statusParser(ITCList[byteCount+1]);
    strncat(output,gstatusITC,elcount(output));
    convertAndSave(ITCList[byteCount+2],output,1);
    
    temp = (ITCList[byteCount+3] << 8) + ITCList[byteCount+4];
    convertAndSave(temp,output,4);
    
   // write("*****************%d %d %d",(ITCList[byteCount+5] << 8),ITCList[byteCount+6],temp);
    
    temp = (ITCList[byteCount+5] << 8) + ITCList[byteCount+6];
    //write("*****************%d %d %d",(ITCList[byteCount+5] << 8),ITCList[byteCount+6],temp);
    convertAndSave(temp,output,2);
    
    temp = (ITCList[byteCount+7] << 8) + ITCList[byteCount+8];
    convertAndSave(temp,output,3);
    
    temp = (ITCList[byteCount+9] << 8) + ITCList[byteCount+10];
    convertAndSave(temp,output,0);
    
    convertAndSave(ITCList[byteCount+11],output,99);
    convertAndSave(ITCList[byteCount+12],output,99);
    convertAndSave(ITCList[byteCount+13],output,99);
    convertAndSave(ITCList[byteCount+14],output,99);
    strncat(output," ",elcount(output));
    convertAndSave(ITCList[byteCount+15],output,99);
    convertAndSave(ITCList[byteCount+16],output,99);
    convertAndSave(ITCList[byteCount+17],output,99);
    convertAndSave(ITCList[byteCount+18],output,99);
    
    if(strlen(output)%68 != 0)
    {
      for(i = 0;i<(strlen(output)%68);i++)
      {
        strncat(output," ",elcount(output));
      }
    }
    byteCount+=19;
  
  }
  strncat(output,"\0",elcount(output));
  sysSetVariableString(sysvar::DIAG_FD3::ITC::Display,output);  
}

void convertAndSave(dword input,char output[],int unit)
{
  char temp[7];
  
  if(unit == 0)
  {
    ltoa(input,temp,10);
    strncat(output,temp,elcount(output));
    strncat(output," ",elcount(output));
  }
  else if(unit == 1)
  {
    ltoa(input,temp,10);
    strncat(output,temp,elcount(output));
    strncat(output,"(Occ) ",elcount(output));
  }
  else if(unit == 2)
  {
    ltoa(input,temp,10);
    strncat(output,temp,elcount(output));
    strncat(output,"mV ",elcount(output));
  }
  else if(unit == 3)
  {
    ltoa(input/10,temp,10);
    strncat(output,temp,elcount(output));
    strncat(output,"`C ",elcount(output));
  }
  else if(unit == 4)
  {
    ltoa(input,temp,10);
    strncat(output,temp,elcount(output));
    strncat(output,"m/s ",elcount(output));
  }
  else if(unit == 99)
  {
    ltoa(input,temp,16);
    if(strlen(temp) == 1)
    {
      strncat(output,"0",elcount(output));
      strncat(output,temp,elcount(output));
    } 
    else
    {
      strncat(output,temp,elcount(output));
    }
  }
  else
  {
      write("Error");
  }
}

void statusParser(byte status)
{
  strncpy(gstatusITC,"",22);
  if(status == 0x11)
  {
    strncpy(gstatusITC,"FAILED_FIRST        ",22);
  }
  else if(status == 0x32)
  {
    strncpy(gstatusITC,"HEALED_AFTER_FAILED ",22);
  }
  else if(status == 0x31)
  {
    strncpy(gstatusITC,"FAILED_AFTER_HEALED ",22);
  }
  else
  {
    strncpy(gstatusITC,"NO_ITC              ",22);
  }
}

//PSA Security Access
on sysvar_update sysvar::DIAG_FD3::PSA_SecAcc::Seed
{
  if(@this)
  {
    @sysvar::DIAG_FD3::PSA_SecAcc::Trigger_Status=0;
    sysSetVariableString(sysvar::DIAG_FD3::PSA_SecAcc::Display,"");
    StartDiagService( SEEDNKEYPSAREQUEST );
  }
}

void PSA_seed_req_Evaluate()
{
  if((RxDataBuffer[0] == 0x67)&&(RxDataBuffer[1] == 0x03))
  {
    switch(@sysvar::DIAG_FD3::GeneralSettings::sysECUvariant) 
    {
        case 0://RadarFC
               Get_PSA_Seed_Key(APPLICATIONKEY_FRONT);
               break;
        case 1://RadarFL:
        case 2://RadarFR:
        case 3://RadarRL:
        case 4://RadarRR:
               Get_PSA_Seed_Key(APPLICATIONKEY_CORNER);
               break;
      }
  @sysvar::DIAG_FD3::PSA_SecAcc::Trigger_Status=1;   
  }else{
          @sysvar::DIAG_FD3::PSA_SecAcc::Trigger_Status=-1;
      }
}

void Get_PSA_Seed_Key(word Variant_KEY)
{      
  int i;
  dword  l_SeedDataArray_ub[10];
  dword  l_SeedtempStore[4];
  
  dword l_SeedRot_ul; //For to store value after Seed reverse
  word  l_SeedMSBStore_ui,l_SeedLSBStore_ui ;
  word  l_Seedbytestr_1_ub,l_Seedbytestr_2_ub,l_Seedbytestr_3_ub,l_Seedbytestr_4_ub;

  word  l_KeyStore_MSB_ul,l_KeyStore_LSB_ul;
  dword l_KeyfinalResult_ul;


   for(i=0;i<8;i++)
   {
     l_SeedDataArray_ub[i] = RxDataBuffer[i];//Storing response bytes   
   } 
   
   //Func_DeleteRequestAndResponseObjects();
   g_seed_value_psa[0] = l_SeedDataArray_ub[2];//Storing Seed value into Global buffer
   g_seed_value_psa[1] = l_SeedDataArray_ub[3];//Storing Seed value into Global buffer
   g_seed_value_psa[2] = l_SeedDataArray_ub[4];//Storing Seed value into Global buffer
   g_seed_value_psa[3] = l_SeedDataArray_ub[5];//Storing Seed value into Global buffer
  
   sysSetVariableData(sysvar::DIAG_FD3::PSA_SecAcc::Seed_value,g_seed_value_psa,elCount(g_seed_value_psa));

   l_SeedtempStore[0] = g_seed_value_psa[0]; //Storing Seed value into temp buffer
   l_SeedtempStore[1] = g_seed_value_psa[1]; //Storing Seed value into temp buffer
   l_SeedtempStore[2] = g_seed_value_psa[2]; //Storing Seed value into temp buffer
   l_SeedtempStore[3] = g_seed_value_psa[3]; //Storing Seed value into temp buffer


   if( !((l_SeedDataArray_ub[2] == 0x00) && (l_SeedDataArray_ub[3] == 0x00) && (l_SeedDataArray_ub[4] == 0x00) && (l_SeedDataArray_ub[5] == 0x00)))
   {

    /* Arranging Seed into varaible from stored local temp buffer */
    l_SeedRot_ul = (((dword)(l_SeedtempStore[0]) << 24) +((dword)(l_SeedtempStore[1]) << 16) + ((dword)(l_SeedtempStore[2]) << 8) +((dword)(l_SeedtempStore[3]) << 0));

    /*Copy seed as MSB and LSB into local variables*/
    l_SeedMSBStore_ui = ((dword)(l_SeedRot_ul & 0xFFFF0000)>>16);
    l_SeedLSBStore_ui = ((dword)(l_SeedRot_ul & 0x0000FFFF)>>0);

    /*Copy seed into bytes */
    l_Seedbytestr_1_ub = ((word)(l_SeedMSBStore_ui & 0xFF00) >> 8);
    l_Seedbytestr_2_ub = ((word)(l_SeedMSBStore_ui & 0x00FF) >> 0);
    l_Seedbytestr_3_ub = ((word)(l_SeedLSBStore_ui & 0xFF00) >> 8);
    l_Seedbytestr_4_ub = ((word)(l_SeedLSBStore_ui & 0x00FF) >> 0);      

    /*Copy seed into two variables by adding (4 & 1<<8) and (3 + 2<<8)*/
    l_SeedMSBStore_ui = (l_Seedbytestr_4_ub +((word)(l_Seedbytestr_1_ub << 8)));
    l_SeedLSBStore_ui = (l_Seedbytestr_3_ub + ((word)(l_Seedbytestr_2_ub << 8)));


    /* Key calculation with predefind APPL Key*/
     
     l_KeyStore_MSB_ul = Func_Calculatekey(Variant_KEY, l_SeedMSBStore_ui);
    
    /* Key calculation with Seed LSB and calculted result with APPL key */ 
     l_KeyStore_LSB_ul = Func_Calculatekey(l_SeedLSBStore_ui, l_KeyStore_MSB_ul);
     
     
     l_KeyfinalResult_ul = ((dword)((l_KeyStore_MSB_ul << 16))+((dword)(l_KeyStore_LSB_ul << 0))); // Storing Key with Adding result bytes MSB | LSB
     
     
     g_key_value_psa[0] = ((byte) ((l_KeyfinalResult_ul) >> 24)) ; // Storing Calculated Key into global buffer g_key_value_psa
     g_key_value_psa[1] = ((byte) ((l_KeyfinalResult_ul >> 16))) ; // Storing Calculated Key into global buffer g_key_value_psa
     g_key_value_psa[2] = ((byte) ((l_KeyfinalResult_ul >> 8))) ;  // Storing Calculated Key into global buffer g_key_value_psa
     g_key_value_psa[3] = ((byte) l_KeyfinalResult_ul);            // Storing Calculated Key into global buffer g_key_value_psa
     
    
     sysSetVariableData(sysvar::DIAG_FD3::PSA_SecAcc::Key_value,g_key_value_psa,elCount(g_key_value_psa));
    }
    else
    {
        /* Security access is already enabled */
        sysSetVariableString(sysvar::DIAG_FD3::PSA_SecAcc::Display,"Security Already Enabled");
     }
}

word Func_Calculatekey(word Var_MSB_ui,word Var_LSB_ui)
{
  int t_key1 , t_key2, t_Key_MSB, t_Key_LSB;
  int l_Counter;
  int l_temp_LSB, l_temp_MSB ;
  word l_keyResult_ui;
  
  l_temp_LSB = (int) Var_MSB_ui ;
  l_temp_MSB = (int) Var_LSB_ui;

  t_key1 = t_key2 = 0;
  t_Key_MSB = t_Key_LSB = 0;
  
  l_Counter = (int) l_temp_LSB ;

  if (l_temp_LSB>=0)
  {
    do
    {
      l_Counter = l_Counter - 178;
      t_key2++;
    } while(l_Counter > 178);
  }
  else
  {
    do
    {
      l_Counter = l_Counter + 178;
      t_key2--;
    } while(l_Counter < -178);
  }

  t_key1  = l_temp_LSB - (t_key2 * 178);
  t_Key_MSB = (-63 * t_key2)+ (t_key1 * 170);

   if ( t_Key_MSB < 0 )
  {
    t_Key_MSB = t_Key_MSB +30323;  
  }
  
  t_key2 =  0;
  l_Counter = (int) l_temp_MSB;
  if (l_temp_MSB >= 0)
  {
   do
    {
      l_Counter = l_Counter - 177;
      t_key2++;
    } while(l_Counter > 177);
  }
  else
  {
    do
    {
      l_Counter = l_Counter + 177;
      t_key2--;
    } while(l_Counter < -177);
  }


  t_key1 = l_temp_MSB - (t_key2 * 177) ;
  t_Key_LSB= (-t_key2 -t_key2) +(t_key1 * 171) ;

  if ( t_Key_LSB < 0 )
  {
    t_Key_LSB = t_Key_LSB + 30269;
  } 

  l_keyResult_ui =  (word)(t_Key_LSB)|(word)(t_Key_MSB) ;
  
  write("Final key %x \n", l_keyResult_ui);
  return l_keyResult_ui;
}

on sysvar_update sysvar::DIAG_FD3::PSA_SecAcc::`Key
{
  if(@this)
  {
    @sysvar::DIAG_FD3::PSA_SecAcc::Trigger_Status=0;
    sysSetVariableString(sysvar::DIAG_FD3::PSA_SecAcc::Display,"");
    StartDiagService( SEEDNKEYPSARESP );
  }
}

void PSA_key_req_Evaluate()
{
  if((RxDataBuffer[0] == 0x67)&&(RxDataBuffer[1] == 0x04))
  {
    sysSetVariableString(sysvar::DIAG_FD3::PSA_SecAcc::Display,"Security::Enabled");
    @sysvar::DIAG_FD3::PSA_SecAcc::Trigger_Status=1;   
  }else{
          @sysvar::DIAG_FD3::PSA_SecAcc::Trigger_Status=-1;
          sysSetVariableString(sysvar::DIAG_FD3::PSA_SecAcc::Display,"Security::Disabled::Error");
          
      }
}

//Bosch Security Access
on sysvar_update sysvar::DIAG_FD3::Bosch_SecAcc::Seed
{
  if(@this)
  {
    @sysvar::DIAG_FD3::Bosch_SecAcc::Trigger_Status=0;
    sysSetVariableString(sysvar::DIAG_FD3::Bosch_SecAcc::Display,"");
    StartDiagService( SEEDNKEYBOSCHREQUEST );
  }
}

void Bosch_seed_req_Evaluate()
{
  if((RxDataBuffer[0] == 0x67)&&(RxDataBuffer[1] == 0x61))
  {
    calculate_key_Bosch();
    @sysvar::DIAG_FD3::Bosch_SecAcc::Trigger_Status=1;   
  }else{
          @sysvar::DIAG_FD3::Bosch_SecAcc::Trigger_Status=-1;
      }
}

on sysvar_update sysvar::DIAG_FD3::Bosch_SecAcc::`Key
{
  if(@this)
  {
    @sysvar::DIAG_FD3::Bosch_SecAcc::Trigger_Status=0;
    sysSetVariableString(sysvar::DIAG_FD3::Bosch_SecAcc::Display,"");
    StartDiagService( SEEDNKEYBOSCHRESP );
  }
}

void Bosch_key_req_Evaluate()
{
  if((RxDataBuffer[0] == 0x67)&&(RxDataBuffer[1] == 0x62))
  {
    sysSetVariableString(sysvar::DIAG_FD3::Bosch_SecAcc::Display,"Security::Enabled");
    @sysvar::DIAG_FD3::Bosch_SecAcc::Trigger_Status=1;   
  }else{
          @sysvar::DIAG_FD3::Bosch_SecAcc::Trigger_Status=-1;
          sysSetVariableString(sysvar::DIAG_FD3::Bosch_SecAcc::Display,"Security::Disabled::Error");
          
      }
}

calculate_key_Bosch()  // Calculate key.
{
  dword  temp1,temp2;
  dword  position;
  temp1=temp2=0;
  for(position = 0; position < 6; position++)
  {
     g_seed_value_bosch[position] = RxDataBuffer[position + 2];
  }
  sysSetVariableData(sysvar::DIAG_FD3::Bosch_SecAcc::Seed_value,g_seed_value_bosch,elCount(g_seed_value_bosch));
  
  Write("Seed: %02x %02x %02x %02x %02x %02x.", g_seed_value_bosch[0], g_seed_value_bosch[1], g_seed_value_bosch[2], g_seed_value_bosch[3], g_seed_value_bosch[4], g_seed_value_bosch[5]);
  if (
       (0x00 == g_seed_value_bosch[0])
       &&
       (0x00 == g_seed_value_bosch[1])
       &&
       (0x00 == g_seed_value_bosch[2])
       &&
       (0x00 == g_seed_value_bosch[3])
       &&
       (0x00 == g_seed_value_bosch[4])
       &&
       (0x00 == g_seed_value_bosch[5])
   )
   {
     Write("Security access level 31 is already unlocked.");
     sysSetVariableString(sysvar::DIAG_FD3::Bosch_SecAcc::Display,"Security Already Enabled");
   }
   else
   {

  //swap g_seed_value_bosch[0] <-->g_seed_value_bosch[5]
  temp1 = g_seed_value_bosch[0];
  g_seed_value_bosch[0] = g_seed_value_bosch[5];
  g_seed_value_bosch[5] = temp1;
  
  //swap g_seed_value_bosch[1] <-->g_seed_value_bosch[4]
  temp1 = g_seed_value_bosch[1];
  g_seed_value_bosch[1] = g_seed_value_bosch[4];
  g_seed_value_bosch[4] = temp1;
  
  //swap g_seed_value_bosch[2] <-->g_seed_value_bosch[3]
  temp1 = g_seed_value_bosch[2];
  g_seed_value_bosch[2] = g_seed_value_bosch[3];
  g_seed_value_bosch[3] = temp1;

  temp1 = ((g_seed_value_bosch[0] << 8) | g_seed_value_bosch[1]);
  temp2 = ((g_seed_value_bosch[2] << 24) | (g_seed_value_bosch[3] << 16) |(g_seed_value_bosch[4] << 8) | (g_seed_value_bosch[5])) ;

  temp2 = ((temp2 >> 1) | ((temp1 & 0x1) << 31));
  temp1 = (temp1 >> 1);
  
  // Fill in the key.
  g_key_value_bosch[0] = (temp1 >> 8) & 0xFF;
  g_key_value_bosch[1] = (temp1  & 0xFF);
  g_key_value_bosch[2] = (temp2 >> 24) & 0xFF;
  g_key_value_bosch[3] = (temp2 >> 16) & 0xFF;
  g_key_value_bosch[4] = (temp2 >> 8) & 0xFF;
  g_key_value_bosch[5] = (temp2 & 0xFF);

  sysSetVariableData(sysvar::DIAG_FD3::Bosch_SecAcc::Key_value,g_key_value_bosch,elCount(g_key_value_bosch));
  }  
}

/*

on sysvar_update sysvar::DIAG_FD3::Bosch_SecAcc::Req
{
   if (@this)
    {
      StartDiagService( RB_SEC_MODE );
      setTimer(BoschUnlockTimer,100);
    }
}

On timer BoschUnlockTimer
{
  StartDiagService( SEEDNKEYBOSCHREQUEST );
}

void calculate_key_Bosch()
{
//Start Key Calculation
dword hexnumber,k1,k2,k3,k3_key;
hexnumber =0;
k3_key=0;
hexnumber =  (hexnumber | (Seed_buf_Bosch[0] & 0x000000FF)<<24);    // diagns_respbyte3 must remain constant //
hexnumber =  (hexnumber | (Seed_buf_Bosch[1] & 0x000000FF)<<16);    // diagns_respbyte4 must remain constant //
hexnumber =  (hexnumber | (Seed_buf_Bosch[2] & 0x000000FF)<<8);    // diagns_respbyte5 must remain constant //
hexnumber =  (hexnumber | (Seed_buf_Bosch[3] & 0x000000FF)<<0);    // diagns_respbyte6 must remain constant //
k1 = 0xB21ACD23;//Bosch-Project
k2 = k1 ^ hexnumber;
k3_key|= ((k2 & 0x000000FF)<<16);
k3_key|= ((k2 & 0x0000FF00)>>8);
k3_key|= ((k2 & 0x00FF0000)<<8);
k3_key|= ((k2 & 0xFF000000)>>16);
  TxDataBuffer[0] = 0x27;
  TxDataBuffer[1] = 0x62;
  TxDataBuffer[5]=((k3_key & 0x000000FF)>>0);
  TxDataBuffer[4]=((k3_key & 0x0000FF00)>>8);
  TxDataBuffer[3]=((k3_key & 0x00FF0000)>>16);
  TxDataBuffer[2]=((k3_key & 0xFF000000)>>24);
//End Key Calculation
}//endkey
*/

on sysvar_update sysvar::DIAG_FD3::sysDataToTransmit_String
{
	dword i,length;
  dword 	SendBufferSize;
  char	MVbuffer[130000] = "";
  char	MVbuffer2[130000] = "0x"; 
  byte 	TransmitBuffer[65000];

  sysGetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_String, MVbuffer, elcount(MVbuffer));
  SendBufferSize = strlen(MVbuffer)+1;

  if( !strncmp(MVbuffer,"Idle",strlen(MVbuffer)) )
		{
			@sysvar::DIAG_FD3::GeneralSettings::sysSendData=0;
		}
	else
		{
      strncpy(MVbuffer2, "0x",3);
			for(i=0; i<= SendBufferSize-3; i+=2)
				{
					MVbuffer2[2] = MVbuffer[i];
					MVbuffer2[3] = MVbuffer[i+1];
					MVbuffer2[4] = 0;
					TransmitBuffer[i/2] = atol( MVbuffer2 );
				}
			length = (SendBufferSize - 1)/2;
      sysSetVariableData(sysvar::DIAG_FD3::sysDataToTransmit,TransmitBuffer,length);
        
      sysSetVariableString(sysvar::DIAG_FD3::sysDataToTransmit_String,"Idle");
		}
}