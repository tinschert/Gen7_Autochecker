/*@!Encoding:1252*/

/*******************************************************************************
	MODULEFILE_DESCRIPTION:stbm over CAN
	COPYRIGHT:
	Robert Bosch GmbH reserves all rights even in the event of industrial
	property. We reserve all rights of disposal such as copying and passing
	on to third parties.
	COPYRIGHT_END:

	PROJECT:		  Implements STBM functionality as a Master Node
	FILENAME:		  stbm_over_can.cin

	DESCRIPTION:		  CAPL-Program for STBM master over CAN simulation.

	HISTORY:
        Version1: 14.02.2019 ; DUE1KOR ; Initial Version 
        Version2: 16.09.2022 ; HKR3KOR + DUE1KOR 
        Version2: 11.10.2022 ; HKR3KOR 
        Version2: 10.02.2023 ; UDAB1KOR 

*****************************************************************************/
includes
{
  #include "GlobalTimeObserver_CAN.cin"
  //#include "..\\CAPL\\GPIO_Dout.cin"
}

variables{
  const FALSE	=	0;
  const TRUE 	= 	!FALSE;
  
  pdu TimeSync Msg_TimeSync;
  mstimer GTBTimer_Sync;
  mstimer GTBTimer_Fup;
  //msTimer GPIO_Timer;
  msTimer Temp_buffer_Time_ms;
  
  dword timestamp;
  dword timestamp_nanosecond_portion;
  dword T_diff;
  dword time_raw_ns;
  dword total_nanosecond;
  dword Overflow_to_second;
  dword nanosecond_FUP;
  dword time_raw_10us_precision;
  dword nanosecond_rollover = 1000000000;
  
  int64 Temp_buffer_Time_cnt;
  

  int Sync_Cnt = 0;
  int FUP_Cnt = 0;
  int cnt=0;
  int cycle_time = 0;
  int Sync_transmitted = 0;
  
  int temp=0;
  int count=0;
  int GPIO_count;
  
  byte CRC_INITIAL_VALUE8H2F = 0xFF;
  byte CRC_XOR_VALUE8H2F = 0xFF;
  byte crc_buffer_index = 0;
  byte crc_buffer[7] = {0,0,0,0,0,0,0};
  
  //Reference
  //Doors:https://rb-alm-13-p-dwa.de.bosch.com:8443/dwa/rm/urn:rational::1-4147106800294823-O-1224-00186f2c?doors.view=00000006
  //Docupedia::https://inside-docupedia.bosch.com/confluence/display/CCD/Time+Synchronization#TimeSynchronization-ECUconfiguration
  
  byte DataIDList_Sync[16]={10, 90, 149, 154, 192, 228, 12, 92, 225, 93, 230, 6, 173, 5, 236, 55}; //Sync Data-IDs
  byte DataIDList_Fup[16] ={74, 205, 180, 22, 232, 113, 36, 223, 153, 248, 90, 13, 89, 243, 139, 59}; //Follow-up Data-IDs
    
  //Data table for CRC calculation, copy from generated code of BCT tool
  byte  CRC_8_H2F_Tbl[256] =
  {
        /*    0: */    0x0,     0x2f,    0x5e,    0x71,    0xbc,    0x93,    0xe2,    0xcd,
        /*    8: */    0x57,    0x78,    0x9,     0x26,    0xeb,    0xc4,    0xb5,    0x9a,
        /*   16: */    0xae,    0x81,    0xf0,    0xdf,    0x12,    0x3d,    0x4c,    0x63,
        /*   24: */    0xf9,    0xd6,    0xa7,    0x88,    0x45,    0x6a,    0x1b,    0x34,
        /*   32: */    0x73,    0x5c,    0x2d,    0x2,     0xcf,    0xe0,    0x91,    0xbe,
        /*   40: */    0x24,    0xb,     0x7a,    0x55,    0x98,    0xb7,    0xc6,    0xe9,
        /*   48: */    0xdd,    0xf2,    0x83,    0xac,    0x61,    0x4e,    0x3f,    0x10,
        /*   56: */    0x8a,    0xa5,    0xd4,    0xfb,    0x36,    0x19,    0x68,    0x47,
        /*   64: */    0xe6,    0xc9,    0xb8,    0x97,    0x5a,    0x75,    0x4,     0x2b,
        /*   72: */    0xb1,    0x9e,    0xef,    0xc0,    0xd,     0x22,    0x53,    0x7c,
        /*   80: */    0x48,    0x67,    0x16,    0x39,    0xf4,    0xdb,    0xaa,    0x85,
        /*   88: */    0x1f,    0x30,    0x41,    0x6e,    0xa3,    0x8c,    0xfd,    0xd2,
        /*   96: */    0x95,    0xba,    0xcb,    0xe4,    0x29,    0x6,     0x77,    0x58,
        /*  104: */    0xc2,    0xed,    0x9c,    0xb3,    0x7e,    0x51,    0x20,    0xf,
        /*  112: */    0x3b,    0x14,    0x65,    0x4a,    0x87,    0xa8,    0xd9,    0xf6,
        /*  120: */    0x6c,    0x43,    0x32,    0x1d,    0xd0,    0xff,    0x8e,    0xa1,
        /*  128: */    0xe3,    0xcc,    0xbd,    0x92,    0x5f,    0x70,    0x1,     0x2e,
        /*  136: */    0xb4,    0x9b,    0xea,    0xc5,    0x8,     0x27,    0x56,    0x79,
        /*  144: */    0x4d,    0x62,    0x13,    0x3c,    0xf1,    0xde,    0xaf,    0x80,
        /*  152: */    0x1a,    0x35,    0x44,    0x6b,    0xa6,    0x89,    0xf8,    0xd7,
        /*  160: */    0x90,    0xbf,    0xce,    0xe1,    0x2c,    0x3,     0x72,    0x5d,
        /*  168: */    0xc7,    0xe8,    0x99,    0xb6,    0x7b,    0x54,    0x25,    0xa,
        /*  176: */    0x3e,    0x11,    0x60,    0x4f,    0x82,    0xad,    0xdc,    0xf3,
        /*  184: */    0x69,    0x46,    0x37,    0x18,    0xd5,    0xfa,    0x8b,    0xa4,
        /*  192: */    0x5,     0x2a,    0x5b,    0x74,    0xb9,    0x96,    0xe7,    0xc8,
        /*  200: */    0x52,    0x7d,    0xc,     0x23,    0xee,    0xc1,    0xb0,    0x9f,
        /*  208: */    0xab,    0x84,    0xf5,    0xda,    0x17,    0x38,    0x49,    0x66,
        /*  216: */    0xfc,    0xd3,    0xa2,    0x8d,    0x40,    0x6f,    0x1e,    0x31,
        /*  224: */    0x76,    0x59,    0x28,    0x7,     0xca,    0xe5,    0x94,    0xbb,
        /*  232: */    0x21,    0xe,     0x7f,    0x50,    0x9d,    0xb2,    0xc3,    0xec,
        /*  240: */    0xd8,    0xf7,    0x86,    0xa9,    0x64,    0x4b,    0x3a,    0x15,
        /*  248: */    0x8f,    0xa0,    0xd1,    0xfe,    0x33,    0x1c,    0x6d,    0x42
  };
}

on sysvar_update hil_ctrl::adas_sim
{
  if (@hil_ctrl::adas_sim == 1)
  {
    @STBM::STBM_Over_CAN.Sync_Trigger=1;
    @STBM::STBM_Over_CAN.FUP_Trigger=1;
  }
}


on sysvar STBM::STBM_Over_CAN.Sync_Trigger
{
  if(@this)
  {
    setTimer(GTBTimer_Sync,0);
  }else{
          canceltimer(GTBTimer_Sync);
          canceltimer(GTBTimer_Fup);
          //cancelTimer(GPIO_Timer);
          @STBM::STBM_Over_CAN.FUP_Trigger=0;
          //@STBM::GPIO.GPIO_Trigger=0;
        }
}

 
on sysvar STBM::STBM_Over_CAN.FUP_Trigger{
  temp=0;
  if(@STBM::STBM_Over_CAN.FUP_Trigger==0)
  {
    canceltimer(GTBTimer_Fup);
  }
}

byte PROJ_CRC_Cal(byte Crc_DataPtr[], int Crc_Length, int Crc_StartValue8, int Crc_IsFirstCall)//function of calculate the CRC
{
    byte  index;
    byte  crcTemp;
    byte  result;


    if (Crc_IsFirstCall != FALSE)
    {
    	  crcTemp = (CRC_INITIAL_VALUE8H2F);
    }
    else
    {
  	    crcTemp = (Crc_StartValue8^(CRC_XOR_VALUE8H2F));
    }

    for (index = 0; index < Crc_Length; ++index)
    {
        /* Impact of temporary rest on next crc rest */
        crcTemp ^= Crc_DataPtr.byte(index);

        /* Next temporary crc rest */
        crcTemp  = CRC_8_H2F_Tbl[crcTemp];
    }
    result = crcTemp^(CRC_XOR_VALUE8H2F);
	  return (result);
    
    
}


on PDU TimeSync
{
  //write("----------------------------------------Debug:On Message 0x1E---------------------------------------- %d",Sync_transmitted);
  //Tx confirmation for Sync message
  if (Sync_transmitted == 1)
  {
    //Retrieve the time difference in ns between t0 (time value to be transmitted)and t1 (time triggered by Tx confirmation mechanism)
    T_diff = ((timeNow()) - time_raw_10us_precision)*10000;
    
    //Calculate total nanosecond portion that need to be attached to transmit in FUP message
    
    total_nanosecond = T_diff + timestamp_nanosecond_portion;
   //  write("nanosecond_FUP before %d",total_nanosecond);
    total_nanosecond =total_nanosecond + (@STBM::STBM_Over_CAN.UNIX_NSTime*1000);    //changed time from milli seconf to micro second
  //  write("nanosecond_FUP after %d",total_nanosecond);
    //Check overflow due to the maximum of nanosecond portion is 10^9
    Overflow_to_second = total_nanosecond/nanosecond_rollover;
  //  write("Overflow_to_second %d",Overflow_to_second);
    //Final nanosecond shall be attached after overflow checked
    nanosecond_FUP = total_nanosecond - (Overflow_to_second*nanosecond_rollover);
   
  }

  if (this.byte(0)==0x28)
  {
    //write("GPIO_count1 %d",GPIO_count);
   // write("GPIO triggering time %f",timeNowFloat()/100000.0);
    if (GPIO_count ==11 || GPIO_count ==10)
    {
      GPIO_count=0;
      count=1;
      @sysvarMember::STBM::GPIO.Sync_dependent = 1;
      @sysvarMember::STBM::GPIO.GPIO_Trigger= @ sysvarMember:: STBM::STBM_Over_CAN.FUP_Trigger;
      
    }
    else if (temp==0)
    {
      GPIO_count=0;
      @sysvarMember::STBM::GPIO.Sync_dependent = 1;
      @sysvarMember::STBM::GPIO.GPIO_Trigger= @ sysvarMember:: STBM::STBM_Over_CAN.FUP_Trigger;
      temp=1;
      
    }
//    count=count+1;
//    write("count %d",count);
  }
}
on timer GTBTimer_Sync
{
    dword OffSet_timestamp;
    //write("----------------------------------------Debug::Sync---------------------------------------- %d",Sync_transmitted);
    //get number of tick, one tick is 10us
    //In CAPL, to get the current system time, the timeNow() function is used.
    //When a measurement starts, the system clock initialises, and it’s incremented in 10us units (for example, timestamp = 12345 ticks = 123.45ms)
    //Note: time_raw_10us_precision is overflow after around 12hours (due to 32bit, each bit 10us)
    time_raw_10us_precision = timeNowFloat();
 
 //   write("time_raw_10us_precision %d",time_raw_10us_precision);
    //Retrive second portion from time raw value (10us precision) that is returned from timeNow()
    //Note: timestamp is overflow depends on overflow of time_raw_10us_precision
    timestamp = ((time_raw_10us_precision)/100000);
    
    //Retrive nanosecond portion from time raw value (10us precision) that is returned from timeNow()
    //Note:timestamp_nanosecond_portion is overflow depends on overflow of time_raw_10us_precision 
    timestamp_nanosecond_portion = (dword)(((((double)(time_raw_10us_precision)/(double)100000) - (double)(timestamp))*(double)(1000000000)));
 //   write("timestamp_nanosecond_portion %d",timestamp_nanosecond_portion);
    //debugging purpose
    //write("time_raw_10us_precision: %d",time_raw_10us_precision);
    
	OffSet_timestamp=timestamp + @STBM::STBM_Over_CAN.UNIX_Time;
  
   //Increment sequence counter for Sync message for the next transmission
	//Sync_Cnt=((Sync_Cnt+1)%(16));
	
	
    if (@STBM::Corruption.TimeSync_SequenceCounter == 0) 
      Sync_Cnt=((Sync_Cnt+1)%(16));
    else
      Sync_Cnt=((Sync_Cnt+@STBM::Corruption.Increase_counter_value)%(16));
     // @STBM::Corruption.TimeSync_SequenceCounter = 0;
	
	
    //debugging purpose
    //write("timestamp_nanosecond_portion: %d", timestamp_nanosecond_portion);

    
  	Msg_TimeSync.PduLength=8;
  	Msg_TimeSync.byte(0) = 0x20;//Type: 0x20 means SYNC PDU  [With out Error/dtc]
  	
    Msg_TimeSync.byte(2) = 0x10 | Sync_Cnt;//time domain (bit7 -> bit4) is 10, sequence counter: bit 3 -> 0
    Msg_TimeSync.byte(3) = 0x00;//user byte: default value is 0
	
	
    Msg_TimeSync.byte(4) = OffSet_timestamp>>24;
    Msg_TimeSync.byte(5) = OffSet_timestamp>>16;
    Msg_TimeSync.byte(6) = OffSet_timestamp>>8;
    Msg_TimeSync.byte(7) = OffSet_timestamp;
    
    //CRC algorithm
    for(crc_buffer_index = 0; crc_buffer_index < 6; crc_buffer_index++)
    {
      //buffer shall be from byte 2 to byte 7 of Time Sync message (applicable for both Sync and FUP)
      crc_buffer[crc_buffer_index] = Msg_TimeSync.Byte(crc_buffer_index + 2);
    }
    
    //Including DataID as per OD requirement
    crc_buffer[6] = DataIDList_Sync[Sync_Cnt];
    
    //Attach CRC after calculation
    //PROJ_CRC_Cal is basically library function Crc_CalculateCRC8H2F which has been generated by BCT tool
    if (@STBM::Corruption.TimeSync_CRC == 0) 
       Msg_TimeSync.byte(1) = PROJ_CRC_Cal(crc_buffer,7,0xFF,TRUE);//byte 1: CRC
    else
      Msg_TimeSync.byte(1) = 0xFF;//byte 1: CRC
	
   // Msg_TimeSync.byte(1) = PROJ_CRC_Cal(crc_buffer,7,0xFF,TRUE);//byte 1: CRC
	
    //To indicate that Sync message is transmitted, it shall be reset after transmitting corresponding follow up message
    Sync_transmitted = 1;
    
    //trigger the transmission of Sync message
	
    triggerPDU(Msg_TimeSync);
   
   	
    //Time Offset for corresponding Follow Up message 
    if(@STBM::STBM_Over_CAN.FUP_Trigger==1)
    {
      cycle_time = @STBM::STBM_Over_CAN.FUP_CycleTime;
      setTimer(GTBTimer_Fup,cycle_time);
    }else{
      cycle_time = @STBM::STBM_Over_CAN.FUP_CycleTime + @STBM::STBM_Over_CAN.Sync_CycleTime ;
      setTimer(GTBTimer_Sync,cycle_time);
    }
}



on timer GTBTimer_Fup
{
  if (@STBM::STBM_Over_CAN.FUP_Trigger == 1)
  {
	//write("----------------------------------------Debug::FUP---------------------------------------- %d",Sync_transmitted);
  //  Msg_TimeSync.CAN = 1;
  //  Msg_TimeSync.DLC = 8;

   Msg_TimeSync.PduLength=8;
	 Msg_TimeSync.byte(0) = 0x28;//[With out Error/dtc]

	

   if ((@STBM::Corruption.TimeSync_SequenceCounter == 1) &(@STBM::Corruption.FUP_SC_Sync_dependant==0))
   {
     FUP_Cnt=FUP_Cnt +1;
   }
   else{
     FUP_Cnt=Sync_Cnt;
   }
    //Increment sequence counter of follow up message
    if (@STBM::Corruption.FUP_SequenceCounter == 0) 
      FUP_Cnt=((FUP_Cnt)%(16));
    else
       FUP_Cnt=((FUP_Cnt+ @STBM::Corruption.Increase_counter_value)%(16));
      // @STBM::Corruption.FUP_SequenceCounter =0;
       //FUP_Cnt = 1;
    
    
  Msg_TimeSync.byte(2) = 0x10 | FUP_Cnt;//time domain is 10
	
	Msg_TimeSync.byte(3) = 0x00 & Overflow_to_second;//SGW is always 0 as it's synchronized with Global Time Master
	
	
    Msg_TimeSync.byte(4) = nanosecond_FUP>>24;
    Msg_TimeSync.byte(5) = nanosecond_FUP>>16;
    Msg_TimeSync.byte(6) = nanosecond_FUP>>8;
    Msg_TimeSync.byte(7) = nanosecond_FUP;
    
    //CRC algorithm
    for(crc_buffer_index = 0; crc_buffer_index < 6; crc_buffer_index++)
    {
      //buffer shall be from byte 2 to byte 7 of Time Sync message (applicable for both Sync and FUP)
      crc_buffer[crc_buffer_index] = Msg_TimeSync.Byte(crc_buffer_index + 2);
    }
    
    //Including DataID as per OD requirement
    crc_buffer[6] = DataIDList_Fup[FUP_Cnt];
    
    
    //Attach CRC after calculation
    //PROJ_CRC_Cal is basically library function Crc_CalculateCRC8H2F which has been generated by BCT tool
    if (@STBM::Corruption.FUP_CRC==0)
     Msg_TimeSync.byte(1) = PROJ_CRC_Cal(crc_buffer,7,0xFF,TRUE);
    else
      Msg_TimeSync.byte(1) = 0xFF;
    //Reset Sync transmitted flag here, it shall be set in next transmission of Sync msg
    Sync_transmitted = 0;
    
    //trigger to transmit

    triggerPDU(Msg_TimeSync);

    
  }
  if (@STBM::STBM_Over_CAN.Sync_Trigger == 1)
  {
    cycle_time = @STBM::STBM_Over_CAN.Sync_CycleTime ;
    setTimer(GTBTimer_Sync,cycle_time);
  }
}

on sysvar_update sysvarMember::STBM::STBM_Over_CAN.Temp_buffer_Time
{
  setTimerCyclic(Temp_buffer_Time_ms,1);
}

on timer Temp_buffer_Time_ms
{
  ++Temp_buffer_Time_cnt;
  @sysvarMember::STBM::STBM_Over_CAN.Temp_buffer_Time_ms = @sysvarMember::STBM::STBM_Over_CAN.Temp_buffer_Time + Temp_buffer_Time_cnt;
}


