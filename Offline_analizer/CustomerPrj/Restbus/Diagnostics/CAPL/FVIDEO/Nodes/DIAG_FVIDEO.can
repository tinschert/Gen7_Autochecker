/*@!Encoding:1252*/
/**
 * @file DIAG_FVIDEO.can
 * @author ADAS_HIL_TEAM
 * @date 10-04-2022
 * @brief CAPL-Program for DIAG/UDS over CAN/CAN-FD simulation via OSEK_TP.
 *
 * ################################################################
 * C O P Y R I G H T S
 * ----------------------------------------------------------------
 * Copyright (c) 2022-2023 by Robert Bosch GmbH. All rights reserved.
 
 * The reproduction, distribution and utilization of this file as
 * well as the communication of its contents to others without express
 * authorization is prohibited. Offenders will be held liable for the
 * payment of damages. All rights reserved in the event of the grant
 * of a patent, utility model or design.
 *
 * ################################################################
*/

includes
{
  #include "CAPL\Tester_On_Fuction.cin"

}

variables
{  
    byte      emptyString[kBufferSizeJumbo];

   
   	//Transmit
    const int txSize = 4096;
	  byte 	  TxDataBuffer[kBufferSizeJumbo];
   	int       TxLength;
    byte      TxDataBuffer_temp[3]={22,22,22};
    
    dword filehandle = 0;
    char buffer[32000];
    char text[512];
    char path[50] = "..\\CSV\\FVIDEO_Event_List.csv";

    //Receive
    const int rxSize = 4098;
	  byte 	  RxDataBuffer[kBufferSizeJumbo];
   	int  	  RxBufferIndex;
   	int  	  RxLength_CAN;        
    char      hexaStr[6];

    //My evaluate
    int 	NrNeededRespBytes = 0;
	  int 	ReceiveBufferLength;

	  char	MVbuffer[1024] = "";
	  char	MVbuffer2[1024] = "0x";   	

    // Variables for Requests
	  int 	  DirectTxDataLen  = 0;
   	int   	  CurrentDiagServ  = 0;
	  int		  SId              = 0;
   	float 	  RespTime         = 0.0;

    //Constants for Diag Switch
    const int TESTER_PRESENT_ON = 0;
    const int DEFAULT_SESSION   = 1;
    const int PROGRAM_SESSION   = 2;
  	const int EXTENDED_SESSION	= 3;
    const int BOSCH_SESSION     = 4;
    
    const int ECU_HARD_RESET    = 5;
    const int ECU_SOFT_RESET    = 6;
    
  	const int READ_DTC_BY_ST    = 7;
  	const int CLEAR_DTC			    = 8;
    const int DIRECT_RQ			    = 9;
    
    const int READ_DTC_BY_ST_RBEOL = 89;   

	const int READ_DTC_PASS     = 13;

    
//  	const int EN_NOR_MSG_TX		= 3;
//  	const int ECU_ID			    = 4;
//  	const int ECU_DEV_ST    	= 5;
//  	const int RD_CAMERA_LEFT    = 8;
//  	const int RD_CAMERA_RIGHT   = 9;
//  	const int RD_SW_VER         = 10;
//  	const int TEST				      = 11;
  
//  	const int RD_SERIAL_NR      = 14;
//  	const int RESET             = 15;
//  	const int START_IR_TEST     = 16;
//  	const int STOP_IR_TEST      = 17;
//  	const int START_IMG_TEST    = 18;
//  	const int STOP_IMG_TEST     = 19;
//  	const int GET_SYS_RUNTIME	  = 20;
//  	const int RESET_RUNTIME		  = 21;
//  	const int SHOW_ENG_INFO		  = 22;
//  	const int ENV_DATA			= 23;
//  	const int RD_CAN_SIG		= 24;
//  	const int RD_TEMP    		= 25;
//  	const int RD_CALIB_DATA     = 26;
//  	const int RD_ECU_ST			= 27;
//  	const int RD_TEMP_PROF		= 28;
//    const int SKIP_CALIB		= 29;
//  	const int CALIB_SHIFT_UP	= 30;
//  	const int CALIB_SHIFT_DOWN	= 31;
//  	const int CALIB_SHIFT_LEFT	= 32;
//  	const int CALIB_SHIFT_RIGHT = 33;
//  	const int CALIB_DATA_SAVE   = 34;
//  	const int RD_MAX_CALIB_DATA = 35;
//  	const int CALIB_AUTO        = 36;
//  	const int CALIB_DATA_DEL    = 37;
//  	const int READ_HIST_DTC    =  38;
//  	const int CLEAR_HIST_DTC	= 39;
//  	const int HIST_ENV_DATA		= 40;
//  	const int START_CAM_ON		= 41;
//  	const int START_CAM_OFF		= 42;
//  	const int RQ_RES_CALIB_AUTO	= 43;
//  	const int RQ_RES_SELFTEST	= 44;
//  	const int RQ_RES_CHECKSUM	= 45;
//
//    const int READ_HIST_DTC_BY_ST    = 47;
//    const int FINGERPRINT       = 48;
//    const int PROGDATE          = 49;
      const int SEEDNKEYREQUEST        =50;
    const int SEEDNKEYFBLDYNAMICREQUEST = 91;
	const int SEEDNKEYJLRDYNAMICREQUEST = 92;
	const int SEEDNKEYJLRREQUEST    =93; 
	const int SEEDNKEYFBLREQUEST     =101;
	const int SEEDNKEYJLREOLREQUEST  =102;
	const int SEEDNKEYCUSTOMERREQUEST     = 103;
	const int SEEDNKEYCUSTOMERDYNAMICREQUEST     = 104;
	const int SEEDNKEYJLRRESP        = 105;
//    const int  READ_EWB_ACT      = 54;
//    const int  READ_DEACT_FUNC   = 55;
//    const int  PRE_WRITE         = 56;
//    const int  DEACT_FUNC_FLA    = 57;
//    const int  DEACT_FUNC_CCP    = 58;
//    const int  DEACT_FUNC_VZE    = 59; 
//    const int  ACT_EWB_VZF =61;
//    const int  ACT_EWB_EHR =62;
//    const int  ACT_EWB_FLA =63;
//    const int  ACT_EWB_MOD =64;
//    const int  ACT_EWB_HCA =65;
//    const int  ACT_EWBs = 79; //MI
//    const int  ACT_XCP =84;//MI 
    //Anpassung Identifiers  all starting with 0x05
//    const int EWB_VZE_ID=0x32;
//    const int EWB_VZF_ID=0x33;
//    const int EWB_EHR_ID=0x34;
//    const int EWB_HCA_ID=0x35;
//    const int EWB_MOD_ID=0x36;
//    const int EWB_FLA_ID=0x37;
//    const int DEACT_CCP_ID= 0x30;
//    const int DEACT_FLA_ID= 0x19;
//    const int DEACT_VZE_ID= 0x18;
//    const int MASK_FAULT_CLASS_ID= 0x3C;
//    const int MASK_ERR_RCTN_ID= 0x3B;
//    const int BAP_PERS_ID= 0xA4;
//    const int XCP_ID=0x30;//MI
    //Anpassung Identifiers  all starting with 0x09 //MI
//    const int EWBs_ID=0x02; //MI
    //Anpassung Identifiers  all starting with 0x3B
//    const int V_THRESHOLD_MAINBEAM_OFF_ID= 0x23;
//    const int V_THRESHOLD_MAINBEAM_ON_ID= 0x24;
//    const int  READ_V_THRESHOLD_MAINBEAM_ON =72; 
//    const int  WRITE_V_THRESHOLD_MAINBEAM_ON =73; 
//    const int  READ_V_THRESHOLD_MAINBEAM_OFF =74; 
//    const int  WRITE_V_THRESHOLD_MAINBEAM_OFF =75; 
    
    const int ALIGNMENT_START       =51; 
    const int ALIGNMENT_STOP        =52;
    const int ALIGNMENT_STATUS      =53;
    const int ALIGNMENT_RUN_STATUS  =54;
    const int ALIGNMENT_MEAR_RES    =55;
    const int ALIGNMENT_DATA_R      =56;
    const int ALIGNMENT_DATA_W      =57;
    const int ALIGNMENT_TOL_R       =58;
    const int ALIGNMENT_TOL_W       =59;
    const int ALIGNMENT_CURR_VAL    =60;
    
    //ITC
    const int ITC_READ              =61;
    const int ITC_CLEAR             =62;
    
    //BOSCH_CODING
    const int READ_BOSCH_CODING     =63;
  	const int WRITE_BOSCH_CODING    =64;
    
    //Bosch Security Access
    const int SEEDNKEYBOSCHREQUEST  =65;
    const int SEEDNKEYBOSCHRESP     =66;

    
    //PSA Security Access
    const int SEEDNKEYPSAREQUEST    =68;
    const int SEEDNKEYPSARESP       =79;
    
    //VARIANT_CODING
    //ER
    const int READ_ER_VARIANT     =95;
  	const int WRITE_ER_VARIANT    =96;
    //RPC
    const int READ_RPC_VARIANT     =97;
  	const int WRITE_RPC_VARIANT    =98;
    
    const int SEEDNKEYRESP       = 88;
    const int P_MODE_ACT_P1 = 82;
    const int P_MODE_ACT_P2 = 83;
    
/*
    const int VIN_LEARN_START = 92;
    const int VIN_LEARN_STATUS = 94;
    const int VIN_LEARN_STOP = 82;

    const int READ_BOSCH_CODING  = 85;
  	const int WRITE_BOSCH_CODING = 86;
  	const int CAMERA_RESET       = 87;
  	





    const int  READ_MASK_FAULT_CLASS =66; 
    const int  WRITE_MASK_FAULT_CLASS =67; 
    const int  READ_MASK_ERR_RCTN =68; 
    const int  WRITE_MASK_ERR_RCTN =69; 

    const int  READ_BAP_PERS =70; 
    const int  WRITE_BAP_PERS =71; 

    const int MINICODEREQUEST = 76;
    const int PRE_WRITE_MINICODE = 77;
    const int SEEDNKEYREPROGREQUESTWRITEKEY = 78;
    const int READ_Software_version    = 79;*/
   
    int InnerTempValue = 0;

    long copiedBytes ;

   
    //Stringbuffer
    char 	  Stringbuffer[4098];
   	char	  StringAux[4098];	

    //read dtc variables
   	dword 	  errorDTC[256];
   	dword 	  errorStatus[256]; 
   	int  	  CurrentDTC = 0;
   	int  	  NrOfReadDTC ;   
	
	  dword 	  errorHistDTC[256];
   	byte 	  errorHistStatus[256]; 
   	int  	  CurrentHistDTC = 0;
   	int  	  NrOfHistDTC;  
   	int  	  NrOfReadHistDTC;   

	  // Tester Present Handling
   	msTimer   TesterPresentTimer;
   	const int TesterPresentTime = 2000;
   	const int FirstTesterPresentTime = 20;
    
  	/*   
   	message   TST_PhysicalReqCCM_UN msgDiagRequest = {
   				dword(0) = 0xffffffff,
   				dword(4) = 0xffffffff};

    
    message   TST_PhysicalRespCCM_UN ReqDiagMsgGlobal = {
   				dword(0) = 0x00000000,
   				dword(4) = 0x00000000}; 
    */
   	   
 	 
   	int 	  DiagActive = 0;       

    msTimer   UpdateRuntime;
	  const int UpdateCycle = 1000;
    
    //to doors-automate-tests

    int readTimeValue;          //elapsed time counter (ms)
    char DTCValue [255];        //internal container for error codes  
    msTimer readDtcTimer;       //for repeat the reading process
    int CNTR_VALUE=200;         //default timer resolution (ms)
    char readString[255];       //to store the read DTC command
    byte readRequest[255];      //to store the read DTC command
    int requestSize;            //
    char msString[30];          //for the information string
    byte ErrValue [4098];       //the representation of RxDataBuffer
    char ErrString [4098];      //the characteric representation of RxDataBuffer
    char tempString [4098];     //for internal use

    //Seed&key

    byte Fingerprint[9]={0x2e,0xf1,0x98,0x01,0x02,0x03,0x04,0x05,0x06};
    byte ProgrammingDate[6]={0x2e,0xf1,0x99,0x19,0x01,0x09};
    byte SeednKeyFBLRequest[2] = {0x27,0x61};
	byte SeednKeyCustomerRequest[2] = {0x27,0x03};
    byte SeednKeyJLREOLRequest[2] = {0x27,0x01};
    byte MinicodeRequest[2]= {0x27,0x21};
    dword seedReprogValue,  keyLowReprogValue, keyUpperReprogValue;
    dword keyReprogValue;
    dword authKey;
    byte     pufferEOL[10]={0,0,0,0,0,0,0,0,0,0};
    dword keyMaxReprogValue = 0xFFFFFFFF;
    dword WLA, WLAaktiv, WLApassiv; 

    byte whichlogin=0;
    dword result=0; 
    byte resultarray[6]={0x27,0,0,0,0,0};
    byte resultarra[5] = {0x27,0,0,0,0};
 
    // For new security Implementation
    char seedList[600][600];
    char keyList[4096][4096];
    
    char seedListJLR[600][600];
	  char seedListCUST[600][600];
    
    char keyListJLR[2048][2048];
	  char keyListCUST[2048][2048];
    
	char responsefilename[256];
	char responseCUSTfilename[256];
	char keyString[2048];
	char keySend[2048];
	int gDynamicWaitcnt;
	dword responsefilehandle;
	dword responseCUSTfilehandle;
    int dynamicKeyLen;
	int gDynamicCUSTWaitcnt;
    int securityType = SEEDNKEYREQUEST;
    int securityTypeJLR = SEEDNKEYJLRREQUEST;
	int securityTypeCUST = SEEDNKEYCUSTOMERREQUEST;
    byte SecurityBuffer[1];
    int i, j, c_index, bin;
    byte input[8];
    int challenge[64], position_one[24], position_two[24];
    int init_array[24] = {1,0,0,1,0,1,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,1};
    byte sendKey[4096];
    msTimer sectimer1;
    msTimer sectimer2;
	mstimer secDynamictimer;
	mstimer secDynamiccusttimer;
	msTimer SeednKeyReq;
    int DynamicFlag = 0;
    char temp1[5];

    char DynamicKey[2052];
    byte defaultsec[1];
    int Seed_buf[4]={0,0,0,0};
    int Seed_buf_Bosch[5]={0,0,0,0,0};
    msTimer JLRUnlockTimer;
    msTimer BoschUnlockTimer;
    msTimer     ActPMode;

    char gstatusITC[22];
    msTimer VINTimer;
    
    int VINFlag;
    int ALIGNFlag;

    int tempInt;
    
    msTimer alignmentTimer;

    msTimer ITCTimer_Read,ITCTimer_Clear;//ITC timer
	  byte BoschCodingBuffer[50];
    

    //Alignment::Default value
    const K_Align_RID_Sta  =  0x0402;//Static Alignment
    const K_Align_RID_Dyn  =  0x0403;//Dynamic Alignment    
    
    const K_Align_IN_Plant  =  0x01;//Plant Alignment
    const K_Align_IN_After  =  0x02;//After sale Alignment 
    
    word G_Align_RID =  K_Align_RID_Sta;//Project-Routine Identifier (RID)
    byte G_Align_IN  =  K_Align_IN_Plant;
    
    word G_Align_Data      =  0xD406;//Alignment Data
    word G_Align_Tolerance =  0xD413;//DID::Alignment Tolerance
    word G_Align_Meas_Res  =  0xD414;//DID::Alignment Measure Result
    word G_Align_Curr_Val  =  0xD415;//DID::Current Misalignment Value
    
    //BOSCH CODING DATA::ITC::Default value
    const K_ITC_DiD  =  0xFB09;
    const K_ITC_FR_Mask_lng  =  54;//Front length
    const K_ITC_CR_Mask_lng  =  50;//Corner length
    
    byte  G_ITC_Mask_lng    =  K_ITC_FR_Mask_lng;//Default


    //FR
    const K_TxId_FR = 0x6B6;
    const K_RxId_FR = 0x696;
   
    //CR_FL:
    const K_TxId_CR_FL  = 0x6A5;
    const K_RxId_CR_FL  = 0x685;
    
    //CR_FR:
    const K_TxId_CR_FR  = 0x6AB;
    const K_RxId_CR_FR  = 0x68B;
    
    //CR_RL:
    const K_TxId_CR_RL  = 0x6AE;
    const K_RxId_CR_RL  = 0x68E;
    
    //CR_RR:
    const K_TxId_CR_RR  = 0x6BE;
    const K_RxId_CR_RR  = 0x69E;
    
    const APPLICATIONKEY_FRONT  = 0xBDE3   ;// Value of Application Key for FRONT RADAR
    const APPLICATIONKEY_CORNER = 0xB77B   ;// Value of Application Key for CORNER RADAR 
      
    byte g_seed_value_psa[4];
    byte g_key_value_psa[4];
    
    byte g_seed_value_bosch[6];
    byte g_key_value_bosch[6];
}

on preStart
{

	char absPath[256];
  char absPathsecurity[250];
  char absPathCustomerSecurity[250];
  
  registerUserFile("CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FVIDEO\\CSV\\FVIDEO_Event_List.csv", 0);
  getUserFilePath("FVIDEO_Event_List.csv", absPath, 256);
  //write("%s",absPath);
  
  filehandle = openFileRead(path, 0);
  if (!filehandle) 
  {
    write("Error reading CSV file!!!");
  }
  
  sysSetVariableString(sysvar::DIAG_FVIDEO::PSA_SecAcc::Display,"");
  sysSetVariableString(sysvar::DIAG_FVIDEO::Bosch_SecAcc::Display,"");
  //write("##############%s",absPath);
  
    //getAbsFilePath("\\..\\cs\\cs_dbcs\\ECU Unlock Security.xml", absPathsecurity, 256);
    registerUserFile("CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FVIDEO\\Security\\ECU Unlock Security.xml", 0);
    getUserFilePath("ECU Unlock Security.xml", absPathsecurity, 256);
    //ParseSecurityXML(absPathsecurity);
    ini_seed_key();
  
    //getAbsFilePath("\\..\\cs\\cs_dbcs\\ECU Customer Unlock Security.xml", absPathCustomerSecurity, 256); 
    registerUserFile("CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FVIDEO\\Security\\ECU Customer Unlock Security.xml", 0);
    getUserFilePath("ECU Customer Unlock Security.xml", absPathCustomerSecurity, 256);
    
    //ParseCustomerSecurityXML(absPathCustomerSecurity);
    
    write("##############%s",absPathsecurity);
    write("##############%s",absPathCustomerSecurity);
  
  @DIAG_FVIDEO::GeneralSettings::sysPaddingValue =0x00;
}

on start
{
   
    byte buffer[1]={0xFF};
    set_sysPaddingValue(0x00);
    //ConfigTP();
    defaultsec[0] = 0x61;
    //putvalue(Env_Doip_Security_SubFunctionCAN,defaultsec);
    sysSetVariableData(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Doip_Security_SubFunction1CAN,defaultsec,elCount(defaultsec));
    defaultsec[0] = 0x01;
    //putvalue(Env_Doip_Security_SubFunction2CN,defaultsec);
    sysSetVariableData(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Doip_Security_SubFunction2CAN,defaultsec,elCount(defaultsec));
       // Default Suche nach DTC 000124
    defaultsec[0] = 0x03;
    //putvalue(Env_CANSecurity_SubFunction3CAN,defaultsec);
    sysSetVariableData(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Doip_Security_SubFunction3CAN,defaultsec,elCount(defaultsec));
    
    
}

/** @brief this is  function for parse xml file
* Into arguments nameOfFile xml file for parse
* @param nameOfFile received UDP data into byte format
* @return void data
*/

void ParseSecurityXML(char nameOfFile[])
{
  dword fileHandle;
  char buffer[10000];
  char FileBuffer[150000];
  int filePos;
  int key_type = 0;
  int staticPosStart;
  int staticPosEnd;
  char staticBuffer[50000];
  int seedPosStart;
  int seedPosEnd;
  int staticPos=0;
  int i;
  
  fileHandle =  openFileRead (nameOfFile,0);
  
  while (fileGetStringSZ(buffer,elcount(buffer),fileHandle)!=0)
  {
    strncat(FileBuffer, buffer, elcount(FileBuffer));
  }
  fileClose (fileHandle);
  
  //write("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%d",strstr(FileBuffer,"0x61\" key_type=\"static"));
  if(strstr(FileBuffer,"0x61\" key_type=\"static")!=-1)
  {
    filePos = strstr(FileBuffer,"dia_sub_function=\"0x61\" encrypted=\"no\"");
    if(filePos!=-1)
    {
      staticPosStart = strstr_off(FileBuffer,filePos,"<SEEDS>")+7;
      staticPosEnd = strstr_off(FileBuffer,filePos,"</KEYS>");
      substr_cpy(staticBuffer, FileBuffer, staticPosStart,staticPosEnd-staticPosStart,elcount(staticBuffer));
	    i=0;
      while(1)
      {
        seedPosStart = strstr_off(staticBuffer,staticPos,"<SEED>")+6;
        if(seedPosStart==-1)
        {
          break;
        }
        seedPosEnd = strstr_off(staticBuffer,staticPos+7,"</SEED>");
        if(seedPosEnd==-1)
        {
          break;
        }
        substr_cpy(seedList[i], staticBuffer, seedPosStart+2,seedPosEnd-seedPosStart-2,elcount(seedList));
        i++;
        staticPos = seedPosEnd;
		
      }
      i=0;
	  staticPos = 0;
      while(1)
      {
        seedPosStart = strstr_off(staticBuffer,staticPos,"<KEY>")+5;
        if(seedPosStart==-1)
        {
          break;
        }
        seedPosEnd = strstr_off(staticBuffer,staticPos+7,"</KEY>");
        if(seedPosEnd==-1)
        {
          break;
        }
        substr_cpy(keyList[i], staticBuffer, seedPosStart+2,seedPosEnd-seedPosStart-2,elcount(keyList));
        i++;
        staticPos = seedPosEnd;
		
      }
    }
    
    securityType = SEEDNKEYFBLREQUEST;
    //write("!!!!!!!!!!!");
    
  }
  else if(strstr(FileBuffer,"0x61\" key_type=\"dynamic")!=-1)
  {
    securityType = SEEDNKEYFBLDYNAMICREQUEST;
    //write("@@@@@@@@@@@@@@@@@@@");
  }
  else if(strstr(FileBuffer,"0x61\" key_type=\"conventional")!=-1)
  {
    securityType = SEEDNKEYREQUEST;
    //write("####################");
  }
  else
  {
    write("The Security XML is not as per standards. Conventional mode of EOL is active");
  }
  
  //****** For JLR Security Unlock *******
  if(strstr(FileBuffer,"0x01\" key_type=\"static")!=-1)
  {
    filePos = strstr(FileBuffer,"dia_sub_function=\"0x01\" encrypted=\"no\"");
    if(filePos!=-1)
    {
      staticPosStart = strstr_off(FileBuffer,filePos,"<SEEDS>")+7;
      staticPosEnd = strstr_off(FileBuffer,filePos,"</KEYS>");
      substr_cpy(staticBuffer, FileBuffer, staticPosStart,staticPosEnd-staticPosStart,elcount(staticBuffer));
	    i=0;
      staticPos = 0;
      while(1)
      {
        seedPosStart = strstr_off(staticBuffer,staticPos,"<SEED>")+6;
        if(seedPosStart==-1)
        {
          break;
        }
        seedPosEnd = strstr_off(staticBuffer,staticPos+7,"</SEED>");
        if(seedPosEnd==-1)
        {
          break;
        }
        substr_cpy(seedListJLR[i], staticBuffer, seedPosStart+2,seedPosEnd-seedPosStart-2,elcount(seedListJLR));
        i++;
        staticPos = seedPosEnd;
		
      }
      i=0;
	  staticPos = 0;
      while(1)
      {
        seedPosStart = strstr_off(staticBuffer,staticPos,"<KEY>")+5;
        if(seedPosStart==-1)
        {
          break;
        }
        seedPosEnd = strstr_off(staticBuffer,staticPos+7,"</KEY>");
        if(seedPosEnd==-1)
        {
          break;
        }
        substr_cpy(keyListJLR[i], staticBuffer, seedPosStart+2,seedPosEnd-seedPosStart-2,elcount(keyListJLR));
        i++;
        staticPos = seedPosEnd;
		
      }
    }
    
    securityTypeJLR = SEEDNKEYJLREOLREQUEST;
    
  }
  else if(strstr(FileBuffer,"0x01\" key_type=\"dynamic")!=-1)
  {
    securityTypeJLR = SEEDNKEYJLRDYNAMICREQUEST;
  }
  else if(strstr(FileBuffer,"0x01\" key_type=\"conventional")!=-1)
  {
    securityTypeJLR = SEEDNKEYJLRREQUEST;
  }
  else
  {
    write("The Security XML is not as per standards. Conventional mode EOL is active");
  }
  
  
  
}

/** @brief this is  function for parse xml file
* Into arguments nameOfFile xml file for parse
* @param nameOfFile received UDP data into byte format
* @return void data
*/

void ParseCustomerSecurityXML(char nameOfFile[])
{
  dword fileHandle;
  char buffer[10000];
  char FileBuffer[150000];
  int filePos;
  int key_type = 0;
  int staticPosStart;
  int staticPosEnd;
  char staticBuffer[50000];
  int seedPosStart;
  int seedPosEnd;
  int staticPos=0;
  int i;
  
  fileHandle =  openFileRead (nameOfFile,0);
  while (fileGetStringSZ(buffer,elcount(buffer),fileHandle)!=0)
  {
    strncat(FileBuffer, buffer, elcount(FileBuffer));
  }
  fileClose (fileHandle);
  
    filePos = strstr(FileBuffer,"dia_sub_function=\"0x03\" encrypted=\"no\"");
    if(filePos!=-1)
    {
      staticPosStart = strstr_off(FileBuffer,filePos,"<SEEDS>")+7;
      staticPosEnd = strstr_off(FileBuffer,filePos,"</KEYS>");
      substr_cpy(staticBuffer, FileBuffer, staticPosStart,staticPosEnd-staticPosStart,elcount(staticBuffer));
	    i=0;
      while(1)
      {
        seedPosStart = strstr_off(staticBuffer,staticPos,"<SEED>")+6;
        if(seedPosStart==-1)
        {
          break;
        }
        seedPosEnd = strstr_off(staticBuffer,staticPos+7,"</SEED>");
        if(seedPosEnd==-1)
        {
          break;
        }
        substr_cpy(seedListCUST[i], staticBuffer, seedPosStart+2,seedPosEnd-seedPosStart-2,elcount(seedListCUST));
        i++;
        staticPos = seedPosEnd;
		
      }
      i=0;
	  staticPos = 0;
      while(1)
      {
        seedPosStart = strstr_off(staticBuffer,staticPos,"<KEY>")+5;
        if(seedPosStart==-1)
        {
          break;
        }
        seedPosEnd = strstr_off(staticBuffer,staticPos+7,"</KEY>");
        if(seedPosEnd==-1)
        {
          break;
        }
        substr_cpy(keyListCUST[i], staticBuffer, seedPosStart+2,seedPosEnd-seedPosStart-2,elcount(keyListCUST));
        i++;
        staticPos = seedPosEnd;
		
      }
    }
    
    securityTypeCUST = SEEDNKEYCUSTOMERREQUEST;
    write("parse xml cust");
    
 
    
  if(strstr(FileBuffer,"0x03\" key_type=\"dynamic")!=-1)
  {
    securityTypeCUST = SEEDNKEYCUSTOMERDYNAMICREQUEST;
  }
 
  else
  {
    write("The Security XML is not as per standards");
  }
  
}



on timer SeednKeyReq
{
StartDiagService( SEEDNKEYREQUEST );
}

on timer sectimer1
{
  //putValue(Env_Doip_SecurityMode_OutputCAN,"");
  sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN,"");
  setTimer(sectimer2,500);
}

on timer sectimer2
{
  //putValue(Env_Doip_SecurityMode_OutputCAN,"Click the button to enter dynamic Key");
  sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN,"Click the button to enter dynamic Key");
  setTimer(sectimer1,1000);
}

on timer secDynamictimer
{
  
 if(fileGetStringSZ(keyString,elcount(keyString),responsefilehandle)!=0)
      {
         if(strncmp(keyString,"ERROR",6)==0)
            {
      DynamicFlag = 0;
      //putvalue(Env_Doip_SecurityMode_OutputCAN,"Not Successful ! Check Smart Card connection");
      sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN,"Not Successful ! Check Smart Card connection");
	  fileClose(responsefilehandle);
      cancelTimer(sectimer1);
      cancelTimer(sectimer2);
            }
         else
          {
            for(i = 0; i<strlen(keyString)-4;i++)
          {
            keySend[i]=keyString[i+4];
          }
            fileClose(responsefilehandle);
            //write("Comingggggggggggggggg");
          //putValue(Env_DoipSecurity_DynamicInputCAN,keySend);
          sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_DynamicInput,keySend);
          }
        }
    
 else
      {
    settimer(secDynamictimer,500);
    gDynamicWaitcnt++;
      }
  
if(gDynamicWaitcnt > 240)
  
  {
    cancelTimer(secDynamictimer);
    DynamicFlag = 0;
    //putvalue(Env_Doip_SecurityMode_OutputCAN,"Key input Timeout. Try once again");
    sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN,"Key input Timeout. Try once again");
  }
  

}

on timer secDynamiccusttimer
{
  
if(fileGetStringSZ(keyString,elcount(keyString),responseCUSTfilehandle)!=0)
  {
    if(strncmp(keyString,"ERROR",6)==0)
    {
      DynamicFlag = 3;
      //putvalue(Env_Doip_SecurityMode_OutputCAN,"Not Successful ! Check Smart Card connection");
      sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN,"Not Successful ! Check Smart Card connection");
	  fileClose(responseCUSTfilehandle);
      cancelTimer(sectimer1);
      cancelTimer(sectimer2);
    }
    else
    {
      for(i = 0; i<strlen(keyString)-4;i++)
      {
        keySend[i]=keyString[i+4];
      }
        fileClose(responseCUSTfilehandle);
        write("CUST Comingggggggggggggggg");
        //putValue(Env_DoipSecurity_DynamicInputCAN,keySend);
        sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_DynamicInput,keySend);
    }
  }
  else
  {
    settimer(secDynamiccusttimer,500);
    gDynamicCUSTWaitcnt++;
  }
  
  if(gDynamicCUSTWaitcnt > 240)
  {
    cancelTimer(secDynamiccusttimer);
    DynamicFlag = 3;
    //putvalue(Env_Doip_SecurityMode_OutputCAN,"Key input Timeout. Try once again");
    sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN,"Key input Timeout. Try once again");
  }
  
  }

/** @brief this is function for send diag service as per serviceid
* Into arguments ServiceId
* @param ServiceId byte data for diag service
* @return void data
*/

void StartDiagService( byte ServiceId )
{ 
    int64 i;
    long copiedBytes;
    byte l_Key_value[4],l_Seed_value[4];
    byte l_Key_value_bosch[6],l_Seed_value_bosch[6];
  
    for(i=0;i<4;i++)
    {
      l_Key_value[i]=l_Seed_value[i]=0;//Reset
    }
    for(i=0;i<6;i++)
    {
      l_Key_value_bosch[i]=l_Seed_value_bosch[i]=0;//Reset
    }


    CurrentDiagServ = ServiceId;
  
    if(ServiceId!=TESTER_PRESENT_ON)
         sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "...");
         sysSetVariableFloat(sysvar::DIAG_FVIDEO::sysDataReceived_Time, 0.0);   

   //Diag Switch
   switch ( ServiceId )
   {
	  case TESTER_PRESENT_ON:
							TxDataBuffer[0] = 0x3E;	
							TxDataBuffer[1] = 0x00;
							TxLength = 2;  
							TransmitTxBuffer();
							break;
	  case DEFAULT_SESSION:
							TxDataBuffer[0] = 0x10;
							TxDataBuffer[1] = 0x01;	
							TxLength = 2;  
							TransmitTxBuffer();
							break;
	  case PROGRAM_SESSION:
							TxDataBuffer[0] = 0x10;
							TxDataBuffer[1] = 0x02;	
							TxLength = 2;  
							TransmitTxBuffer();
							break;
	  case EXTENDED_SESSION:
							TxDataBuffer[0] = 0x10;
							TxDataBuffer[1] = 0x03;	//Extended diag session
							TxLength = 2;  
							TransmitTxBuffer();
							break;
    case BOSCH_SESSION: 
							TxDataBuffer[0] = 0x10;
							TxDataBuffer[1] = 0x60; 
							TxLength = 2; 
							TransmitTxBuffer();
							break; 
    case ECU_HARD_RESET:
							TxDataBuffer[0] = 0x11;
							TxDataBuffer[1] = 0x01;	//Extended diag session
							TxLength = 2;  
							TransmitTxBuffer();
							break;
    case ECU_SOFT_RESET:
							TxDataBuffer[0] = 0x11;
							TxDataBuffer[1] = 0x03;	//Extended diag session
							TxLength = 2;  
							TransmitTxBuffer();
							break;
    case READ_DTC_BY_ST: 
							TxDataBuffer[0] = 0x19;
							TxDataBuffer[1] = 0x02;
							TxDataBuffer[2] = 0x09;  
							TxLength = 3; 
							TransmitTxBuffer();
							break;
    case CLEAR_DTC: 
							TxDataBuffer[0] = 0x14;
							TxDataBuffer[1] = 0xFF;  
							TxDataBuffer[2] = 0xFF;
							TxDataBuffer[3] = 0xFF;   
							TxLength = 4;
							TransmitTxBuffer();
							break;
    case DIRECT_RQ: 
							TxLength = DirectTxDataLen;
							TransmitTxBuffer();
							break;
    case P_MODE_ACT_P1:
      
        //1) Send part1 request "80 FA 31 03 30 05"
        TxDataBuffer[0] = 0x80;
        TxDataBuffer[1] = 0xB5;
        TxDataBuffer[2] = 0x28;  
        TxDataBuffer[3] = 0xC3;  
        TxDataBuffer[4] = 0x1E;  
        TxDataBuffer[5] = 0xFD;  
       
        TxLength = 6; 
        TransmitTxBuffer();
        
      break;  
      
      case P_MODE_ACT_P2:
      
        //2) Send part2 request "80 FA 11 08"
        TxDataBuffer[0] = 0x80;
        TxDataBuffer[1] = 0xB5;
        TxDataBuffer[2] = 0x7C;  
        TxDataBuffer[3] = 0x68;  
        
        TxLength = 4; 
        TransmitTxBuffer();
        
      break;  
/*
    case VIN_LEARN_START:
							TxDataBuffer[0] = 0x31;
							TxDataBuffer[1] = 0x01;
      
							TxDataBuffer[2] = 0x04;  
							TxDataBuffer[3] = 0x04; 
							TxLength = 4; 
							TransmitTxBuffer();
							break;
    case VIN_LEARN_STOP:
							TxDataBuffer[0] = 0x31;
							TxDataBuffer[1] = 0x02;
							TxDataBuffer[2] = 0x04;  
							TxDataBuffer[3] = 0x04; 
							TxLength = 4; 
							TransmitTxBuffer();
							break;
    case VIN_LEARN_STATUS:
							TxDataBuffer[0] = 0x31;
							TxDataBuffer[1] = 0x03;
							TxDataBuffer[2] = 0x04;  
							TxDataBuffer[3] = 0x04; 
							TxLength = 4; 
							TransmitTxBuffer();
							break;

*/
	case ALIGNMENT_START:
          	  TxDataBuffer[0] = 0x31;//Diagnostic Routine Service
          	  TxDataBuffer[1] = 0x01;//Sub-functions::Start Routine
          	  TxDataBuffer[2] = G_Align_RID>>8;//Project-Routine Identifier (RID)
          	  TxDataBuffer[3] = G_Align_RID;//Project-Routine Identifier (RID)
              TxDataBuffer[4] = G_Align_IN;
              TxLength = 5;
              TransmitTxBuffer();
							break;
	case ALIGNMENT_STOP:
          		TxDataBuffer[0] = 0x31;//Diagnostic Routine Service
          		TxDataBuffer[1] = 0x02;//Sub-functions::Stop Routine
          		TxDataBuffer[2] = G_Align_RID>>8;//Project-Routine Identifier (RID)
          		TxDataBuffer[3] = G_Align_RID;//Project-Routine Identifier (RID)
          		TxLength = 4;
          		TransmitTxBuffer();
							break;
  case ALIGNMENT_STATUS:
          		TxDataBuffer[0] = 0x31;//Diagnostic Routine Service
          		TxDataBuffer[1] = 0x03;//Sub-functions::Request Routine Results
          		TxDataBuffer[2] = G_Align_RID>>8;//Project-Routine Identifier (RID)
          		TxDataBuffer[3] = G_Align_RID;//Project-Routine Identifier (RID)
          		TxLength = 4;
          		TransmitTxBuffer();
							break;
	case ALIGNMENT_RUN_STATUS:
          		TxDataBuffer[0] = 0x22;
          		TxDataBuffer[1] = 0xA2;//Project
          		TxDataBuffer[2] = 0x29;//Project
          		TxLength = 3;
          		TransmitTxBuffer();
							break;
	case ALIGNMENT_MEAR_RES:
              TxDataBuffer[0] = 0x22;//RDBI
            	TxDataBuffer[1] = G_Align_Meas_Res>>8;
            	TxDataBuffer[2] = G_Align_Meas_Res;
              TxLength = 3;
              TransmitTxBuffer();
							break;
	case ALIGNMENT_DATA_R:
              TxDataBuffer[0] = 0x22;//RDBI
            	TxDataBuffer[1] = G_Align_Data>>8;
            	TxDataBuffer[2] = G_Align_Data;
              TxLength = 3;
              TransmitTxBuffer();
							break;
	case ALIGNMENT_DATA_W:
              Alignment_Data_Write();
							break;
	case ALIGNMENT_TOL_R:
              TxDataBuffer[0] = 0x22;//RDBI
            	TxDataBuffer[1] = G_Align_Tolerance>>8;
            	TxDataBuffer[2] = G_Align_Tolerance;
              TxLength = 3;
              TransmitTxBuffer();
							break;
	case ALIGNMENT_TOL_W:
              Alignment_Tolerance_Write();
							break;
	case ALIGNMENT_CURR_VAL:
              TxDataBuffer[0] = 0x22;//RDBI
            	TxDataBuffer[1] = G_Align_Curr_Val>>8;
            	TxDataBuffer[2] = G_Align_Curr_Val;
              TxLength = 3;
              TransmitTxBuffer();
							break;
    case ITC_READ:
							TxDataBuffer[0] = 0x22;
							TxDataBuffer[1] = 0xFD;//Pending
							TxDataBuffer[2] = 0x09;//Pending
							TxLength = 3;
							TransmitTxBuffer();
							break;
    case ITC_CLEAR:
							TxDataBuffer[0] = 0x31;
							TxDataBuffer[1] = 0x01; 
							TxDataBuffer[2] = 0xF0;//Pending
							TxDataBuffer[3] = 0x01;//Pending
							TxLength = 4;
							TransmitTxBuffer();
							break;
  case READ_BOSCH_CODING:
							TxDataBuffer[0] = 0x22;
          	  TxDataBuffer[1] = K_ITC_DiD>>8;
          	  TxDataBuffer[2] = K_ITC_DiD;
              TxLength = 3;
              TransmitTxBuffer();
							break;
  case WRITE_BOSCH_CODING: 
							bosch_coding_Write();
							break;
  case READ_ER_VARIANT:
							TxDataBuffer[0] = 0x22;
          	  TxDataBuffer[1] = 0x05;
          	  TxDataBuffer[2] = 0x00;
              TxLength = 3;
              TransmitTxBuffer();
							break;
  case WRITE_ER_VARIANT: 
    					TxDataBuffer[0] = 0x2E;
          	  TxDataBuffer[1] = 0x05;
          	  TxDataBuffer[2] = 0x00;
              TxDataBuffer[3] = @DIAG_FVIDEO::ER_VARIANT_CODING::ERVariant;
              TxLength = 4;
              TransmitTxBuffer();
							//variant_coding_Write();
							break;
  case READ_RPC_VARIANT:
							TxDataBuffer[0] = 0x22;
          	  TxDataBuffer[1] = 0x05;
          	  TxDataBuffer[2] = 0x00;
              TxLength = 3;
              TransmitTxBuffer();
							break;
  case WRITE_RPC_VARIANT: 
    					TxDataBuffer[0] = 0x2E;
          	  TxDataBuffer[1] = 0x05;
          	  TxDataBuffer[2] = 0x00;
              TxDataBuffer[3] = @DIAG_FVIDEO::RPC_VARIANT_CODING::RPCVariant;
              TxLength = 4;
              TransmitTxBuffer();
							//variant_coding_Write();
							break;
	case SEEDNKEYBOSCHREQUEST: 
							TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x61;
							TxLength = 2;
							TransmitTxBuffer();
							break;
	case SEEDNKEYFBLDYNAMICREQUEST:
							TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x61;
							TxLength = 2;
							TransmitTxBuffer();
							break; 
	case SEEDNKEYFBLREQUEST:
							TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x61;
							TxLength = 2;
							TransmitTxBuffer();
							break;
	case SEEDNKEYCUSTOMERDYNAMICREQUEST:
							TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x03;
							TxLength = 2;
							TransmitTxBuffer();
							break;
	case SEEDNKEYCUSTOMERREQUEST:
							TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x03;
							TxLength = 2;
							TransmitTxBuffer();
							break;
	case SEEDNKEYJLRDYNAMICREQUEST:
							TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x61;
							TxLength = 2;
							TransmitTxBuffer();
							break;
	case SEEDNKEYJLREOLREQUEST:
							TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x01;
							TxLength = 2;
							TransmitTxBuffer();
							break;
	case SEEDNKEYJLRREQUEST:
							TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x61;
							TxLength = 2;
							TransmitTxBuffer();
							break;
	case SEEDNKEYREQUEST:
							TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x61;
							TxLength = 2;
							TransmitTxBuffer();
							break;

	case SEEDNKEYJLRRESP: 
              //putValue(EnvTxData_1CAN,sendKey);
              sysSetVariableData(sysvar::DIAG_FVIDEO::sysDataToTransmit,sendKey,elCount(sendKey));
              //DirectTxDataLen = getValue( EnvTxData_1CAN, TxDataBuffer );
              DirectTxDataLen = sysGetVariableData(sysvar::DIAG_FVIDEO::sysDataToTransmit, TxDataBuffer ,copiedBytes);
              TransmitTxBuffer();
              //write("))))))))))))))))))) %d",TxLength);
              break;
	
  case SEEDNKEYBOSCHRESP: 
              TxDataBuffer[0] = 0x27;
              TxDataBuffer[1] = 0x62;
              TxLength = sysGetVariableData(sysvar::DIAG_FVIDEO::Bosch_SecAcc::Key_value, l_Key_value_bosch ,copiedBytes);
              for (i = 0 ; i < 6 ; i++)
              {
                  TxDataBuffer[i+2] = g_key_value_bosch[i];
              }
              for (i = 8 ; i < 2050 ; i++)
              {
                  TxDataBuffer[i] = 0x00;
              }
  						TxLength = 2050;//TxLength = 6;
							TransmitTxBuffer();
							break;
  case SEEDNKEYPSAREQUEST: 
              sysSetVariableData(sysvar::DIAG_FVIDEO::PSA_SecAcc::Seed_value,l_Seed_value,elCount(l_Seed_value));//Reset
							TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x03;
							TxLength = 2;
							TransmitTxBuffer();
							break; 
  case SEEDNKEYPSARESP: 
              @sysvar::DIAG_FVIDEO::PSA_SecAcc::Trigger_Status=0;//Rest
							TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x04;
							TxLength = sysGetVariableData(sysvar::DIAG_FVIDEO::PSA_SecAcc::Key_value, l_Key_value ,copiedBytes);
              for(i=0;i<4;i++)
              {
                 TxDataBuffer[i+2] =l_Key_value[i];
              }
							TxLength = 6;
							TransmitTxBuffer();
							break;      


  case SEEDNKEYRESP: 

    					TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x00;
              TxDataBuffer[2] = 0x00;
              TxDataBuffer[3] = 0x00;
              TxDataBuffer[4] = 0x00;
							TxLength = 5;  
							TransmitTxBuffer();
							break;
/*
  case READ_Software_version: 
							TxDataBuffer[0] = 0x22;
							TxDataBuffer[1] = 0xF1;
							TxDataBuffer[2] = 0x88;  
							TxLength = 3; 
							TransmitTxBuffer();
							break;
*/
  }
}   

/** @brief this is function for evaluate CANtp response and put on
 panel dispaly
*/

MyEvaluateResponse ()
{
	int i;
	int RespLength;

	char buffer[1024];
	char buffer2[1024]="0";

 
	strncpy(buffer2, "0", 6);
	strncpy(MVbuffer2, "",6);
	strncpy(MVbuffer, "",6);

	if( ReceiveBufferLength > 255 )
	{
		strncpy(buffer, "Answer length too big!",99);//English
    //strncpy(buffer, "Antwortlaenge zu gross!",99);//German
		//write("An error %s has occurred!", buffer)//English
		//write("Fehler '%s' ist aufgetreten!", buffer);an error has occurred
	}

	if( NrNeededRespBytes != 0 )
	{
		RespLength = NrNeededRespBytes;
	}
	else
	{
		RespLength = ReceiveBufferLength;
	}
	
	for(i=0; i < RespLength; i++)
	{
		ltoa(RxDataBuffer[i], MVbuffer2, 16);
		if( strlen( MVbuffer2 ) == 1 )
		{
			strncat(buffer2, MVbuffer2, elcount(buffer2));
			strncat(MVbuffer, buffer2, elcount(MVbuffer));
			strncpy(buffer2, "0", 6);
		}
		else
		{
			strncat(MVbuffer, MVbuffer2, elcount(MVbuffer));
		}
	}
  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataReceived_String ,MVbuffer);
}

/** @brief this is function for Evalualate CANTP RX buffer
* Into arguments Length
* @param Length rxbuffer Length
* @return void data
*/

void EvaluateRxData( int Length )
{
   int      DtcNr;  
   dword    auxRT;
   float    convert_rad_grad = 57.295779513082320876798154814105;

   dword    resultarray_32[6]={0,0,0,0,0,0};

   dword    REP_RBA_CBB_AKEY_VALUE  = 0x41916668;
   dword    REP_RBA_CBB_BKEY_VALUE  = 0x12774118;
   dword    REP_RBA_CBB_CKEY_VALUE  = 0x86905668;
   dword    REP_RBA_CBB_DKEY_VALUE  = 0x10371229;


   dword    WERK_RBA_CBB_AKEY_VALUE = 0x52917768;  //Minicode 2703/2704
   dword    WERK_RBA_CBB_BKEY_VALUE = 0x12774118;   // Porsche
   dword    WERK_RBA_CBB_CKEY_VALUE = 0x86905668;  // Porsche
   dword    WERK_RBA_CBB_DKEY_VALUE = 0x21482338;  // Porsche

   dword    DEV_RBA_CBB_AKEY_VALUE  = 0x46947376; //Minicode 2721/2722
   dword    DEV_RBA_CBB_BKEY_VALUE  = 0x12774118;  // Porsche
   dword    DEV_RBA_CBB_CKEY_VALUE  = 0x86905668;  // Porsche
   dword    DEV_RBA_CBB_DKEY_VALUE  = 0x45982573;   // Porsche

   dword    RBEOLPin = 0x42444441; //It has been derived from the ASCII values of "Bosch Diagnostics for Driver Assistance"
   dword    PMARequest = 0x80FA1108; //Plant mode activation part request

   dword    keytemp;
   char    buffer[50],tempbuffer[50];
   Byte    ByteValue[1];
   int     IdentifierId;
   int     IdentifierValue;

   int      i;
   dword j,m,k;
   
   char     Seed[1024];
   byte     puffer[128];
   
   byte securityRespBuffer[1100];
   char pufferStr[2200];
   
   char temp[5];
   char IMBuffer[4];
   int responseLen;
  
    //*****************************************************************//
    byte First_MID[4096];  
    byte Last_MID[4096];
    char	MVbuffer[4096] = "";
    char	MVbuffer2[4096] = "";
    char  buffer2[4096]="0"; 
    char	MVbuffer5[4096] = "";
    char	MVbuffer6[4096] = "";
    char  buffer5[4096]="0";
    dword bufferSize;
    int RBflag1 =0;
    int RBflag2 = 0;
    
    strncpy(buffer2, "0", 4);
	  strncpy(MVbuffer2, "",4);
	  strncpy(MVbuffer, "",4);
    strncpy(buffer5, "0", 4);
	  strncpy(MVbuffer6, "",4);
	  strncpy(MVbuffer5, "",4);


  
    //**************************************************************// 
    
    EvaluateResponse( );  
   
    // write("coimgggggggggg %d ",CurrentDiagServ);
  
  if ( RxDataBuffer[0] == 0x67 && RxDataBuffer[1] == 0x61 && CurrentDiagServ == SEEDNKEYFBLREQUEST)
  {
    //    write("17=%d 18=%d 19=%d 20=%d 21=%d 22=%d 23=%d 24=%d ",gRxDataBuffer[17],gRxDataBuffer[18],gRxDataBuffer[19],gRxDataBuffer[20],gRxDataBuffer[21],gRxDataBuffer[22],gRxDataBuffer[23],gRxDataBuffer[24]);
    if( ( 0 == RxDataBuffer[17] ) &&
        ( 0 == RxDataBuffer[18] ) &&
        ( 0 == RxDataBuffer[19] ) &&
        ( 0 == RxDataBuffer[20] ) &&
        ( 0 == RxDataBuffer[21] ) &&
        ( 0 == RxDataBuffer[22] ) &&
        ( 0 == RxDataBuffer[23] ) &&
        ( 0 == RxDataBuffer[24] ) )
    {
      //write("CurrentDiagServ = SEEDNKEYFBLREQUEST");
      CurrentDiagServ = SEEDNKEYFBLREQUEST;
      sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_SeedOutputCAN, "Static Security Mode");
      //write("inside evaluate");
    }
    else
    {
      //write("CurrentDiagServ = SEEDNKEYFBLDYNAMICREQUEST");
      CurrentDiagServ = SEEDNKEYFBLDYNAMICREQUEST;
      sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_SeedOutputCAN, "Dynamic Security Mode");
    }
  }

   
  
 else if ( RxDataBuffer[0] == 0x67 && RxDataBuffer[1] == 0x03 && CurrentDiagServ == SEEDNKEYCUSTOMERREQUEST)
  {
    //    write("17=%d 18=%d 19=%d 20=%d 21=%d 22=%d 23=%d 24=%d ",gRxDataBuffer[17],gRxDataBuffer[18],gRxDataBuffer[19],gRxDataBuffer[20],gRxDataBuffer[21],gRxDataBuffer[22],gRxDataBuffer[23],gRxDataBuffer[24]);
    if( ( 0 == RxDataBuffer[17] ) &&
        ( 0 == RxDataBuffer[18] ) &&
        ( 0 == RxDataBuffer[19] ) &&
        ( 0 == RxDataBuffer[20] ) &&
        ( 0 == RxDataBuffer[21] ) &&
        ( 0 == RxDataBuffer[22] ) &&
        ( 0 == RxDataBuffer[23] ) &&
        ( 0 == RxDataBuffer[24] ) )
    {
      //write("CurrentDiagServ = SEEDNKEYCUSTOMERREQUEST");
      CurrentDiagServ = SEEDNKEYCUSTOMERREQUEST;
      sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_SeedOutputCAN, "Static Security Mode");
      //write("inside evaluate - 3");
    }
    else
    {
      write("CurrentDiagServ = SEEDNKEYCUSTOMERDYNAMICREQUEST");
      CurrentDiagServ = SEEDNKEYCUSTOMERDYNAMICREQUEST;
      sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_SeedOutputCAN, "Dynamic Security Mode");
    }
  }
  
    switch ( CurrentDiagServ )  
    {
     long copiedBytes;
      
     case READ_DTC_BY_ST:  
     case READ_DTC_BY_ST_RBEOL: 
     case READ_DTC_PASS:  
          if ( RxDataBuffer[0] == 0x59 )
          {
            RxBufferIndex  = 3;
            NrOfReadDTC    = (Length - 3)/4;  
            DtcNr        = 1; 
            for (i = 0; i < NrOfReadDTC; i++)
            {
                  errorDTC[DtcNr]      = (dword)RxDataBuffer[RxBufferIndex++] << 16;
                  errorDTC[DtcNr]      += (dword)RxDataBuffer[RxBufferIndex++] << 8;
                  errorDTC[DtcNr]      += (dword)RxDataBuffer[RxBufferIndex++]; 
                  errorStatus[DtcNr++] = RxDataBuffer[RxBufferIndex++];
			   
            }
            if ( (NrOfReadDTC == 0) )
            {
              sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "No DTCs");
            }else{
                   sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "All DTCs received");
                  }

               CurrentDTC = 1;
               ShowDTCs();
            }
          break;
            
      case SEEDNKEYJLRREQUEST: 
        
                
                //getvalue(EnvRxData_CAN,puffer);        
                sysGetVariableData(sysvar::DIAG_FVIDEO::sysDataReceived, puffer, copiedBytes);
                
                bin = 0x80;
                c_index=0;
                input[0] = puffer[2];
                input[1] = puffer[3];
                input[2] = puffer[4];
                input[3] = 0xef ;
                input[4] = 0xad;
                input[5] = 0x9c;
                input[6] = 0xc9;
                input[7] = 0x08;
                write("in resp code ");
                            
                write("seed%x%x%x",puffer[2],puffer[3],puffer[4]);
                for(i = 0; i < 24; i++)
                {
                    position_one[i]=init_array[i];
                }
            
                for(i = 0; i < 8; i++)
                {
                    for(j = 7; j >= 0; j--)
                    {
                        challenge[c_index + j] = input[i] & bin;
                        if(challenge[c_index + j] > 0)
                        {
                            challenge[c_index + j] = 1;
                        }
                        bin = bin >> 1;
                    }
                    bin = 0x80;
                    c_index+=8;
                }
                
                for(i = 0; i < 64; i++)
                {
                    position_two[23] = challenge[i] ^ position_one[0];
                    for(j = 0; j < 23; j++)
                    {
                        position_two[j] = position_one[j+1];
                    }
                    for(j = 0; j < 24; j++)
                    {
                        if(j == 3 || j == 5 || j == 12 || j == 15 || j == 20)
                        {
                            position_one[j] = position_two[j] ^ position_two[23];
                        }
                        else
                        {
                            position_one[j] = position_two[j];
                        }
                    }        
                }
                
                resultarra[0] = 0x27;
                resultarra[1] = SeednKeyJLREOLRequest[1] + 1;
                resultarra[2] = (byte)((position_one[11] * 8 + position_one[10] * 4 + position_one[9] *2 + position_one[8]) * 16 + (position_one[7] * 8 + position_one[6] * 4 + position_one[5] *2 + position_one[4]));
                resultarra[3] = (byte)((position_one[15] * 8 + position_one[14] * 4 + position_one[13] *2 + position_one[12]) * 16 + (position_one[23] * 8 + position_one[22] * 4 + position_one[21] *2 + position_one[20]));
                resultarra[4] = (byte)((position_one[3] * 8 + position_one[2] * 4 + position_one[1] *2 + position_one[0]) * 16 + (position_one[19] * 8 + position_one[18] * 4 + position_one[17] *2 + position_one[16]));
                write(" key cal %x%x%x%x%x",resultarra[0],resultarra[1],resultarra[2],resultarra[3],resultarra[4]);
                StartDiagService( SEEDNKEYRESP);
    break;
    
    case SEEDNKEYFBLREQUEST: 
      
                securityRespBuffer[0]='\0';
      
                //responseLen = getvalue(EnvRxData_CAN,securityRespBuffer);   
                responseLen = sysGetVariableData(sysvar::DIAG_FVIDEO::sysDataReceived, securityRespBuffer, copiedBytes);
                responseLen = copiedBytes;
                
                strncpy(pufferStr,"",elcount(pufferStr));//Reset/Clear
                strncpy(Seed,"",elcount(Seed));//Reset/Clear
                    
                //write("##############%x",securityRespBuffer[1]);
                for(i=0;i<responseLen;i++)
                {
                  ltoa(securityRespBuffer[i],IMBuffer,16);
                  
                  if( strlen( IMBuffer ) == 1 )
            			{
            				 IMBuffer[1] = IMBuffer[0];
                     IMBuffer[0] = '0';
                     strncat(pufferStr,IMBuffer,elcount(pufferStr));
            			}
            		  else
            			{
            				 strncat(pufferStr,IMBuffer,elcount(pufferStr));
            			}
                  
                }
               // write("############***%s",pufferStr);
                substr_cpy(Seed,pufferStr,6,-1,elcount(Seed));
                
                  //putValue(Env_Doip_Security_SeedOutputCAN,Seed);
                sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_SeedOutputCAN, Seed);
                
                toUpper(Seed,Seed,elcount(Seed));
                      
                for(i=0;i<100;i++)
                {
                  if(strncmp(seedList[i],Seed, elcount(Seed))==0)
                  {
                    break;
                  }
                  else if(100== i+1)
                  {
                    write("The Security XML doesnt have the required seed - key pair ");
                    i = -1;
                    break;
                  }
                }
                
                sendKey[0]='\0';
                
                if(i!=-1)
                {
                sendKey[0]=0x27;
                sendKey[1]=SeednKeyFBLRequest[1]+1;      
                k=2;  
                strncpy(temp, "0x",3);
                j=0;
                TxLength = (strlen(keyList[i])/2)+2;
                while(j<strlen(keyList[i]))
                {
                  temp[2]=keyList[i][j];
                  temp[3]=keyList[i][j+1];
                  temp[4]=0;
                  sendKey[k]=atol(temp);
                  k++;
                  j+=2;
                }
                sendKey[k]='\0';
                
                //write(" ^^^^^^^key len %d",k);
                if(securityRespBuffer[0] != 0x7F)
                  {
                      StartDiagService( SEEDNKEYJLRRESP);    
                  }
                }
                else
                {
                  //putValue(Env_Doip_SecurityMode_OutputCAN,"Seed Not found in XML");
                  sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN, "Seed Not found in XML");
                
                }
                break;
    
    case SEEDNKEYCUSTOMERREQUEST: 
      
    
      
    securityRespBuffer[0]='\0';
    //responseLen = getvalue(EnvRxData_CAN,securityRespBuffer);  
    responseLen = sysGetVariableData(sysvar::DIAG_FVIDEO::sysDataReceived, securityRespBuffer, copiedBytes);
    
    strncpy(pufferStr,"",elcount(pufferStr));
    strncpy(Seed,"",elcount(Seed));
        
    //write("##############%x",securityRespBuffer[1]);
    for(i=0;i<responseLen;i++)
    {
      ltoa(securityRespBuffer[i],IMBuffer,16);
      
      if( strlen( IMBuffer ) == 1 )
			{
				 IMBuffer[1] = IMBuffer[0];
         IMBuffer[0] = '0';
         strncat(pufferStr,IMBuffer,elcount(pufferStr));
			}
		  else
			{
				 strncat(pufferStr,IMBuffer,elcount(pufferStr));
			}
      
    }
  // write("############***%s",pufferStr);
    substr_cpy(Seed,pufferStr,6,-1,elcount(Seed));
    
      //putValue(Env_Doip_Security_SeedOutputCAN,Seed);
    sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_SeedOutputCAN, Seed);
    
    toUpper(Seed,Seed,elcount(Seed));
          
    for(i=0;i<100;i++)
    {
      if(strncmp(seedListCUST[i],Seed, elcount(Seed))==0)
      {
        break;
      }
      else if(100== i+1)
      {
        write("The Security XML doesnt have the required seed - key pair ");
        i = -1;
        break;
      }
    }
    
    sendKey[0]='\0';
    
    if(i!=-1)
    {
    sendKey[0]=0x27;
    sendKey[1]=SeednKeyCustomerRequest[1]+1;      
    k=2;  
    strncpy(temp, "0x",3);
    j=0;
    TxLength = (strlen(keyListCUST[i])/2)+2;
    while(j<strlen(keyListCUST[i]))
    {
      temp[2]=keyListCUST[i][j];
      temp[3]=keyListCUST[i][j+1];
      temp[4]=0;
      sendKey[k]=atol(temp);
      k++;
      j+=2;
    }
    sendKey[k]='\0';
    
   // write(" ^^^^^^^key len %d",k);
    write("inside case for seed");
    
    if(securityRespBuffer[0] != 0x7F)
    {
    
    StartDiagService( SEEDNKEYJLRRESP); 
      
    }
    }
    else
    {
      //putValue(Env_Doip_SecurityMode_OutputCAN,"Seed Not found in XML");
      sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN, "Seed Not found in XML");
    
    }
    break;
    
    case SEEDNKEYFBLDYNAMICREQUEST:
      
        
            //responseLen = getvalue(EnvRxData_CAN,securityRespBuffer);
            responseLen = sysGetVariableData(sysvar::DIAG_FVIDEO::sysDataReceived, securityRespBuffer, copiedBytes);
            strncpy(pufferStr,"",elcount(pufferStr));
            for(i=0;i<responseLen;i++)
            {
              ltoa(securityRespBuffer[i],IMBuffer,16);
              if( strlen( IMBuffer ) == 1 )
			        {
				        IMBuffer[1] = IMBuffer[0];
                IMBuffer[0] = '0';
                strncat(pufferStr,IMBuffer,elcount(pufferStr));
			        }
		          else
			        {
				        strncat(pufferStr,IMBuffer,elcount(pufferStr));
			        }
              
            }
            substr_cpy(Seed,pufferStr,6,-1,elcount(Seed));
            
         //   write(" ^^^ %s",Seed);
         //   write(" ^^^ %s",pufferStr);
            
            if(securityRespBuffer[0] != 0x7F)
            {
             //putValue(Env_Doip_Security_SeedOutputCAN,Seed);
             sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_SeedOutputCAN, Seed);
             setTimer(sectimer1,1000);
            }
            
            DynamicFlag = 1;
            DynamicKeyAutoGenerate(Seed);
            break;
      
      case SEEDNKEYCUSTOMERDYNAMICREQUEST:
      
        
            //responseLen = getvalue(EnvRxData_CAN,securityRespBuffer);
            responseLen = sysGetVariableData(sysvar::DIAG_FVIDEO::sysDataReceived, securityRespBuffer, copiedBytes);
            strncpy(pufferStr,"",elcount(pufferStr));
            for(i=0;i<responseLen;i++)
            {
              ltoa(securityRespBuffer[i],IMBuffer,16);
              if( strlen( IMBuffer ) == 1 )
			        {
				        IMBuffer[1] = IMBuffer[0];
                IMBuffer[0] = '0';
                strncat(pufferStr,IMBuffer,elcount(pufferStr));
			        }
		          else
			        {
				        strncat(pufferStr,IMBuffer,elcount(pufferStr));
			        }
              
            }
            substr_cpy(Seed,pufferStr,6,-1,elcount(Seed));
            
      //      write(" ^^^ %s",Seed);
       //     write(" ^^^ %s",pufferStr);
            
            if(securityRespBuffer[0] != 0x7F)
            {
             //putValue(Env_Doip_Security_SeedOutputCAN,Seed);
             sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_SeedOutputCAN, Seed);
             setTimer(sectimer1,1000);
            }
            
            DynamicFlag = 3;
            DynamicCustomerKeyAutoGenerate(Seed);
            break;
            
      case SEEDNKEYJLRDYNAMICREQUEST:
        
            //responseLen = getvalue(EnvRxData_CAN,securityRespBuffer);
            responseLen = sysGetVariableData(sysvar::DIAG_FVIDEO::sysDataReceived, securityRespBuffer, copiedBytes);
            for(i=0;i<responseLen;i++)
            {
              ltoa(securityRespBuffer[i],IMBuffer,16);
              if( strlen( IMBuffer ) == 1 )
			        {
				        IMBuffer[1] = IMBuffer[0];
                IMBuffer[0] = '0';
                strncat(pufferStr,IMBuffer,elcount(pufferStr));
			        }
		          else
			        {
				        strncat(pufferStr,IMBuffer,elcount(pufferStr));
			        }
              
            }
            substr_cpy(Seed,pufferStr,6,-1,elcount(Seed));
            
             if(securityRespBuffer[0] != 0x7F)
            {
             //putValue(Env_Doip_Security_SeedOutputCAN,Seed);
              sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_SeedOutputCAN, Seed);
             setTimer(sectimer1,1000);
            }
            
            DynamicFlag = 2;
            break;
            
      case SEEDNKEYJLREOLREQUEST: 
        
    //responseLen = getvalue(EnvRxData_CAN,securityRespBuffer);
    responseLen = sysGetVariableData(sysvar::DIAG_FVIDEO::sysDataReceived, securityRespBuffer, copiedBytes);
    strncpy(pufferStr,"",elcount(pufferStr));
    strncpy(Seed,"",elcount(Seed));
        
    for(i=0;i<responseLen;i++)
    {
      ltoa(securityRespBuffer[i],IMBuffer,16);
      
      if( strlen( IMBuffer ) == 1 )
			{
				 IMBuffer[1] = IMBuffer[0];
         IMBuffer[0] = '0';
         strncat(pufferStr,IMBuffer,elcount(pufferStr));
			}
		  else
			{
				 strncat(pufferStr,IMBuffer,elcount(pufferStr));
			}
    
    }
    write("%s",pufferStr);
    substr_cpy(Seed,pufferStr,6,-1,elcount(Seed));
    
    if(securityRespBuffer[0] != 0x7F)
    {
      //putValue(Env_Doip_Security_SeedOutputCAN,Seed);
      sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_SeedOutputCAN, Seed);
    }
    
    toUpper(Seed,Seed,elcount(Seed));
          
    for(i=0;i<100;i++)
    {
      if(strncmp(seedListJLR[i],Seed, elcount(Seed))==0)
      {
        break;
      }
      else if(100== i+1)
      {
        write("The Security XML doesnt have the required seed - key pair ");
        i = -1;
        break;
      }
    }
    
    if(i!=-1)
    {
    sendKey[0]=0x27;
    sendKey[1]=SeednKeyJLREOLRequest[1]+1;
    k=2;  
    
    strncpy(temp, "0x",3);
    j=0;
    TxLength = (strlen(keyListJLR[i])/2)+2;
    
    while(j<strlen(keyListJLR[i]))
    {
      temp[2]=keyListJLR[i][j];
      temp[3]=keyListJLR[i][j+1];
      temp[4]=0;
      sendKey[k]=atol(temp);
      k++;
      j+=2;
    }
    sendKey[k]='\0';    
    StartDiagService( SEEDNKEYJLRRESP);
    }
     break;  

            
      /*
      case VIN_LEARN_STATUS:
      
             if(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x01)
             {
                putvalue(Env_VIN_Display,"Specified VIN already stored");
             }
             else if(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x00)
				     {
					      putvalue(Env_VIN_Display,"VIN Learn Successful");
				     } 
             else if(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0xFF)
				     {
					      putvalue(Env_VIN_Display,"VIN Learn Not Successful");
				     }
            else
            {
                putvalue(Env_VIN_Display,"Unknown Status");
            }
      break;
            
      case VIN_LEARN_START:
      
             if(RxDataBuffer[0] == 0x71 && RxDataBuffer[4] == 0x7B)
             {
                putvalue(Env_VIN_Display,"VIN Learn started");
             }  
             else
             {
                putvalue(Env_VIN_Display,"Unknown Status");
             }
      break;
            
      case VIN_LEARN_STOP:
      
             if(RxDataBuffer[0] == 0x71 && RxDataBuffer[4] == 0x7A)
             {
                putvalue(Env_VIN_Display,"VIN Learn Stopped");
             }  
             else if(RxDataBuffer[0] == 0x71 && RxDataBuffer[4] == 0x78)
             {
                putvalue(Env_VIN_Display,"VIN Learn Stopped before completion");
             }
             else
             {
                putvalue(Env_VIN_Display,"Unknown Status");
             }
      break;
      
            
      case SEEDNKEYJLRREQUEST: 
                Seed_buf[0] = RxDataBuffer[2];
                Seed_buf[1] = RxDataBuffer[3];
                Seed_buf[2] = RxDataBuffer[4];
                Key_Calculation();
                StartDiagService( SEEDNKEYRESP);
         break;     
    case ALIGNMENT_RUN_STATUS:
    case ALIGNMENT_STATUS:
          //write("^^^^^^^^ %x %x %x",RxDataBuffer[0],RxDataBuffer[3],RxDataBuffer[5]);
      
          if((RxDataBuffer[3] != 0x0F)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] != 0x0F))
          {
             if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x09)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x09))
             {
                sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Target Not Found");
             }
             else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x07)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x07))
				     {
					      sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Alignment Successful");
				     }
				     else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x08)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x08))
				     {
					      sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Alignment Aborted");
				     }
             else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x0A)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x0A))
				     {
					      sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Invalid Input Value");
				     }
             else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x06)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x06))
				     {
					      sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Alignment Not Executed");
				     }
             else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x0B)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x0B))
				     {
					      sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Horizontal Bad Angle");
				     }
             else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x0C)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x0C))
				     {
					      sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Vertical Bad Angle");
				     }
				     else
				     {
					      sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Unknown Error");
				     }
                  cancelTimer(alignmentTimer);
        }
				else
				{
					sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Alignment in progress");
				}
				
	  break;*/
	case ALIGNMENT_START:
              Alignment_start_Evaluate();
							break;
	case ALIGNMENT_STOP:
              Alignment_stop_Evaluate();
							break;
	case ALIGNMENT_STATUS:
              Alignment_status_Evaluate();
							break;
	case ALIGNMENT_MEAR_RES:
              Alignment_Current_Value_Read_Evaluate();
							break;
	case ALIGNMENT_DATA_R:
              Alignment_Data_Read_Evaluate();
							break;
	case ALIGNMENT_DATA_W:
              Alignment_Data_Write_Evaluate();
							break;
	case ALIGNMENT_TOL_R:
              Alignment_Data_Read_Evaluate();
							break;
	case ALIGNMENT_TOL_W:
              Alignment_Data_Write_Evaluate();
							break;
	case ALIGNMENT_CURR_VAL:
              Alignment_Current_Value_Read_Evaluate();
							break;
  case ITC_READ:  
              parseITCData(RxDataBuffer,Length);
              break;
  case READ_BOSCH_CODING:
              Bosch_coding_Read_Evaluate();
							break;
  case WRITE_BOSCH_CODING:
              Bosch_coding_Write_Evaluate();
							break;
  case SEEDNKEYBOSCHREQUEST: 
              Bosch_seed_req_Evaluate();
              break; 
  case SEEDNKEYBOSCHRESP: 
              Bosch_key_req_Evaluate();
              break; 
  case SEEDNKEYPSAREQUEST: 
              PSA_seed_req_Evaluate();
							break; 
  case SEEDNKEYPSARESP: 
              PSA_key_req_Evaluate();
							break; 
	  /*
	  case READ_BOSCH_CODING:
        for(i = 0; i<elcount(BoschCodingBuffer); i++)
    		{
    			BoschCodingBuffer[i] = RxDataBuffer[i];
    		}
    		
    		BoschCodingRead(RxDataBuffer);
    		break;
  */
  }

}  

/** @brief this is function for Evalualate diag resonse and put 
into panel
* @return int data
*/

int EvaluateResponse()
{  
   int ret; 
   ret = 0;

   if ( RxDataBuffer[0] == 0x7F )
   {
   
      switch ( RxDataBuffer[2] ) 
      {
         case 0x10:
                  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "General reject");
                  break;

         case 0x11: 
                  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Service not supported");
                  break;

         case 0x12: 
                  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "SubFunction Not Supported");
                  break;

         case 0x13: 
                  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, " InCorrect Message Length-invalid Format");
                  break;

         case 0x21: 
                  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Busy Repeat Request");
                  break;

         case 0x22: 
                  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Conditions Not Correct");
                  break;

     //    case 0x23: 
     //           sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Routine not complete");
     //           break;

         case 0x24: 
                  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Request Sequence Error");
                  break;

         case 0x26: 
                  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Failure Prevents Execution of requested action");
				  break;

         case 0x31: 
				  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Request Out Of Range");
				  break;

         case 0x33: 
				  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Security Access Denied");
				  break;

         case 0x35: 
				  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Invalid key");
				  break;

         case 0x36: 
				  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Exceed number of attempts");
				  break;

         case 0x37: 
				  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Time delay not expired");
				  break;

         case 0x78: 
				  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Request Correctly Received-Response Pending");
				  // Wait
				  ret = 0; 
				  break;

      //   case 0x80: 
      //      sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Service not supported in active mode");
      //   break;

         case 0x7E: 
				  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "SubFunction Not Supported In Active Diagnostic Session");
				  break;

         case 0x7F: 
				  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Service Not Supported In Active Diagnosic Session");
				  break;
             
         case 0x83: 
				  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Condition not correct - Engine running");
				  break;
         
         case 0x88: 
				  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Vehicle Speed Too High");
				  break;

         case 0x89: 
				  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Negative Response:ESP_v_Signal<= 50 km/h");
				  break;
         
        case 0x93:
				  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "VoltageTooLow");
				  break;

        case 0x92:
				  sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "VoltageTooHigh");
				  break;


         default:   
				 sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status, "Negative Response: Acknowledge not defined");
				 break;
         }
   }
   else
   {
      if ( RxDataBuffer[0] == ( SId + 0x40 ) )        
      {
         // Positive response
         sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status,"OK! Positive response");
         ret = 1; 
      }
      else                      
      {
        sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_Status ,"Unknown response");
        ret = 0; 
      }
   }

   return ( ret ); 
}

/** @brief this is function for send CANTP
* Into arguments void
* @return void data
*/

void TransmitTxBuffer (void)
{ 
  // OSEK TP supports up to 4 GiB with Jumbo frames, but limit that to a much lower value for this demo
  int fd_dlc;
  int temp_sysMaxFDFrameLen;
  temp_sysMaxFDFrameLen = @sysvar::DIAG_FVIDEO::GeneralSettings::sysMaxFDFrameLen;
  
  if (TxLength > kBufferSizeJumbo)
      TxLength = kBufferSizeJumbo;
  
  fd_dlc=TxLength+2;
  
  if((fd_dlc>8) && (fd_dlc<13))
    set_sysMaxFDFrameLen(12);
  else if((fd_dlc>12) && (fd_dlc<17))
    set_sysMaxFDFrameLen(16);
  else if((fd_dlc>16) && (fd_dlc<21))
    set_sysMaxFDFrameLen(20);
  else if((fd_dlc>20) && (fd_dlc<25))
    set_sysMaxFDFrameLen(24);
  else if((fd_dlc>24) && (fd_dlc<33))
    set_sysMaxFDFrameLen(32);
  else if((fd_dlc>32) && (fd_dlc<49))
    set_sysMaxFDFrameLen(48);
  else if((fd_dlc>48) && (fd_dlc<64))
    set_sysMaxFDFrameLen(64);
  
  writeDbgLevel(1,"%s, connection %d: Send request for %d data bytes",gECU, kIdTester1, TxLength);

  setTimerCyclic(tFlashTxLEDTester1, kDuration_LEDFlash_ms);
  setTimer(tSwitchOffTxLEDTester1, kDuration_RxLEDFlashOff_ms);

  CanTpSendData(gHandleTester1, TxDataBuffer, TxLength);
 
	if(TxDataBuffer[0] != 0x3E)
  {
    sysSetVariableData(sysvar::DIAG_FVIDEO::sysDataReceived,emptyString,0);
    sysSetVariableInt(sysvar::DIAG_FVIDEO::sysNoOfBytesReceived,0);
    sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataReceived_String,"");// delete old value from receive 

    sysSetVariableData(sysvar::DIAG_FVIDEO::sysDataToTransmit,TxDataBuffer,TxLength);
  }
	SId = TxDataBuffer[0];
  
  @sysvar::DIAG_FVIDEO::GeneralSettings::sysMaxFDFrameLen=temp_sysMaxFDFrameLen;//Reset
}


/** @brief this is function to get response time 
* Into arguments status
* @param status Osektp status
*/

OSEKTL_DataCon(long status)
{
	if (status != 0) 
	{
		RespTime = ( (float) timeNow() * (-1.0) );	
       	
	}
	else
	{
		write("Tx error, status is %d", status);
	}
}

/** @brief This on system variable to decide whether tester data to 
send or not
*/

on sysvar_update sysvar::DIAG_FVIDEO::SESSION::TESTER_PRESENT
{ 
    if ( @this ) 
    {
        StartDiagService( TESTER_PRESENT_ON );
        setTimer (TesterPresentTimer, FirstTesterPresentTime);//First time
    }
    else
    {
        cancelTimer (TesterPresentTimer);
    } 
}

on timer TesterPresentTimer
{
   StartDiagService( TESTER_PRESENT_ON );
   // reStart timer
   setTimer (TesterPresentTimer, TesterPresentTime);
} 

/** @brief This on system variable to send default session on diag
*/

on sysvar_update sysvar::DIAG_FVIDEO::SESSION::DEF_SESS
{ 
    if ( @this ) 
    {
      StartDiagService( DEFAULT_SESSION );
    }
     
}

/** @brief This on system variable to send programming session on diag
*/

on sysvar_update sysvar::DIAG_FVIDEO::SESSION::PRO_SESS
{ 
    if (@this ) 
    {
      StartDiagService( PROGRAM_SESSION );
    }
    
}

/** @brief This on system variable to send Extended session on diag
*/

on sysvar_update sysvar::DIAG_FVIDEO::SESSION::EXT_SESS
{ 
    if ( @this ) 
    {
      StartDiagService( EXTENDED_SESSION );
    }  
}

/** @brief This on system variable to send Bosch session on diag
*/

on sysvar_update sysvar::DIAG_FVIDEO::SESSION::BOS_SESS
{ 
    if ( @this ) 
    {
      StartDiagService( BOSCH_SESSION );
    }  
}

/** @brief This on system variable to Hard reset on diag
*/

on sysvar_update sysvar::DIAG_FVIDEO::ECU_RESET::Hard_Rest
{ 
    if ( @this ) 
    {
      StartDiagService( ECU_HARD_RESET );
    }
     
}

/** @brief This on system variable to soft reset on diag
*/

on sysvar_update sysvar::DIAG_FVIDEO::ECU_RESET::Soft_Rest
{ 
    if ( @this ) 
    {
      StartDiagService( ECU_SOFT_RESET );
    }
     
}
/*
on timer readDtcTimer
{
    int i;
    readTimeValue+=CNTR_VALUE;

    if (readTimeValue < 1000)   //try to read until 1000ms
    {
        //putValue(EnvDirectSend,readString);
		TxLength = (requestSize - 1)/2;
        for (i=0; i<TxLength; i++) TxDataBuffer[i]=readRequest[i];
        TransmitTxBuffer();


        strncpy(DTCValue,ErrString,strlen(ErrString)+1);
        //write("At %f DTCValue=%s",timeNowFloat()/100000,DTCValue);

        // if NOT "Busy Repeat Request", NOT "OK", NOT "Response Pending"
        if ( strncmp(DTCValue,"7f1921",6)!=0 &&     
             strncmp(DTCValue,"54",2)    !=0 &&
             strncmp(DTCValue,"7f1978",6)!=0 &&
             strlen(DTCValue)            !=0 )      
        {
            putValue(EnvErrValueOutput,DTCValue);
        } 
        else
        {
            //else (if "Busy...") do nothing
        }

        setTimer(readDtcTimer,CNTR_VALUE);
    }
    else  // time elapsed
    {
        cancelTimer(readDtcTimer);
        if (getValue(EnvErrValueOutput,DTCValue)==0)
        {
            putValue(EnvErrValueOutput,"No answer received.");
        }

        //syncronise the environmental variables
        putValue(EnvErrValueOutput,DTCValue);
        //write("***At %f EnvErrValueOutput= %s",timeNowFloat()/100000,DTCValue);

    }

}

on sysvar sysvar::DIAG_FVIDEO::DTC_INFO::DTC_SetReadDTC
{
    int i;

    getValue(this,readString);

    if (strlen(readString)!=0) {

        //initialization
        requestSize = getValueSize(EnvSetReadDTC);
        strncpy(DTCValue,"",255);
        readTimeValue=0;
        putValue(EnvErrValueOutput,"");
        for (i=0;i<2048;i++) ErrValue[i]=0;
        //write("***At %fs (timer=%ims) request= %s",timeNowFloat()/100000,CNTR_VALUE,readString);

        //start timer at first time
        setTimer(readDtcTimer,CNTR_VALUE);

    } //end if
    //putValue(EnvDirectSend,readString);

	//getValue(EnvSetReadDTC,readString);
	if( strlen(readString) == 0 )
	{
		//write("Variable neu initialisiert");
		//putValue(EnvSendBuffer_1,0);
	}
	else
	{
		strncpy(tempString, "0x",3);

		for(i=0; i<= requestSize-3; i+=2)
		{
			tempString[2] = readString[i];
			tempString[3] = readString[i+1];
			tempString[4] = 0;
			readRequest[i/2] = atol( tempString );
		}
		//putValue(EnvTxData_1CAN, TransmitBuffer, length);
		//putValue(EnvTransferCAN, length);
		//putValue(EnvSendBuffer_1,1);

		TxLength = (requestSize - 1)/2;
        for (i=0; i<TxLength; i++) TxDataBuffer[i]=readRequest[i];
        TransmitTxBuffer();
	}

    putValue(EnvSetReadDTC,"");

}
*/

/** @brief This on system variable to read DTC informatiom
*/

on sysvar_update sysvar::DIAG_FVIDEO::DTC_INFO::DTC_Read
{ 
    if ( @this ) 
    {
        ClearDtcDisplay();
        StartDiagService( READ_DTC_BY_ST );
    }
}

/** @brief This on system variable to clear read DTC informatiom
*/

on sysvar_update sysvar::DIAG_FVIDEO::DTC_INFO::DTC_Clear
{ 
    if ( @this ) 
    {
      StartDiagService( CLEAR_DTC );
	    ClearDtcDisplay();
    }
}

/** @brief This on system variable to scrolling down DTC information over 
panel
*/

on sysvar_update sysvar::DIAG_FVIDEO::DTC_INFO::DTC_CountDown
{ 
    if ( @this ) 
    {
            CurrentDTC--;
            ShowDTCs(); 
        }
}

/** @brief This on system variable to scrolling up DTC information over 
panel
*/

on sysvar_update sysvar::DIAG_FVIDEO::DTC_INFO::DTC_CountUP
{ 
    if ( @this ) 
    {
            CurrentDTC++;
            ShowDTCs(); 
        }
}

/** @brief this is function for Get DTC Name
* Into arguments error,DTC_or_historical
* @param error DTC name
* @param  DTC_or_historical  it is new DTC or historical DTC
* @return void data
*/

void GetDtcName (dword error,int DTC_or_historical)
{	
	char DTCText [256] = "";
  long res;
  int v;

  // Hole DTC Beschreibung aus Tabelle
  // res=GetDTCdescription_Kamera(error, DTCText);
  
  for (v = 0; v < elcount(DTCText); v++)
  {
      DTCText[v] = ' ';
  }
  
  res=GetDTCdescription(error, DTCText);
   
  write("GetDtcName::%d",res);
  if(res == 0) // DTC in Tabelle nicht gefunden
  {
      snprintf( DTCText, 255,"Unknown Error: %d",error);
  }

 	if (DTC_or_historical==1)  //ReadDTC
	{
    write("DTCText::%s",DTCText);
		res=sysSetVariableString(sysvar::DIAG_FVIDEO::DTC_INFO::DTC_Name,DTCText);
	}
   
}

/** @brief this is function for Get DTC Descrtption from excel file
* Into arguments error,DTCText
* @param error DTC name
* @param  DTCText  buffer of DTC text
* @return long data
*/

long GetDTCdescription(dword error, char DTCText[])
{
  char str1[100]; 
  char str[100]; 
  long pos;
  int k, m;
  filehandle = 0;
  k = 0;
  
  ltoa(error, str1, 16); // dword to string
  toUpper(str, str1, elcount(str));
  
  filehandle = openFileRead(path, 0);

  if (filehandle != 0) 
  {   
     while (fileGetString(buffer, elcount(buffer), filehandle) != 0) // till end of file ...
  	 {        
         pos = strstr(buffer, str);
      	 
         if (pos != -1)
         {
          	 for (i = pos; i > 0 ; i--)
             {
                if (buffer[i] == ';')
                {
                    for (j = i-1; j > 0; j--)
                    {
                        if (buffer[j] != ';')
                				{
                           continue;
                        }
                        else
                        {
                           break;
                        }
                    }
                    
                    for (m = j+1; m <= i-1; m++)
                    {
                        DTCText[k++] = buffer[m];
                    }
                    
                    return 1;
                }               
          	  }	  
          }
      }
  }
  
  return 0;  
}

/** @brief this is function for clearDTC on display
* @return void data
*/

void ClearDtcDisplay (void)
{
   NrOfReadDTC = 0;
   CurrentDTC  = 0;
  
   ShowDTCs();
}

/** @brief this is function for showdtc on display
* @return void data
*/

void ShowDTCs (void)
{
   char buffer[50];
   long buffer_dec;
   
   if ( CurrentDTC > NrOfReadDTC )
   {
      CurrentDTC = NrOfReadDTC;
   } 
   else if ( (CurrentDTC < 1) && (NrOfReadDTC) )
   {
      CurrentDTC = 1;
   }
   else if ( (CurrentDTC < 0) && (!NrOfReadDTC) )
   {
      CurrentDTC = 0;
   } 

   snprintf (buffer, 49, "%02d/%02d", CurrentDTC, NrOfReadDTC);
   sysSetVariableString(sysvar::DIAG_FVIDEO::DTC_INFO::DTC_Position,buffer);

   if ( CurrentDTC )
   {
      // DTC No
      snprintf (buffer, 49, "%06x",   errorDTC[CurrentDTC]);
      sysSetVariableString(sysvar::DIAG_FVIDEO::DTC_INFO::DTC_Nr,buffer);

      //DTC Status
      snprintf (buffer, 49, "%02x", errorStatus[CurrentDTC]);
      sysSetVariableString(sysvar::DIAG_FVIDEO::DTC_INFO::DTC_State,buffer);
      GetDtcName (errorDTC[CurrentDTC],1);
      

   }
   else
   {
      sysSetVariableString(sysvar::DIAG_FVIDEO::DTC_INFO::DTC_Nr,"----");
      sysSetVariableString(sysvar::DIAG_FVIDEO::DTC_INFO::DTC_State,"--");
      sysSetVariableString(sysvar::DIAG_FVIDEO::DTC_INFO::DTC_Name,"----");
   } 

}

/** @brief this is function for to create string representation of 
(bin)ErrValue[] in (char)ErrString[]
* Into arguments length
* @param length length of rx string
* @return void data
*/

FillErrString (int length)
{
  //to create string representation of (bin)ErrValue[] in (char)ErrString[]

  char temp[3];
  int i;
  strncpy(ErrString,"",0);
  if (length!=0)
  {
  for (i=0;i<length;i++) 
      {
      strncpy(tempString,"",0);
      ltoa(ErrValue[i],temp,16);
      if (strlen(temp)==1) strncpy(tempString,"0",2);
      strncat(tempString,temp,(strlen(tempString)+strlen(temp))+1);
      //if (i<10) write("%d.%s->%s",i,temp,tempString);
      strncat(ErrString,tempString,strlen(tempString)+strlen(ErrString)+1);
      }
  length=0;
  //write("***At %f ErrString= %s",timeNowFloat()/100000,ErrString);
  }


}

//on timer ActPMode
//{
//    StartDiagService( P_MODE_ACT_P2 );
//}

/*

on timer UpdateRuntime
{
	StartDiagService( GET_SYS_RUNTIME );
	SetTimer( UpdateRuntime, UpdateCycle);
}


on start
{
    defaultsec[0] = 0x61;
    putvalue(Env_Doip_Security_SubFunctionCAN,defaultsec);
    defaultsec[0] = 0x01;
    putvalue(Env_Doip_Security_SubFunction2CN,defaultsec);
    // Default Suche nach DTC 000124
    putValue(Env_ITC_Display,"");
    putValue(Env_VIN_Display,"");
    putValue(Env_Alignment_Display,"");
    putValue(EnvTesterPresentOnOffCAN,0);
  
}

On envVar Env_VINLearn
{
  if ( getValue (this) )
  {
     putvalue(Env_JLRSecurity_CCM,1);
     setTimer(VINTimer,300);
     VINFlag = 1;
  }
}

On envVar Env_VINLearn_Stop
{
  if ( getValue (this) )
  {
     putvalue(Env_JLRSecurity_CCM,1);
     setTimer(VINTimer,300);
     VINFlag = 2;
  }
}

On envVar Env_VINLearn_Status
{
  if ( getValue (this) )
  {
     putvalue(Env_JLRSecurity_CCM,1);
     setTimer(VINTimer,300);
     VINFlag = 3;
  }
}
*/
on timer VINTimer
{
  /*
  if(VINFlag == 1)
  {
    StartDiagService( VIN_LEARN_START );
  }
  else if(VINFlag == 2)
  {
    StartDiagService( VIN_LEARN_STOP );
  }
  else if(VINFlag == 3)
  {
    StartDiagService( VIN_LEARN_STATUS );
  }
  else if(VINFlag == 4)
  {
    StartDiagService( ECU_HARD_RESET );
  }
  else */
}

on timer alignmentTimer
{
  switch(ALIGNFlag)
  {
    case 1:
          StartDiagService( ALIGNMENT_START );
          break;
    case 2:
          StartDiagService( ALIGNMENT_STOP );
          break;
    case 3:
          StartDiagService( ALIGNMENT_STATUS );
          break;
    case 4:
          StartDiagService(ALIGNMENT_RUN_STATUS);
          break;
  }
  ALIGNFlag=0;//Reset
  /*
  if((ALIGNFlag!=0) && (ALIGNFlag!=4))
  {
    ALIGNFlag=4;
    setTimerCyclic(alignmentTimer,500);
  }
  */
}

/*
on envVar Env_JLRSecurity_CCM
{
   if ( getValue (this) )
    {
        
      StartDiagService( EXTENDED_SESSION );
      setTimer(JLRUnlockTimer,100);
      putvalue(Env_JLRSecurity_CCM,0);
    }
}

On timer JLRUnlockTimer
{
  StartDiagService( SEEDNKEYJLRREQUEST );
}

on envVar Env_BoschCoding_Read
{
	if ( getValue (this) )
    {
      StartDiagService( READ_BOSCH_CODING );
    }
}

on envVar Env_BoschCoding_Write
{
	if ( getValue (this) && (BoschCodingBuffer[0] == 0x62))
    {
		BoschCodingWrite();
		for(i = 0; i<elcount(BoschCodingBuffer);i++)
		{
			TxDataBuffer[i] = BoschCodingBuffer[i];
		}
		StartDiagService( WRITE_BOSCH_CODING );
    }
}

CalculateKey (dword SeedValue,dword RBA_CBB_AKEY_VALUE, dword RBA_CBB_BKEY_VALUE, dword RBA_CBB_CKEY_VALUE, dword RBA_CBB_DKEY_VALUE)
{

        int      j;
        dword    keytemp;
      
        
        	keyReprogValue = SeedValue;

        	for(j = 0; j <8 ; j++)
        	{

            	keytemp = keyReprogValue ;
            	keyReprogValue = keyReprogValue + RBA_CBB_AKEY_VALUE;
	       		  // write(" keytemp and keyReprogValue  for j value %i beginning loop: %lx, %lx ",j, keytemp, keyReprogValue );    
    
    			if((keyMaxReprogValue - RBA_CBB_AKEY_VALUE) < keytemp)
    			{
    	  		//Rotate Right by 10 
 	       		keyLowReprogValue = keyReprogValue & (0x000001FF);
 	    			keyUpperReprogValue = keyLowReprogValue << 23;
 	    			keyReprogValue = keyReprogValue >> 9;
 	    			keyReprogValue = keyReprogValue | keyUpperReprogValue;
       			keyReprogValue = keyReprogValue ^ RBA_CBB_BKEY_VALUE;

           }
    			else
    			{
 	    		//Rotate Left by 13 
 	    		  keyUpperReprogValue = keyReprogValue & (0xFFF80000);
 			      keyLowReprogValue   = keyUpperReprogValue >> 19;
 			    	keyReprogValue      = keyReprogValue << 13;
		 	    	keyReprogValue      = keyReprogValue | keyLowReprogValue;
		        keyReprogValue      = keyReprogValue ^ RBA_CBB_CKEY_VALUE;

           }
         }
 
         keyReprogValue = keyReprogValue - RBA_CBB_DKEY_VALUE;
              
           
         //Key Algo end 
			    //   write(" final  keyReprogValue %lx",keyReprogValue ); 
}

void BoschCodingWrite()
{
	BoschCodingBuffer[0] = 0x2E;
	BoschCodingBuffer[1] = 0xFD;
	BoschCodingBuffer[2] = 0x07;

	BoschCodingBuffer[9] = @Env_DMonitoring_1>>8;
	BoschCodingBuffer[10] = @Env_DMonitoring_1;
	
	BoschCodingBuffer[11] = @Env_DMonitoring_2>>8;
	BoschCodingBuffer[12] = @Env_DMonitoring_2;
	
	BoschCodingBuffer[13] = @Env_DMonitoring_3>>8;
	BoschCodingBuffer[14] = @Env_DMonitoring_3;
	
	BoschCodingBuffer[15] = @Env_DMonitoring_4>>8;
	BoschCodingBuffer[16] = @Env_DMonitoring_4;
	
	BoschCodingBuffer[17] = @Env_DMonitoring_5>>8;
	BoschCodingBuffer[18] = @Env_DMonitoring_5;
	
	BoschCodingBuffer[19] = @Env_DMonitoring_6>>8;
	BoschCodingBuffer[20] = @Env_DMonitoring_6;
	
	BoschCodingBuffer[21] = @Env_DMonitoring_7>>8;
	BoschCodingBuffer[22] = @Env_DMonitoring_7;
	
	BoschCodingBuffer[23] = @Env_DMonitoring_8>>8;
	BoschCodingBuffer[24] = @Env_DMonitoring_8;
	
	BoschCodingBuffer[25] = @Env_DMonitoring_9>>8;
	BoschCodingBuffer[26] = @Env_DMonitoring_9;
	
	BoschCodingBuffer[27] = @Env_DMonitoring_10>>8;
	BoschCodingBuffer[28] = @Env_DMonitoring_10;
	
	BoschCodingBuffer[29] = @Env_DMonitoring_11>>8;
	BoschCodingBuffer[30] = @Env_DMonitoring_11;
	
	BoschCodingBuffer[31] = @Env_DMonitoring_12>>8;
	BoschCodingBuffer[32] = @Env_DMonitoring_12;
	
	BoschCodingBuffer[33] = @Env_DMonitoring_13>>8;
	BoschCodingBuffer[34] = @Env_DMonitoring_13;
	
	BoschCodingBuffer[35] = @Env_DMonitoring_14>>8;
	BoschCodingBuffer[36] = @Env_DMonitoring_14;
	
	BoschCodingBuffer[37] = @Env_DMonitoring_15>>8;
	BoschCodingBuffer[38] = @Env_DMonitoring_15;
	
	BoschCodingBuffer[39] = @Env_DMonitoring_16>>8;
	BoschCodingBuffer[40] = @Env_DMonitoring_16;
	
	BoschCodingBuffer[41] = @Env_DMonitoring_17>>8;
	BoschCodingBuffer[42] = @Env_DMonitoring_17;
	
	BoschCodingBuffer[43] = @Env_DMonitoring_18>>8;
	BoschCodingBuffer[44] = @Env_DMonitoring_18;
	
	BoschCodingBuffer[45] = @Env_DMonitoring_19>>8;
	BoschCodingBuffer[46] = @Env_DMonitoring_19;
	
	BoschCodingBuffer[47] = @Env_DMonitoring_20>>8;
	BoschCodingBuffer[48] = @Env_DMonitoring_20;
}

void BoschCodingRead(byte RxData1[])
{
  if(@Env_ReadBoschCode_Check == 1)
  {
    //Do nothing
  }
  else
  {
	@Env_DMonitoring_1 = (RxData1[9]<<8)+RxData1[10];
	@Env_DMonitoring_2 = (RxData1[11]<<8)+RxData1[12];
	@Env_DMonitoring_3 = (RxData1[13]<<8)+RxData1[14];
	@Env_DMonitoring_4 = (RxData1[15]<<8)+RxData1[16];
	@Env_DMonitoring_5 = (RxData1[17]<<8)+RxData1[18];
	@Env_DMonitoring_6 = (RxData1[19]<<8)+RxData1[20];
	@Env_DMonitoring_7 = (RxData1[21]<<8)+RxData1[22];
	@Env_DMonitoring_8 = (RxData1[23]<<8)+RxData1[24];
	@Env_DMonitoring_9 = (RxData1[25]<<8)+RxData1[26];
	@Env_DMonitoring_10 = (RxData1[27]<<8)+RxData1[28];
	@Env_DMonitoring_11 = (RxData1[29]<<8)+RxData1[30];
	@Env_DMonitoring_12 = (RxData1[31]<<8)+RxData1[32];
	@Env_DMonitoring_13 = (RxData1[33]<<8)+RxData1[34];
	@Env_DMonitoring_14 = (RxData1[35]<<8)+RxData1[36];
	@Env_DMonitoring_15 = (RxData1[37]<<8)+RxData1[38];
	@Env_DMonitoring_16 = (RxData1[39]<<8)+RxData1[40];
	@Env_DMonitoring_17 = (RxData1[41]<<8)+RxData1[42];
	@Env_DMonitoring_18 = (RxData1[43]<<8)+RxData1[44];
	@Env_DMonitoring_19 = (RxData1[45]<<8)+RxData1[46];
	@Env_DMonitoring_20 = (RxData1[47]<<8)+RxData1[48];
  }
	
}

void Key_Calculation()
{

 long request,response; // message handles
 byte KeyArray1, KeyArray2, KeyArray3;
 byte gChallengebyte[8];
 // Declare and initialize the temporary variables 
	long InitialVal ;
    //long challengebyte = 0X5E4D3C2B1A;
	byte Index, ModVal, RefIndex, BitValue,temp1,temp2,mask;

  InitialVal = 0XC541A9;request=0;response=0;Index=0; 
  ModVal=0; RefIndex=0; BitValue=0;temp1=0;temp2=0;mask=0;
  
  //Initialize the Challenge Bytes 
	gChallengebyte[7] = 0x34;//0x4D;
	gChallengebyte[6] = 0x31;//0x52;
	gChallengebyte[5] = 0x52;//0x52;
	gChallengebyte[4] = 0x52;//0x31;
	gChallengebyte[3] = 0x4D;//0x34;0

	// MSB of the Seed is stored in the least byte of the array 
	gChallengebyte[0] = Seed_buf[0];
	gChallengebyte[1] = Seed_buf[1];
	gChallengebyte[2] = Seed_buf[2];
   
  for (Index = 0; Index < 64; Index++)
	{
        ModVal = (Index % 8);
  
		if((ModVal == 0) && (Index != 0))
		{
   
          RefIndex++;
    }
        temp1 = (InitialVal & 0x000001);
        temp2= gChallengebyte[RefIndex] & (0x000001);
        gChallengebyte[RefIndex]= gChallengebyte[RefIndex]>>1;
        BitValue = temp1 ^ temp2;
        InitialVal = ( InitialVal >> 1);
      
        if(BitValue != 0)
        {
            InitialVal ^= 0x909028;
        }
	}
 //Byte R1 - Most Significant Byte of the Key 
	KeyArray1 = ((InitialVal & 0x000000F0) >> 4);
	KeyArray1 |= ((InitialVal & 0x00000F00) >> 4);

	// Byte R2 
	KeyArray2 = ((InitialVal & 0x00F00000) >> 20);
	KeyArray2 |=((InitialVal & 0x0000F000) >> 8);

	// Byte R3 - Least Significant Byte of the Key 
	KeyArray3 = ((InitialVal & 0x000F0000) >> 16);
	KeyArray3 |= ((InitialVal & 0x0000000F) << 4);
  TxDataBuffer[0] = 0x27;
  TxDataBuffer[1] = 0x04;
  TxDataBuffer[2] =KeyArray1;
  TxDataBuffer[3]=KeyArray2;
  TxDataBuffer[4]=KeyArray3;

}



On EnvVar EnvReadswversion
{
    
        if ( getValue ( this ) )
        {
            ClearDtcDisplay();
            StartDiagService( READ_Software_version );
        }

}



void statusParser(byte status)
{
  strncpy(gstatusITC,"",22);
  if(status == 0x11)
  {
    strncpy(gstatusITC,"FAILED_FIRST        ",22);
  }
  else if(status == 0x32)
  {
    strncpy(gstatusITC,"HEALED_AFTER_FAILED ",22);
  }
  else if(status == 0x31)
  {
    strncpy(gstatusITC,"FAILED_AFTER_HEALED ",22);
  }
  else
  {
    strncpy(gstatusITC,"NO_ITC              ",22);
  }
}

EvaluateEnvData()
{
  snprintf( StringAux,99,"Environment data:                ");
  strncpy( Stringbuffer, StringAux,255);

  switch( ( (word)RxDataBuffer[2] << 8 ) | (word)RxDataBuffer[3] )
  {
    default:
    {
    }
    break;
  }

  putValue( EnvEnvDataDisplay, Stringbuffer);

}

void GetSupplier(byte Code, char Supplier[])
{
   switch ( Code )
   {
	  case 0x03: 
	  	strncpy(Supplier,"Bosch",10);
	  break; 

      default:   
	  	strncpy(Supplier,"Error!!",10);
      break; 
   }
}


*/

on busOff
{
   resetCan();
}

/** @brief this is function for convert raw value to physical value
* Into arguments raw_value,factor,offset
* @param raw_value row value of signal
* @param factor factor value of signal
* @param offset offset value of signal
  
 @return void data
*/

double raw_to_phy(dword raw_value,float factor,float offset)
{
  double phy_value;
  
  phy_value=((raw_value*factor)+offset);

  return phy_value;
}

/** @brief this is function for convert physical value to raw_value
* Into arguments phy_value,factor,offset
* @param phy_value phycial value of signal
* @param factor factor value of signal
* @param offset offset value of signal
  
 @return void data
*/

dword phy_to_raw(double phy_value,float factor,float offset)
{
  dword raw_value; 
  
  raw_value =(phy_value-offset)/factor;
  
  return raw_value;
}

/** @brief This on system variable decided alignment type
*/

on sysvar_update sysvar::DIAG_FVIDEO::Alignment::Type
{
  switch(@this)
  {
    case 0:G_Align_RID=K_Align_RID_Sta;break;
    case 1:G_Align_RID=K_Align_RID_Dyn;break;
  }
  write("DIAG_FVIDEO::Alignment::Type::%X",G_Align_RID);
}

/** @brief This on system variable decided alignment type
*/

on sysvar_update sysvar::DIAG_FVIDEO::Alignment::In
{
  switch(@this)
  {
    case 0:G_Align_IN=K_Align_IN_Plant;break;
    case 1:G_Align_IN=K_Align_IN_After;break;
  }
  write("DIAG_FVIDEO::Alignment::In::%X",G_Align_IN);
}

/** @brief This on system variable alignment type will start
*/

on sysvar_update sysvar::DIAG_FVIDEO::Alignment::`Start
{
  if ( @this) 
  {
    //putvalue(Env_JLRSecurity_CCM,1);
    
    ALIGNFlag = 1;//ALIGNMENT_START   
    Alignment_Display_clear();
    setTimer(alignmentTimer,300);
  }
}

/** @brief This on system variable alignment type will stop
*/

on sysvar_update sysvar::DIAG_FVIDEO::Alignment::`Stop
{
  if ( @this) 
  {
    //putvalue(Env_JLRSecurity_CCM,1);
    
    ALIGNFlag = 2;//ALIGNMENT STOP
    Alignment_Display_clear();
    setTimer(alignmentTimer,300);
  }
}

/** @brief This on system variable know alignment status
*/

on sysvar_update sysvar::DIAG_FVIDEO::Alignment::`Status
{
  if ( @this) 
  {
     //putvalue(Env_JLRSecurity_CCM,1);

     ALIGNFlag = 3;//ALIGNMENT STATUS
     Alignment_Display_clear();
     setTimer(alignmentTimer,300);
  }
}

/** @brief this is function clear alignment data from panel

* @return void data
 */
 
void Alignment_Display_clear()
{
    @sysvar::DIAG_FVIDEO::Alignment::Trigger_Status=0;
    sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"");
}

/** @brief this is function start evalute alignment

* @return void data
 */

void Alignment_start_Evaluate()
{
  word Align_RID;
  
  Align_RID=RxDataBuffer[2]<<8;
  Align_RID=RxDataBuffer[3];
 
  if((RxDataBuffer[0] == 0x71)&&(RxDataBuffer[1] == 0x01))
  {
    if(Align_RID==K_Align_RID_Sta)//Static Alignment
    {
      if((RxDataBuffer[4] == 0x01) && (RxDataBuffer[5] == 0x06))
      {
        sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Routine in progress");
        @sysvar::DIAG_FVIDEO::Alignment::Trigger_Status=1;
      }else if((RxDataBuffer[4] == 0xFE)&&(RxDataBuffer[5] == 0xFE))
      {
        sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Alignment Aborted");
        @sysvar::DIAG_FVIDEO::Alignment::Trigger_Status=-1;
      }
    }else if(Align_RID==K_Align_RID_Dyn)//Dynamic Alignment 
    {
      if((RxDataBuffer[4] == 0x01) && (RxDataBuffer[5] == 0x00) && (RxDataBuffer[6] == 0x01) && (RxDataBuffer[7] == 0x00))
      {
        sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Routine in progress");
        @sysvar::DIAG_FVIDEO::Alignment::Trigger_Status=1;
      }
    }
  }
  else if((RxDataBuffer[0] == 0x7F)&&(RxDataBuffer[1] == 0x31))
      {
          switch(RxDataBuffer[2])
          {
            case 0x22:sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Initial Conditions not correct");;
                      break;
            case 0x83:
            case 0x84:sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"IF Engine running");;
                      break;
          }
        @sysvar::DIAG_FVIDEO::Alignment::Trigger_Status=-1;
      }
}

/** @brief this is function stop alignment

* @return void data
 */

void Alignment_stop_Evaluate()
{
  char display[100];
  char xx[50],yy[50];
  int lpl=31;//Letter/column per line
  
  word Align_RID;
  
  Align_RID=RxDataBuffer[2]<<8;
  Align_RID=RxDataBuffer[3];

  if((RxDataBuffer[0] == 0x71))
  {
    if((RxDataBuffer[1] == 0x02)&&(RxDataBuffer[2] == 0x04) && (RxDataBuffer[3] == 0xFE)&&(RxDataBuffer[4] == 0xFE))//Static Alignment
    {
      sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Alignment Aborted");
      @sysvar::DIAG_FVIDEO::Alignment::Trigger_Status=1;
      
    }else if((RxDataBuffer[1] == 0x01)&&(Align_RID == K_Align_RID_Dyn) &&(RxDataBuffer[4] == 0xFE)&&(RxDataBuffer[6] == 0x05))//Dynamic Alignment 
        {
          if( RxDataBuffer[5]<10)
          {
                  i = snprintf(xx,elcount(xx),"Dynamic Calibration %:%d        ", RxDataBuffer[5]);
          }else if(( RxDataBuffer[5]>9)&&( RxDataBuffer[5]<99))
          {
                  i = snprintf(xx,elcount(xx),"Dynamic Calibration %:%d       ", RxDataBuffer[5]);
          }
          else if( RxDataBuffer[5]==100){
                  i = snprintf(xx,elcount(xx),"Dynamic Calibration %:%d      ", RxDataBuffer[5]);
               }
          
          strncat(display,xx,lpl); 
          
          if( RxDataBuffer[7]<=0xF)
          {
                  i = snprintf(yy,elcount(yy),"SDA Driving profile %:0x%X       ", RxDataBuffer[7]);
          }else if(( RxDataBuffer[5]>0xF)&&( RxDataBuffer[5]<=0XFF))
          {
                  i = snprintf(yy,elcount(yy),"SDA Driving profile %:0x%X       ", RxDataBuffer[7]);
          }
          
          strncat(display,yy, strlen(display)+lpl); 
          
          sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,display);
          
          @sysvar::DIAG_FVIDEO::Alignment::Trigger_Status=1;
        }
  }
  else {
        @sysvar::DIAG_FVIDEO::Alignment::Trigger_Status=-1;
       }
}

/** @brief this is functio for alignment status evalute and display 
on paenl

* @return void data
*/

void Alignment_status_Evaluate()
{
  word Align_RID;
  
  char display[200];
  char aa[50],bb[50],cc[70],dd[50];
  
  int lpl=31;//Letter/column per line
  
  long i;
     
  if((RxDataBuffer[0] == 0x71)&&(RxDataBuffer[1] == 0x03))
  {
    Align_RID=RxDataBuffer[2]<<8;
    Align_RID=RxDataBuffer[3];
    
    if(Align_RID==K_Align_RID_Sta)//Static Alignment
    {
      if((RxDataBuffer[4] == 0x01)&& (RxDataBuffer[5] == 0x06))
      {
        sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Routine in progress");
         @sysvar::DIAG_FVIDEO::Alignment::Trigger_Status=1;
      }
      if(RxDataBuffer[4] == 0x02)
      {
        switch(RxDataBuffer[6])
        {
          case 0x00:sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Status::Finished-OK           Measure in PSA Tolerences");
                    break;
          case 0x01:sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Status::Finished-OK           Measure in PSA Tolerences     But with in Bosch Tolerences");
                    break;
          case 0x02:sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Status::Finished-OK           Measure out of Bosch Tolerence");
                    break;
        }
        @sysvar::DIAG_FVIDEO::Alignment::Trigger_Status=1;
      }
      if(RxDataBuffer[4] == 0x03)
      {
        switch(RxDataBuffer[6])
        {
          case 0x03:sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Status::Finished-NOK          Modulation Mode NOK");
                    break;
          case 0x01:sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Status::Finished-NOK          No Target Found");
                    break;
          case 0x02:sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,"Status::Finished-NOK          No Target within Threshold");
                    break;
        }
        @sysvar::DIAG_FVIDEO::Alignment::Trigger_Status=-1;
      }
    }
    else if(Align_RID==K_Align_RID_Dyn)//Dynamic Alignment
    {
      switch(RxDataBuffer[4])
      {
        case 0x01:strncpy(aa, "Routine control in progress    ", lpl);
                  @sysvar::DIAG_FVIDEO::Alignment::Trigger_Status=1;
                  break;
        case 0x02:strncpy(aa, "Routine control finished OK    ", lpl);
                  @sysvar::DIAG_FVIDEO::Alignment::Trigger_Status=1;
                  break;
        case 0x03:strncpy(aa, "Routine control finished NOK   ", lpl);
                  @sysvar::DIAG_FVIDEO::Alignment::Trigger_Status=-1;
                  break;
      }
      strncat(display,aa, lpl); 
      
      if( RxDataBuffer[5]<10)
      {
              i = snprintf(bb,elcount(bb),"Dynamic Calibration %:%d        ", RxDataBuffer[5]);
      }else if(( RxDataBuffer[5]>9)&&( RxDataBuffer[5]<99))
      {
              i = snprintf(bb,elcount(bb),"Dynamic Calibration %:%d       ", RxDataBuffer[5]);
      }
      else if( RxDataBuffer[5]==100){
              i = snprintf(bb,elcount(bb),"Dynamic Calibration %:%d      ", RxDataBuffer[5]);
           }
      
      strncat(display,bb, strlen(display)+lpl); 
      
      switch(RxDataBuffer[6])
      {
        case 0x00:strncpy(cc, "SDA not running                ", lpl);
                  break;
        case 0x01:strncpy(cc, "SDA running                    ", lpl);
                  break;
        case 0x02:strncpy(cc, "Measure in PSA tolerances      ", lpl);
                  break;
        case 0x03:strncpy(cc, "Measure in PSA Tolerences     But with in Bosch Tolerences   ", lpl*2);
                  break;
        case 0x04:strncpy(cc, "Measure out of BOSCH tolerance ", lpl);
                  break;
        case 0x05:strncpy(cc, "Aborted                        ", lpl);
                  break;
      }
      
      strncat(display,cc, strlen(display)+strlen(cc)); 

      if( RxDataBuffer[7]<=0xF)
      {
              i = snprintf(dd,elcount(dd),"SDA Driving profile %:0x%X       ", RxDataBuffer[7]);
      }else if(( RxDataBuffer[5]>0xF)&&( RxDataBuffer[5]<=0XFF))
      {
              i = snprintf(dd,elcount(dd),"SDA Driving profile %:0x%X       ", RxDataBuffer[7]);
      }
      
      strncat(display,dd, strlen(display)+lpl); 
      
      sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,display);
    }
  }else if((RxDataBuffer[0] == 0x71) && (RxDataBuffer[1] == 0x01))
        {
          if((Align_RID == K_Align_RID_Dyn) &&(RxDataBuffer[4] == 0x01)&&(RxDataBuffer[6] == 0x01))//Dynamic Alignment 
              {
                if( RxDataBuffer[5]<10)
                {
                        i = snprintf(aa,elcount(aa),"Dynamic Calibration %:%d        ", RxDataBuffer[5]);
                }else if(( RxDataBuffer[5]>9)&&( RxDataBuffer[5]<99))
                {
                        i = snprintf(aa,elcount(aa),"Dynamic Calibration %:%d       ", RxDataBuffer[5]);
                }
                else if( RxDataBuffer[5]==100){
                        i = snprintf(aa,elcount(aa),"Dynamic Calibration %:%d      ", RxDataBuffer[5]);
                     }
                
                strncat(display,aa,lpl); 
                
                if( RxDataBuffer[7]<=0xF)
                {
                        i = snprintf(bb,elcount(bb),"SDA Driving profile %:0x%X       ", RxDataBuffer[7]);
                }else if(( RxDataBuffer[5]>0xF)&&( RxDataBuffer[5]<=0XFF))
                {
                        i = snprintf(bb,elcount(bb),"SDA Driving profile %:0x%X       ", RxDataBuffer[7]);
                }
                
                strncat(display,bb, strlen(display)+lpl); 
                
                sysSetVariableString(sysvar::DIAG_FVIDEO::Alignment::Display,display);
                
                @sysvar::DIAG_FVIDEO::Alignment::Trigger_Status=1;
              }
        }
}

/** @brief this is functio for clear Current Misalignment Value
on paenl
* @return void data
*/
 
//Current Misalignment Value
void Alignment_Current_Value_clear()
{
  @sysvar::DIAG_FVIDEO::Align_Curr_Value::Azimuth=0;
  @sysvar::DIAG_FVIDEO::Align_Curr_Value::Elevation=0;
  @sysvar::DIAG_FVIDEO::Align_Curr_Value::Trigger_Status=0;
}

/** @brief this is functio for read Current alignment Value 
* @return void data
 */

void Alignment_Current_Value_Read_Evaluate()
{
  byte DID[2];
  word temp;
  
  DID[0]=G_Align_Curr_Val>>8;
  DID[1]=G_Align_Curr_Val;
  
  if((RxDataBuffer[0] == 0x62)&&(RxDataBuffer[1] == DID[0]) && (RxDataBuffer[2] == DID[1]))
  {
    temp=0;//Clear;
    temp=RxDataBuffer[3];
    temp=temp|(RxDataBuffer[4]<<8);
    @sysvar::DIAG_FVIDEO::Align_Curr_Value::Azimuth=raw_to_phy(temp,0.01,-50);//raw_to_phy(raw_value,factor,offset)Factor: 0.01;Offset: -50
    
    temp=0;//Clear;
    temp=RxDataBuffer[5];
    temp=temp|(RxDataBuffer[6]<<8);
    @sysvar::DIAG_FVIDEO::Align_Curr_Value::Elevation=raw_to_phy(temp,0.01,-50);//raw_to_phy(raw_value,factor,offset)Factor: 0.01;Offset: -50
    
    @sysvar::DIAG_FVIDEO::Align_Curr_Value::Trigger_Status=1;
  }
  else{
          @sysvar::DIAG_FVIDEO::Align_Curr_Value::Trigger_Status=-1;
      }
}

/** @brief This on system variable current alignment value will be trigger
*/

on sysvar sysvar::DIAG_FVIDEO::Align_Curr_Value::Trigger
{
  if(@this)
  {
    Alignment_Current_Value_clear();
    StartDiagService(ALIGNMENT_CURR_VAL);
  }
}

/** @brief this function is for clearing alignment tolerance
* @return void data
*/

//Alignment Tolerance
void Alignment_Tolerance_clear()
{
  @sysvar::DIAG_FVIDEO::Align_Tolerance_R::Azimuth=0;
  @sysvar::DIAG_FVIDEO::Align_Tolerance_R::Elevation=0;
  @sysvar::DIAG_FVIDEO::Align_Tolerance_R::Trigger_Status=0;
}


/** @brief this function is for reading alignment tolerance
* @return void data
*/

void Alignment_Tolerance_Read_Evaluate()
{
  byte DID[2];
  byte x;
  
  DID[0]=G_Align_Tolerance>>8;
  DID[1]=G_Align_Tolerance;
  if((RxDataBuffer[0] == 0x62)&&(RxDataBuffer[1] == DID[0]) && (RxDataBuffer[2] == DID[1]))
  {
    x=RxDataBuffer[3];
    @sysvar::DIAG_FVIDEO::Align_Tolerance_R::Azimuth=raw_to_phy(x,0.1,0);//raw_to_phy(raw_value,factor,offset)Factor: 0.1;Offset: 0
    
    x=RxDataBuffer[4];
    @sysvar::DIAG_FVIDEO::Align_Tolerance_R::Elevation=raw_to_phy(x,0.1,0);//raw_to_phy(raw_value,factor,offset)Factor: 0.1;Offset: 0
    
    @sysvar::DIAG_FVIDEO::Align_Tolerance_R::Trigger_Status=1;
  }
  else{
          @sysvar::DIAG_FVIDEO::Align_Tolerance_R::Trigger_Status=-1;
      }
}

/** @brief This on system variable read alignment value
*/

on sysvar sysvar::DIAG_FVIDEO::Align_Tolerance_R::Trigger//Read
{
  if(@this)
  {
    Alignment_Tolerance_clear();
    StartDiagService(ALIGNMENT_TOL_R);
  }
}

/** @brief this function is for writing alignment tolerance
* @return void data
*/

void Alignment_Tolerance_Write()
{
  float a,b;
  TxDataBuffer[0] = 0x2E;//WDBI
	TxDataBuffer[1] = G_Align_Tolerance>>8;
	TxDataBuffer[2] = G_Align_Tolerance;
  
  //Factor : 0.1
  //Offset : 0
  a=@sysvar::DIAG_FVIDEO::Align_Tolerance_W::Azimuth;
  TxDataBuffer[3] = phy_to_raw(a,0.1,0);//Azimuth(Y axis)
  
  b=@sysvar::DIAG_FVIDEO::Align_Tolerance_W::Elevation;
  TxDataBuffer[4] = phy_to_raw(b,0.1,0);//Elevation(Z axis)

  TxLength = 5;
  
	TransmitTxBuffer();
}

/** @brief this function is for writing alignment tolerance status and display 
on panel
* @return void data
*/

void Alignment_Tolerance_Write_Evaluate()
{
  byte DID[2];
  word temp;
  byte x,y,z;
  
  DID[0]=G_Align_Tolerance>>8;
  DID[1]=G_Align_Tolerance;
  if((RxDataBuffer[0] == 0x6E)&&(RxDataBuffer[1] == DID[0]) && (RxDataBuffer[2] == DID[1]))
  {
    @sysvar::DIAG_FVIDEO::Align_Tolerance_W::Trigger_Status=1;
  }
  else{
          @sysvar::DIAG_FVIDEO::Align_Tolerance_W::Trigger_Status=-1;
      }
}

/** @brief This on system variable write alignment tolerance
*/

on sysvar sysvar::DIAG_FVIDEO::Align_Tolerance_W::Trigger//Read
{
  if(@this)
  {
    @sysvar::DIAG_FVIDEO::Align_Tolerance_W::Trigger_Status=0;
    StartDiagService(ALIGNMENT_TOL_W);
  }
}

/** @brief this function is for Alignment data clear 
on panel
* @return void data
*/

//Factory EOL Alignment Data
void Alignment_Data_clear()
{
  @sysvar::DIAG_FVIDEO::Align_Data_R::FVC_FL_wheel=0;
  @sysvar::DIAG_FVIDEO::Align_Data_R::FVC_FR_wheel=0;
  @sysvar::DIAG_FVIDEO::Align_Data_R::FVC_RL_wheel=0;
  @sysvar::DIAG_FVIDEO::Align_Data_R::FVC_RR_wheel=0;
  @sysvar::DIAG_FVIDEO::Align_Data_R::Target_Dist_X=0;
  @sysvar::DIAG_FVIDEO::Align_Data_R::Target_Type=0;
  @sysvar::DIAG_FVIDEO::Align_Data_R::Thrust_Axis=0;
  @sysvar::DIAG_FVIDEO::Align_Data_R::Trigger_Status=0;
}

/** @brief this function is for read Alignment data 
* @return void data
*/

void Alignment_Data_Read_Evaluate()
{
  byte DID[2];
  word temp;
  byte x,y,z;
  
  DID[0]=G_Align_Data>>8;
  DID[1]=G_Align_Data;
  if((RxDataBuffer[0] == 0x62)&&(RxDataBuffer[1] == DID[0]) && (RxDataBuffer[2] == DID[1]))
  {
    x=RxDataBuffer[3];
    @sysvar::DIAG_FVIDEO::Align_Data_R::Thrust_Axis=raw_to_phy(x,0.01,0);//raw_to_phy(raw_value,factor,offset)Factor: 0.01;Offset: 0
    
    x=RxDataBuffer[4];//Target_Type+ Target_Dist_X
    x=x&0xF0;//Target_Type[7-4]
    x=x>>4;
    @sysvar::DIAG_FVIDEO::Align_Data_R::Target_Type=x;
    
    x=RxDataBuffer[4];//Target_Type+ Target_Dist_X
    x=x&0x0F;//Target_Dist_X [0-3]
    
    temp=0;//Clear
    temp=RxDataBuffer[5];//Target_Dist_X[4-11]
    temp=temp|x<<8;
    @sysvar::DIAG_FVIDEO::Align_Data_R::Target_Dist_X=raw_to_phy(temp,1,0);//raw_to_phy(raw_value,factor,offset)Factor: 1;Offset: 0
    
    temp=0;//Clear
    temp=RxDataBuffer[6];//FVC_FL_wheel [0-7]
    
    x=RxDataBuffer[7];//FVC_FL_wheel+FVC_FR_wheel
    x=x&0xF0;//FVC_FL_wheel[8-11]
    x=x>>4;
    temp=temp|(x<<8);
    
    @sysvar::DIAG_FVIDEO::Align_Data_R::FVC_FL_wheel=raw_to_phy(temp,1,0);//raw_to_phy(raw_value,factor,offset)Factor: 1;Offset: 0
    
    x=RxDataBuffer[7];//FVC_FL_wheel+FVC_FR_wheel
    x=x&0x0F;//FVC_FR_wheel[0-3]
    
    temp=0;//Clear
    temp=RxDataBuffer[8]<<4;//FVC_FR_wheel[4-11]
    temp=temp|x;
    @sysvar::DIAG_FVIDEO::Align_Data_R::FVC_FR_wheel=raw_to_phy(temp,1,0);//raw_to_phy(raw_value,factor,offset)Factor: 1;Offset: 0
    
    temp=0;//Clear
    temp=RxDataBuffer[9];//FVC_RL_wheel [0-7]
    
    x=RxDataBuffer[10];//FVC_RL_wheel+FVC_RR_wheel
    x=x&0xF0;//FVC_RL_wheel[8-11]
    x=x>>4;
    temp=temp|(x<<8);
    
    @sysvar::DIAG_FVIDEO::Align_Data_R::FVC_RL_wheel=raw_to_phy(temp,1,0);//raw_to_phy(raw_value,factor,offset)Factor: 1;Offset: 0
    
    x=RxDataBuffer[10];//FVC_RL_wheel+FVC_RR_wheel
    x=x&0x0F;//FVC_RR_wheel[0-3]
    
    temp=0;//Clear
    temp=RxDataBuffer[11]<<4;//FVC_RR_wheel[4-11]
    temp=temp|x;
    @sysvar::DIAG_FVIDEO::Align_Data_R::FVC_RR_wheel=raw_to_phy(temp,1,0);//raw_to_phy(raw_value,factor,offset)Factor: 1;Offset: 0
    
    @sysvar::DIAG_FVIDEO::Align_Data_R::Trigger_Status=1;
  }
  else{
          @sysvar::DIAG_FVIDEO::Align_Data_R::Trigger_Status=-1;
      }
}

/** @brief This on system variable write alignment tolerance on diag
*/

on sysvar sysvar::DIAG_FVIDEO::Align_Data_R::Trigger//Read
{
  if(@this)
  {
    Alignment_Data_clear();
    StartDiagService(ALIGNMENT_DATA_R);
  }
}

/** @brief this function is for write Alignment data 
* @return void data
*/

void Alignment_Data_Write()
{
  byte x,y,z;
  word a,b;
  TxDataBuffer[0] = 0x2E;//WDBI
	TxDataBuffer[1] = G_Align_Data>>8;
	TxDataBuffer[2] = G_Align_Data;
  
  //Factor : 0.01
  //Offset : 0
  TxDataBuffer[3] = phy_to_raw(@sysvar::DIAG_FVIDEO::Align_Data_W::Thrust_Axis,0.01,0);//Thrust_Axis
  
  x=@sysvar::DIAG_FVIDEO::Align_Data_W::Target_Type;
  x=x<<4;
  
  //Factor : 1
  //Offset : 0
  a=phy_to_raw(@sysvar::DIAG_FVIDEO::Align_Data_W::Target_Dist_X,1,0);
  
  y=(a&0xF00)>>8;
  z=x|y;
  
  TxDataBuffer[4]=z;//Target_Type+Target_Dist_X
  
  y=a&0x0FF;
  TxDataBuffer[5]=y;//Target_Dist_X
  
  a=phy_to_raw(@sysvar::DIAG_FVIDEO::Align_Data_W::FVC_FL_wheel,1,0);
  x=a;
  
  TxDataBuffer[6]=x;//FVC_FL_wheel
  
  x=(a&0xF00)>>8;
  x=x<<4;
  
  a=phy_to_raw(@sysvar::DIAG_FVIDEO::Align_Data_W::FVC_FR_wheel,1,0);
  y=a&0xF;
  
  z=x|y;
  
  TxDataBuffer[7]=x;//FVC_FL_wheel+FVC_FR_wheel
  
  y=(a&0xFF0)>>4;
  TxDataBuffer[8]=y;//FVC_FR_wheel
  
  a=phy_to_raw(@sysvar::DIAG_FVIDEO::Align_Data_W::FVC_RL_wheel,1,0);
  x=a;
  
  TxDataBuffer[9]=x;//FVC_RL_wheel
  
  x=(a&0xF00)>>8;
  x=x<<4;
  
  a=phy_to_raw(@sysvar::DIAG_FVIDEO::Align_Data_W::FVC_RR_wheel,1,0);
  y=a&0xF;
  
  z=x|y;
  
  TxDataBuffer[10]=x;//FVC_RL_wheel+FVC_RR_wheel
  
  y=(a&0xFF0)>>4;
  TxDataBuffer[11]=y;//FVC_RR_wheel
  
  TxLength = 12;
  
	TransmitTxBuffer();
}

/** @brief this function is for evalute write Alignment data 
* @return void data
*/


void Alignment_Data_Write_Evaluate()
{
  byte DID[2];
  word temp;
  byte x,y,z;
  
  DID[0]=G_Align_Data>>8;
  DID[1]=G_Align_Data;
  if((RxDataBuffer[0] == 0x6E)&&(RxDataBuffer[1] == DID[0]) && (RxDataBuffer[2] == DID[1]))
  {
    @sysvar::DIAG_FVIDEO::Align_Data_W::Trigger_Status=1;
  }
  else{
          @sysvar::DIAG_FVIDEO::Align_Data_W::Trigger_Status=-1;
      }
}

/** @brief This on system variablea trigger alignment data
*/

on sysvar sysvar::DIAG_FVIDEO::Align_Data_W::Trigger//Write
{
  if(@this)
  {
    @sysvar::DIAG_FVIDEO::Align_Data_W::Trigger_Status=0;
    StartDiagService(ALIGNMENT_DATA_W);
  }
}

/** @brief this function is for Factory EOL Alignment Measure
* @return void data
*/
//Factory EOL Alignment Measure
void Alignment_Measure_Result_clear()
{
  @sysvar::DIAG_FVIDEO::Align_Meas_Res::Azimuth=0;
  @sysvar::DIAG_FVIDEO::Align_Meas_Res::Elevation=0;
  @sysvar::DIAG_FVIDEO::Align_Meas_Res::Trigger_Status=0;
  sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::description,"");
  sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::Meas_Status,"");
}

/** @brief this function is for Evalualate Alignment Measure result
* @return void data
*/

void Alignment_Measure_Result_Evaluate()
{
  byte DID[2];
  word temp;
  DID[0]=G_Align_Meas_Res>>8;
  DID[1]=G_Align_Meas_Res;
  if((RxDataBuffer[0] == 0x62)&&(RxDataBuffer[1] == DID[0]) && (RxDataBuffer[2] == DID[1]))
  {
    //Flag EOL radar misalignment measure status
    switch(RxDataBuffer[3])
    {
      case 0x00:
                sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::Meas_Status, "Request never done, alignment routine never launched");
                break;
      case 0x01:
                sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::Meas_Status, "Request done, with results in PSA tolerance");
                break;
      case 0x02:
                sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::Meas_Status, "Request done, with results out of PSA tolerance but within Bosch tolerance");
                break;
      case 0x03:
                sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::Meas_Status, "Request done, with results out of Bosch tolerance");
                break;
      case 0x04:
                sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::Meas_Status, "Request not done or aborted");
                break; 
       default :
                sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::Meas_Status, "Invalid");
                break; 
    }
    
    temp =RxDataBuffer[4];
    temp =temp|(RxDataBuffer[5]<<8);
    
    @sysvar::DIAG_FVIDEO::Align_Meas_Res::Azimuth=raw_to_phy(temp,0.01,-50);//raw_to_phy(raw_value,factor,offset)//Factor: 0.01; Offset: -50
    
    temp =RxDataBuffer[6];
    temp =temp|(RxDataBuffer[7]<<8);
    
    @sysvar::DIAG_FVIDEO::Align_Meas_Res::Elevation=raw_to_phy(temp,0.01,-50);//raw_to_phy(raw_value,factor,offset)//Factor: 0.01; Offset: -50
    
    //Def Descr (Default description)
    switch(RxDataBuffer[8])
    {
      case 0x00:
                sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::description, "No specific error");
                break;
      case 0x01:
                sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::description, "Target not found ");
                break;
      case 0x03:
                sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::description, "No Target within the threshold limits");
                break;
      case 0x04:
                sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::description, "Modulation Mode Not Ok");
                break;
      case 0x05:
                sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::description, "Sensor Blind");
                break;
      case 0x06:
                sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::description, "Internal Failure");
                break;
      case 0x07:
                sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::description, "SW Timeout");
                break;
      case 0xFF:
                sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::description, "Routine not launched");
                break;
       default :
                sysSetVariableString(sysvar::DIAG_FVIDEO::Align_Meas_Res::description, "Invalid");
                break; 
    }
    @sysvar::DIAG_FVIDEO::Align_Meas_Res::Trigger_Status=1;
  }
  else{
          @sysvar::DIAG_FVIDEO::Align_Meas_Res::Trigger_Status=-1;
      }
}

/** @brief This on system variable trigger alignment measure result on uds
*/

on sysvar sysvar::DIAG_FVIDEO::Align_Meas_Res::Trigger//Read
{
  if(@this)
  {
    Alignment_Measure_Result_clear();
    StartDiagService(ALIGNMENT_MEAR_RES);
  }
}

/** @brief This on system variable decide Tx and rx nodes as per network
*/

on sysVar sysvar::DIAG_FVIDEO::GeneralSettings::sysECUvariant
{
  switch(@this) {
    case 0://Front
           @sysvar::DIAG_FVIDEO::GeneralSettings::sysTxIdentifier=K_TxId_FR;
           @sysvar::DIAG_FVIDEO::GeneralSettings::sysRxIdentifier=K_RxId_FR;
	         G_ITC_Mask_lng=K_ITC_FR_Mask_lng;
           break;
    case 1://CR_FL:
           @sysvar::DIAG_FVIDEO::GeneralSettings::sysTxIdentifier=K_TxId_CR_FL;
           @sysvar::DIAG_FVIDEO::GeneralSettings::sysRxIdentifier=K_RxId_CR_FL;
           G_ITC_Mask_lng=K_ITC_CR_Mask_lng;
           break;
    case 2://CR_FR:
           @sysvar::DIAG_FVIDEO::GeneralSettings::sysTxIdentifier=K_TxId_CR_FR;
           @sysvar::DIAG_FVIDEO::GeneralSettings::sysRxIdentifier=K_RxId_CR_FR;
           G_ITC_Mask_lng=K_ITC_CR_Mask_lng;
           break;
    case 3://CR_RL:
           @sysvar::DIAG_FVIDEO::GeneralSettings::sysTxIdentifier=K_TxId_CR_RL;
           @sysvar::DIAG_FVIDEO::GeneralSettings::sysRxIdentifier=K_RxId_CR_RL;
           G_ITC_Mask_lng=K_ITC_CR_Mask_lng;
           break;
    case 4://CR_RR:
           @sysvar::DIAG_FVIDEO::GeneralSettings::sysTxIdentifier=K_TxId_CR_RR;
           @sysvar::DIAG_FVIDEO::GeneralSettings::sysRxIdentifier=K_RxId_CR_RR;
           G_ITC_Mask_lng=K_ITC_CR_Mask_lng;
           break;
  }
  write("DIAG_FVIDEO::BOSCH_CODING::Length::%d",G_ITC_Mask_lng);
}

/** @brief This on system variable writing bosch coding
*/

on sysvar_update sysvar::DIAG_FVIDEO::BOSCH_CODING::Write
{
  if(@this)
  {
    @sysvar::DIAG_FVIDEO::BOSCH_CODING::Trigger_Status=0;
    StartDiagService( WRITE_BOSCH_CODING );
  }
}

/** @brief This on system variable Reading bosch coding
*/

on sysvar_update sysvar::DIAG_FVIDEO::BOSCH_CODING::Read
{
  if(@this)
  {
    @sysvar::DIAG_FVIDEO::BOSCH_CODING::Trigger_Status=0;
    StartDiagService( READ_BOSCH_CODING );
  }
}

/** @brief This on system variable Reset bosch coding
*/

on sysvar_update sysvar::DIAG_FVIDEO::BOSCH_CODING::reset
{
  int i;
  if(@this)
  {
    for(i=0;i<20;i++)
    {
      @sysvarMember::DIAG_FVIDEO::BOSCH_CODING::ITC_NO[i]=-1;//Reset
    }
  }
}

/** @brief this function is for bosch code writing
* @return void data
*/

void bosch_coding_Write()
{
	  int i;
    int64 Maskbit;
    int byte_index;
    int bit_index;
    int powerof2;//Power of 2
  
    byte  ITC_Mask_data[K_ITC_FR_Mask_lng];
  
    TxDataBuffer[0] = 0x2E;
	  TxDataBuffer[1] = K_ITC_DiD>>8;
	  TxDataBuffer[2] = K_ITC_DiD;
 
    for(i=0;i<G_ITC_Mask_lng;i++)
    {
      ITC_Mask_data[i]=0;//Clear
    }
    
    for(i=0;i<20;i++)
    {
      Maskbit=@sysvarMember::DIAG_FVIDEO::BOSCH_CODING::ITC_NO[i];
      byte_index=Maskbit/8;
      bit_index=Maskbit%8;
      powerof2=_pow(2.0, bit_index);
      ITC_Mask_data[byte_index]=ITC_Mask_data[byte_index]|powerof2;
    }
    
    for(i=0;i<G_ITC_Mask_lng;i++)
    {
      TxDataBuffer[3+i]=ITC_Mask_data[i];//copy to tx
    }
    
    TxLength = 3 + G_ITC_Mask_lng;
    TransmitTxBuffer();
}

/** @brief this function is for bosch code writing evalute
* @return void data
*/

void Bosch_coding_Write_Evaluate()
{
  word ITC_DID;
  
  ITC_DID=RxDataBuffer[1]<<8;
  ITC_DID=ITC_DID|RxDataBuffer[2];
  //write("RxDataBuffer[0]:%X,RxDataBuffer[1]:%X,RxDataBuffer[2]:%X,ITC_DID:%X",RxDataBuffer[0],RxDataBuffer[1],RxDataBuffer[2],ITC_DID);
  if((RxDataBuffer[0] == 0x6E)&&(ITC_DID == K_ITC_DiD))//2E+40=6E
  {
    @sysvar::DIAG_FVIDEO::BOSCH_CODING::Trigger_Status=1;
  }
  else if(RxDataBuffer[0] == 0x7F)
      {
        @sysvar::DIAG_FVIDEO::BOSCH_CODING::Trigger_Status=-1;
      }
}

/** @brief this function is for bosch code Reading evalute
* @return void data
*/

void Bosch_coding_Read_Evaluate()
{
	int64 i,k;
  byte mask = 1; // Bit mask
  byte temp= 00;// Read from file
  
  word  ITC_Mask_index[K_ITC_FR_Mask_lng*8];
  word  ITC_DID;
  
  ITC_DID=RxDataBuffer[1]<<8;
  ITC_DID=ITC_DID|RxDataBuffer[2];
  
  //write("RxDataBuffer[0]:%X,RxDataBuffer[1]:%X,RxDataBuffer[2]:%X,ITC_DID:%X",RxDataBuffer[0],RxDataBuffer[1],RxDataBuffer[2],ITC_DID);
 
  if((RxDataBuffer[0] == 0x62)&&(ITC_DID == K_ITC_DiD))//22+40=62
  {
    if(@sysvar::DIAG_FVIDEO::BOSCH_CODING::Read_Check!=1)
    {
      for(i=0;i<20;i++)
      {
        @sysvarMember::DIAG_FVIDEO::BOSCH_CODING::ITC_NO[i]=-1;//Reset
      }
      
      for(i=0;i<K_ITC_FR_Mask_lng*8;i++)
      {
        ITC_Mask_index[i]=-1;//Reset
      }
      
      k=0;
      
      for(i=0;i<G_ITC_Mask_lng;i++)
      {
        temp=RxDataBuffer[3+i];
        for ( j= 0; j < 8; j++) 
        {
          if((temp >> j) & mask)
          {
            ITC_Mask_index[k]=(i*8)+j;
            k++;
          }  
        }
      }
    
      for ( i = 0; (i < k)&&(i < 20); i++) 
      {
        @sysvarMember::DIAG_FVIDEO::BOSCH_CODING::ITC_NO[i]=ITC_Mask_index[i];
      }
    }

    @sysvar::DIAG_FVIDEO::BOSCH_CODING::Trigger_Status=1;
  
  }else if(RxDataBuffer[0] == 0x7F)
        {
          @sysvar::DIAG_FVIDEO::BOSCH_CODING::Trigger_Status=-1;
        }
}

/** @brief This on system variable write ER_varaint coding
*/

on sysvar_update sysvar::DIAG_FVIDEO::ER_VARIANT_CODING::Write
{
  if(@this)
  {
    StartDiagService( WRITE_ER_VARIANT );
  }
}

/** @brief This on system variable Reading  er_varaint coding

*/
on sysvar_update sysvar::DIAG_FVIDEO::ER_VARIANT_CODING::Read
{
  if(@this)
  {
    StartDiagService( READ_ER_VARIANT );
  }
}

/** @brief This on system variable writing  RPC_varaint coding

*/

on sysvar_update sysvar::DIAG_FVIDEO::RPC_VARIANT_CODING::Write
{
  if(@this)
  {
    StartDiagService( WRITE_RPC_VARIANT );
  }
}

/** @brief This on system variable Reading  RPC_varaint coding

*/

on sysvar_update sysvar::DIAG_FVIDEO::RPC_VARIANT_CODING::Read
{
  if(@this)
  {
    StartDiagService( READ_RPC_VARIANT );
  }
}

/** @brief This on system variable display itc data on panel

*/

on sysvar_update sysvar::DIAG_FVIDEO::ITC::Read
{
   if ( @this) 
   {
        sysSetVariableString(sysvar::DIAG_FVIDEO::ITC::Display,"");
        setTimer(ITCTimer_Read,1);      
    }
}

/** @brief This on system variable clear itc data on panel
*/


on sysvar_update sysvar::DIAG_FVIDEO::ITC::Clear
{
   if ( @this) 
   {
        sysSetVariableString(sysvar::DIAG_FVIDEO::ITC::Display,"");
        StartDiagService( ITC_CLEAR );
        setTimer(ITCTimer_Read,300);
    }
}

on timer ITCTimer_Read
{
  StartDiagService( ITC_READ );
}

/** @brief this function is for parse ITC data
* Into arguments ITCList,Length
* @param ITCList Buffer of ITClist for parse
* @param length length of Itc buffer
* @return void data
*/


void parseITCData(byte ITCList[],int Length)
{
  
  int ITCCount;
  int i,byteCount;
  char output[816];
  int temp;
  //cha
  
  ITCCount = (Length-3)/19;
  byteCount = 3;
  
  strncpy(output,"STATUS               Occ  VehSpd Volt   Temp EVID  AGE    Unique_ID --------------------------------------------------------------------",elcount(output));
  
  for(i=0;i<ITCCount;i++)
  {
   
    statusParser(ITCList[byteCount+1]);
    strncat(output,gstatusITC,elcount(output));
    convertAndSave(ITCList[byteCount+2],output,1);
    
    temp = (ITCList[byteCount+3] << 8) + ITCList[byteCount+4];
    convertAndSave(temp,output,4);
    
   // write("*****************%d %d %d",(ITCList[byteCount+5] << 8),ITCList[byteCount+6],temp);
    
    temp = (ITCList[byteCount+5] << 8) + ITCList[byteCount+6];
    //write("*****************%d %d %d",(ITCList[byteCount+5] << 8),ITCList[byteCount+6],temp);
    convertAndSave(temp,output,2);
    
    temp = (ITCList[byteCount+7] << 8) + ITCList[byteCount+8];
    convertAndSave(temp,output,3);
    
    temp = (ITCList[byteCount+9] << 8) + ITCList[byteCount+10];
    convertAndSave(temp,output,0);
    
    convertAndSave(ITCList[byteCount+11],output,99);
    convertAndSave(ITCList[byteCount+12],output,99);
    convertAndSave(ITCList[byteCount+13],output,99);
    convertAndSave(ITCList[byteCount+14],output,99);
    strncat(output," ",elcount(output));
    convertAndSave(ITCList[byteCount+15],output,99);
    convertAndSave(ITCList[byteCount+16],output,99);
    convertAndSave(ITCList[byteCount+17],output,99);
    convertAndSave(ITCList[byteCount+18],output,99);
    
    if(strlen(output)%68 != 0)
    {
      for(i = 0;i<(strlen(output)%68);i++)
      {
        strncat(output," ",elcount(output));
      }
    }
    byteCount+=19;
  
  }
  strncat(output,"\0",elcount(output));
  sysSetVariableString(sysvar::DIAG_FVIDEO::ITC::Display,output);  
}

/** @brief this function is for convert and save itc parser and give unit value
* Into arguments input,output,unit
* @param input dword input
* @param output buffer of ITC parser
* @param unit data to give unit to itc value
* @return void data
*/

void convertAndSave(dword input,char output[],int unit)
{
  char temp[7];
  
  if(unit == 0)
  {
    ltoa(input,temp,10);
    strncat(output,temp,elcount(output));
    strncat(output," ",elcount(output));
  }
  else if(unit == 1)
  {
    ltoa(input,temp,10);
    strncat(output,temp,elcount(output));
    strncat(output,"(Occ) ",elcount(output));
  }
  else if(unit == 2)
  {
    ltoa(input,temp,10);
    strncat(output,temp,elcount(output));
    strncat(output,"mV ",elcount(output));
  }
  else if(unit == 3)
  {
    ltoa(input/10,temp,10);
    strncat(output,temp,elcount(output));
    strncat(output,"`C ",elcount(output));
  }
  else if(unit == 4)
  {
    ltoa(input,temp,10);
    strncat(output,temp,elcount(output));
    strncat(output,"m/s ",elcount(output));
  }
  else if(unit == 99)
  {
    ltoa(input,temp,16);
    if(strlen(temp) == 1)
    {
      strncat(output,"0",elcount(output));
      strncat(output,temp,elcount(output));
    } 
    else
    {
      strncat(output,temp,elcount(output));
    }
  }
  else
  {
      write("Error");
  }
}

/** @brief this function is for ITC status parser
* Into arguments status
* @param status status of ITC to Display
* @return void data
*/
void statusParser(byte status)
{
  strncpy(gstatusITC,"",22);
  if(status == 0x11)
  {
    strncpy(gstatusITC,"FAILED_FIRST        ",22);
  }
  else if(status == 0x32)
  {
    strncpy(gstatusITC,"HEALED_AFTER_FAILED ",22);
  }
  else if(status == 0x31)
  {
    strncpy(gstatusITC,"FAILED_AFTER_HEALED ",22);
  }
  else
  {
    strncpy(gstatusITC,"NO_ITC              ",22);
  }
}

/** @brief This on system variable send request for key
*/

//PSA Security Access
on sysvar_update sysvar::DIAG_FVIDEO::PSA_SecAcc::Seed
{
  if(@this)
  {
    @sysvar::DIAG_FVIDEO::PSA_SecAcc::Trigger_Status=0;
    sysSetVariableString(sysvar::DIAG_FVIDEO::PSA_SecAcc::Display,"");
    StartDiagService( SEEDNKEYPSAREQUEST );
  }
}

/** @brief this function is for seed request Evalualate
* @return void data
*/

void PSA_seed_req_Evaluate()
{
  if((RxDataBuffer[0] == 0x67)&&(RxDataBuffer[1] == 0x03))
  {
    switch(@sysvar::DIAG_FVIDEO::GeneralSettings::sysECUvariant) 
    {
        case 0://Front
               Get_PSA_Seed_Key(APPLICATIONKEY_FRONT);
               break;
        case 1://CR_FL:
        case 2://CR_FR:
        case 3://CR_RL:
        case 4://CR_RR:
               Get_PSA_Seed_Key(APPLICATIONKEY_CORNER);
               break;
      }
  @sysvar::DIAG_FVIDEO::PSA_SecAcc::Trigger_Status=1;   
  }else{
          @sysvar::DIAG_FVIDEO::PSA_SecAcc::Trigger_Status=-1;
      }
}

/** @brief this function is for get key for psa and display on panel
* Into arguments Variant_KEY 
* @param Variant_KEY seed as per varaint front or corner
* @return void data
*/

void Get_PSA_Seed_Key(word Variant_KEY)
{      
  int i;
  dword  l_SeedDataArray_ub[10];
  dword  l_SeedtempStore[4];
  
  dword l_SeedRot_ul; //For to store value after Seed reverse
  word  l_SeedMSBStore_ui,l_SeedLSBStore_ui ;
  word  l_Seedbytestr_1_ub,l_Seedbytestr_2_ub,l_Seedbytestr_3_ub,l_Seedbytestr_4_ub;

  word  l_KeyStore_MSB_ul,l_KeyStore_LSB_ul;
  dword l_KeyfinalResult_ul;


   for(i=0;i<8;i++)
   {
     l_SeedDataArray_ub[i] = RxDataBuffer[i];//Storing response bytes   
   } 
   
   //Func_DeleteRequestAndResponseObjects();
   g_seed_value_psa[0] = l_SeedDataArray_ub[2];//Storing Seed value into Global buffer
   g_seed_value_psa[1] = l_SeedDataArray_ub[3];//Storing Seed value into Global buffer
   g_seed_value_psa[2] = l_SeedDataArray_ub[4];//Storing Seed value into Global buffer
   g_seed_value_psa[3] = l_SeedDataArray_ub[5];//Storing Seed value into Global buffer
  
   sysSetVariableData(sysvar::DIAG_FVIDEO::PSA_SecAcc::Seed_value,g_seed_value_psa,elCount(g_seed_value_psa));

   l_SeedtempStore[0] = g_seed_value_psa[0]; //Storing Seed value into temp buffer
   l_SeedtempStore[1] = g_seed_value_psa[1]; //Storing Seed value into temp buffer
   l_SeedtempStore[2] = g_seed_value_psa[2]; //Storing Seed value into temp buffer
   l_SeedtempStore[3] = g_seed_value_psa[3]; //Storing Seed value into temp buffer


   if( !((l_SeedDataArray_ub[2] == 0x00) && (l_SeedDataArray_ub[3] == 0x00) && (l_SeedDataArray_ub[4] == 0x00) && (l_SeedDataArray_ub[5] == 0x00)))
   {

    /* Arranging Seed into varaible from stored local temp buffer */
    l_SeedRot_ul = (((dword)(l_SeedtempStore[0]) << 24) +((dword)(l_SeedtempStore[1]) << 16) + ((dword)(l_SeedtempStore[2]) << 8) +((dword)(l_SeedtempStore[3]) << 0));

    /*Copy seed as MSB and LSB into local variables*/
    l_SeedMSBStore_ui = ((dword)(l_SeedRot_ul & 0xFFFF0000)>>16);
    l_SeedLSBStore_ui = ((dword)(l_SeedRot_ul & 0x0000FFFF)>>0);

    /*Copy seed into bytes */
    l_Seedbytestr_1_ub = ((word)(l_SeedMSBStore_ui & 0xFF00) >> 8);
    l_Seedbytestr_2_ub = ((word)(l_SeedMSBStore_ui & 0x00FF) >> 0);
    l_Seedbytestr_3_ub = ((word)(l_SeedLSBStore_ui & 0xFF00) >> 8);
    l_Seedbytestr_4_ub = ((word)(l_SeedLSBStore_ui & 0x00FF) >> 0);      

    /*Copy seed into two variables by adding (4 & 1<<8) and (3 + 2<<8)*/
    l_SeedMSBStore_ui = (l_Seedbytestr_4_ub +((word)(l_Seedbytestr_1_ub << 8)));
    l_SeedLSBStore_ui = (l_Seedbytestr_3_ub + ((word)(l_Seedbytestr_2_ub << 8)));


    /* Key calculation with predefind APPL Key*/
     
     l_KeyStore_MSB_ul = Func_Calculatekey(Variant_KEY, l_SeedMSBStore_ui);
    
    /* Key calculation with Seed LSB and calculted result with APPL key */ 
     l_KeyStore_LSB_ul = Func_Calculatekey(l_SeedLSBStore_ui, l_KeyStore_MSB_ul);
     
     
     l_KeyfinalResult_ul = ((dword)((l_KeyStore_MSB_ul << 16))+((dword)(l_KeyStore_LSB_ul << 0))); // Storing Key with Adding result bytes MSB | LSB
     
     
     g_key_value_psa[0] = ((byte) ((l_KeyfinalResult_ul) >> 24)) ; // Storing Calculated Key into global buffer g_key_value_psa
     g_key_value_psa[1] = ((byte) ((l_KeyfinalResult_ul >> 16))) ; // Storing Calculated Key into global buffer g_key_value_psa
     g_key_value_psa[2] = ((byte) ((l_KeyfinalResult_ul >> 8))) ;  // Storing Calculated Key into global buffer g_key_value_psa
     g_key_value_psa[3] = ((byte) l_KeyfinalResult_ul);            // Storing Calculated Key into global buffer g_key_value_psa
     
    
     sysSetVariableData(sysvar::DIAG_FVIDEO::PSA_SecAcc::Key_value,g_key_value_psa,elCount(g_key_value_psa));
    }
    else
    {
        /* Security access is already enabled */
        sysSetVariableString(sysvar::DIAG_FVIDEO::PSA_SecAcc::Display,"Security Already Enabled");
     }
}

/** @brief this function calculate the key as per varaint
* Into arguments Var_MSB_ui and Var_LSB_ui
* @param Var_MSB_ui  msb of seed
* @param Var_LSB_ui  lsb of seed
* @return word data
*/

word Func_Calculatekey(word Var_MSB_ui,word Var_LSB_ui)
{
  int t_key1 , t_key2, t_Key_MSB, t_Key_LSB;
  int l_Counter;
  int l_temp_LSB, l_temp_MSB ;
  word l_keyResult_ui;
  
  l_temp_LSB = (int) Var_MSB_ui ;
  l_temp_MSB = (int) Var_LSB_ui;

  t_key1 = t_key2 = 0;
  t_Key_MSB = t_Key_LSB = 0;
  
  l_Counter = (int) l_temp_LSB ;

  if (l_temp_LSB>=0)
  {
    do
    {
      l_Counter = l_Counter - 178;
      t_key2++;
    } while(l_Counter > 178);
  }
  else
  {
    do
    {
      l_Counter = l_Counter + 178;
      t_key2--;
    } while(l_Counter < -178);
  }

  t_key1  = l_temp_LSB - (t_key2 * 178);
  t_Key_MSB = (-63 * t_key2)+ (t_key1 * 170);

   if ( t_Key_MSB < 0 )
  {
    t_Key_MSB = t_Key_MSB +30323;  
  }
  
  t_key2 =  0;
  l_Counter = (int) l_temp_MSB;
  if (l_temp_MSB >= 0)
  {
   do
    {
      l_Counter = l_Counter - 177;
      t_key2++;
    } while(l_Counter > 177);
  }
  else
  {
    do
    {
      l_Counter = l_Counter + 177;
      t_key2--;
    } while(l_Counter < -177);
  }


  t_key1 = l_temp_MSB - (t_key2 * 177) ;
  t_Key_LSB= (-t_key2 -t_key2) +(t_key1 * 171) ;

  if ( t_Key_LSB < 0 )
  {
    t_Key_LSB = t_Key_LSB + 30269;
  } 

  l_keyResult_ui =  (word)(t_Key_LSB)|(word)(t_Key_MSB) ;
  
  write("Final key %x \n", l_keyResult_ui);
  return l_keyResult_ui;
}

on sysvar_update sysvar::DIAG_FVIDEO::PSA_SecAcc::`Key
{
  if(@this)
  {
    @sysvar::DIAG_FVIDEO::PSA_SecAcc::Trigger_Status=0;
    sysSetVariableString(sysvar::DIAG_FVIDEO::PSA_SecAcc::Display,"");
    StartDiagService( SEEDNKEYPSARESP );
  }
}

/** @brief This on system variable key of psa will send over diag over can
*/
void PSA_key_req_Evaluate()
{
  if((RxDataBuffer[0] == 0x67)&&(RxDataBuffer[1] == 0x04))
  {
    sysSetVariableString(sysvar::DIAG_FVIDEO::PSA_SecAcc::Display,"Security::Enabled");
    @sysvar::DIAG_FVIDEO::PSA_SecAcc::Trigger_Status=1;   
  }else{
          @sysvar::DIAG_FVIDEO::PSA_SecAcc::Trigger_Status=-1;
          sysSetVariableString(sysvar::DIAG_FVIDEO::PSA_SecAcc::Display,"Security::Disabled::Error");
          
      }
}

/** @brief This on system variable send Bosch key
*/
//Bosch Security Access
on sysvar_update sysvar::DIAG_FVIDEO::Bosch_SecAcc::Seed
{
  if(@this)
  {
    @sysvar::DIAG_FVIDEO::Bosch_SecAcc::Trigger_Status=0;
    sysSetVariableString(sysvar::DIAG_FVIDEO::Bosch_SecAcc::Display,"");
    StartDiagService( SEEDNKEYBOSCHREQUEST );
  }
}


/**@brief this is function for evalute seed request
* @return void data
*/

void Bosch_seed_req_Evaluate()
{
  if((RxDataBuffer[0] == 0x67)&&(RxDataBuffer[1] == 0x61))
  {
    calculate_key_Bosch();
    @sysvar::DIAG_FVIDEO::Bosch_SecAcc::Trigger_Status=1;   
  }else{
          @sysvar::DIAG_FVIDEO::Bosch_SecAcc::Trigger_Status=-1;
      }
}


/** @brief This on system variable send bosch security key 

*/

on sysvar_update sysvar::DIAG_FVIDEO::Bosch_SecAcc::`Key
{
  if(@this)
  {
    @sysvar::DIAG_FVIDEO::Bosch_SecAcc::Trigger_Status=0;
    sysSetVariableString(sysvar::DIAG_FVIDEO::Bosch_SecAcc::Display,"");
    StartDiagService( SEEDNKEYBOSCHRESP );
  }
}

/** @brief this is call function for evalute bosch key
 @return void data
*/

void Bosch_key_req_Evaluate()
{
  if((RxDataBuffer[0] == 0x67)&&(RxDataBuffer[1] == 0x62))
  {
    sysSetVariableString(sysvar::DIAG_FVIDEO::Bosch_SecAcc::Display,"Security::Enabled");
    @sysvar::DIAG_FVIDEO::Bosch_SecAcc::Trigger_Status=1;   
  }else{
          @sysvar::DIAG_FVIDEO::Bosch_SecAcc::Trigger_Status=-1;
          sysSetVariableString(sysvar::DIAG_FVIDEO::Bosch_SecAcc::Display,"Security::Disabled::Error");
          
      }
}

/** @brief this is call function for calcualte bosch key
*/


calculate_key_Bosch()  // Calculate key.
{
  dword  temp1,temp2;
  dword  position;
  temp1=temp2=0;
  for(position = 0; position < 6; position++)
  {
     g_seed_value_bosch[position] = RxDataBuffer[position + 2];
  }
  sysSetVariableData(sysvar::DIAG_FVIDEO::Bosch_SecAcc::Seed_value,g_seed_value_bosch,elCount(g_seed_value_bosch));
  
  Write("Seed: %02x %02x %02x %02x %02x %02x.", g_seed_value_bosch[0], g_seed_value_bosch[1], g_seed_value_bosch[2], g_seed_value_bosch[3], g_seed_value_bosch[4], g_seed_value_bosch[5]);
  if (
       (0x00 == g_seed_value_bosch[0])
       &&
       (0x00 == g_seed_value_bosch[1])
       &&
       (0x00 == g_seed_value_bosch[2])
       &&
       (0x00 == g_seed_value_bosch[3])
       &&
       (0x00 == g_seed_value_bosch[4])
       &&
       (0x00 == g_seed_value_bosch[5])
   )
   {
     Write("Security access level 31 is already unlocked.");
     sysSetVariableString(sysvar::DIAG_FVIDEO::Bosch_SecAcc::Display,"Security Already Enabled");
   }
   else
   {

  //swap g_seed_value_bosch[0] <-->g_seed_value_bosch[5]
  temp1 = g_seed_value_bosch[0];
  g_seed_value_bosch[0] = g_seed_value_bosch[5];
  g_seed_value_bosch[5] = temp1;
  
  //swap g_seed_value_bosch[1] <-->g_seed_value_bosch[4]
  temp1 = g_seed_value_bosch[1];
  g_seed_value_bosch[1] = g_seed_value_bosch[4];
  g_seed_value_bosch[4] = temp1;
  
  //swap g_seed_value_bosch[2] <-->g_seed_value_bosch[3]
  temp1 = g_seed_value_bosch[2];
  g_seed_value_bosch[2] = g_seed_value_bosch[3];
  g_seed_value_bosch[3] = temp1;

  temp1 = ((g_seed_value_bosch[0] << 8) | g_seed_value_bosch[1]);
  temp2 = ((g_seed_value_bosch[2] << 24) | (g_seed_value_bosch[3] << 16) |(g_seed_value_bosch[4] << 8) | (g_seed_value_bosch[5])) ;

  temp2 = ((temp2 >> 1) | ((temp1 & 0x1) << 31));
  temp1 = (temp1 >> 1);
  
  // Fill in the key.
  g_key_value_bosch[0] = (temp1 >> 8) & 0xFF;
  g_key_value_bosch[1] = (temp1  & 0xFF);
  g_key_value_bosch[2] = (temp2 >> 24) & 0xFF;
  g_key_value_bosch[3] = (temp2 >> 16) & 0xFF;
  g_key_value_bosch[4] = (temp2 >> 8) & 0xFF;
  g_key_value_bosch[5] = (temp2 & 0xFF);

  sysSetVariableData(sysvar::DIAG_FVIDEO::Bosch_SecAcc::Key_value,g_key_value_bosch,elCount(g_key_value_bosch));
  }  
}

/*

on sysvar_update sysvar::DIAG_FVIDEO::Bosch_SecAcc::Req
{
   if (@this)
    {
      StartDiagService( RB_SEC_MODE );
      setTimer(BoschUnlockTimer,100);
    }
}

On timer BoschUnlockTimer
{
  StartDiagService( SEEDNKEYBOSCHREQUEST );
}

void calculate_key_Bosch()
{
//Start Key Calculation
dword hexnumber,k1,k2,k3,k3_key;
hexnumber =0;
k3_key=0;
hexnumber =  (hexnumber | (Seed_buf_Bosch[0] & 0x000000FF)<<24);    // diagns_respbyte3 must remain constant //
hexnumber =  (hexnumber | (Seed_buf_Bosch[1] & 0x000000FF)<<16);    // diagns_respbyte4 must remain constant //
hexnumber =  (hexnumber | (Seed_buf_Bosch[2] & 0x000000FF)<<8);    // diagns_respbyte5 must remain constant //
hexnumber =  (hexnumber | (Seed_buf_Bosch[3] & 0x000000FF)<<0);    // diagns_respbyte6 must remain constant //
k1 = 0xB21ACD23;//Bosch-Project
k2 = k1 ^ hexnumber;
k3_key|= ((k2 & 0x000000FF)<<16);
k3_key|= ((k2 & 0x0000FF00)>>8);
k3_key|= ((k2 & 0x00FF0000)<<8);
k3_key|= ((k2 & 0xFF000000)>>16);
  TxDataBuffer[0] = 0x27;
  TxDataBuffer[1] = 0x62;
  TxDataBuffer[5]=((k3_key & 0x000000FF)>>0);
  TxDataBuffer[4]=((k3_key & 0x0000FF00)>>8);
  TxDataBuffer[3]=((k3_key & 0x00FF0000)>>16);
  TxDataBuffer[2]=((k3_key & 0xFF000000)>>24);
//End Key Calculation
}//endkey
*/


/** @brief This on system variable read data to transmit data from panel
*/

on sysvar_update sysvar::DIAG_FVIDEO::sysDataToTransmit_String
{
	dword i,length;
  dword 	SendBufferSize;
  char	MVbuffer[130000] = "";
  char	MVbuffer2[130000] = "0x"; 
  byte 	TransmitBuffer[65000];

  sysGetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_String, MVbuffer, elcount(MVbuffer));
  SendBufferSize = strlen(MVbuffer)+1;

  if( !strncmp(MVbuffer,"Idle",strlen(MVbuffer)) )
		{
			@sysvar::DIAG_FVIDEO::GeneralSettings::sysSendData=0;
		}
	else
		{
      strncpy(MVbuffer2, "0x",3);
			for(i=0; i<= SendBufferSize-3; i+=2)
				{
					MVbuffer2[2] = MVbuffer[i];
					MVbuffer2[3] = MVbuffer[i+1];
					MVbuffer2[4] = 0;
					TransmitBuffer[i/2] = atol( MVbuffer2 );
				}
			length = (SendBufferSize - 1)/2;
      sysSetVariableData(sysvar::DIAG_FVIDEO::sysDataToTransmit,TransmitBuffer,length);
        
      sysSetVariableString(sysvar::DIAG_FVIDEO::sysDataToTransmit_String,"Idle");
		}
}

/** @brief this function send key over uds as per customer

* @return void data
*/
void DynamicKeySend()
{
  long copiedBytes;
  int k;
  if(DynamicFlag == 1 ||DynamicFlag == 2 || DynamicFlag == 3)
  {
    cancelTimer(sectimer1);
    cancelTimer(sectimer2);
    //putValue(Env_Doip_SecurityMode_OutputCAN,"Dynamic Security Mode Active");
    sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN, "Dynamic Security Mode Active");
    //dynamicKeyLen = getValue(Env_DoipSecurity_DynamicInputCAN,DynamicKey);
    sysGetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_DynamicInput, DynamicKey, elCount(DynamicKey));
    dynamicKeyLen = strlen(DynamicKey)+1;
    sendKey[0]=0x27;
    if(DynamicFlag == 1)
    {
      sendKey[1]=SeednKeyFBLRequest[1]+1;
    }
    else if(DynamicFlag == 2)
    {
      sendKey[1]=SeednKeyJLREOLRequest[1]+1;
    }
    else if(DynamicFlag == 3)
    {
      sendKey[1]=SeednKeyCustomerRequest[1]+1;
    }
    k=2;  
    
    strncpy(temp1, "0x",3);
    
    for(j=0;j<dynamicKeyLen;j+=2)
    {
      temp1[2]=DynamicKey[j];
      temp1[3]=DynamicKey[j+1];
      temp1[4]=0;
      sendKey[k]=atol(temp1);
      k++;
     // write("%d",k);
    }
    
    TxLength = (dynamicKeyLen/2)+2;
    StartDiagService( SEEDNKEYJLRRESP);
    
    
    DynamicFlag = 0;
   // putValue(Env_DoipSecurity_DynamicInputCAN," ");
    sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_DynamicInput, " ");
  }
  
}

/** @brief This on system variable it will send doip security key

*/


//on envVar Env_DoipSecurity_DynamicButonCN
on sysvar_update sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::DoipSecurity_DynamicButonCN
{
  DynamicKeySend();
}

/** @brief This on system variable it will send doip security key

*/

//on envVar Env_DoipSecurity_DynamicInputCAN
on sysvar_update sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_DynamicInput
{
  DynamicKeySend();
}


/** @brief this function get key from file
* Into arguments seed
* @param seed buffer of seed to generate key
* @return void data
*/
void DynamicKeyAutoGenerate(char seed[])
{
  char exefilename[256];
  dword exefileHandle;
  char challengefilename[256];
  dword challengefileHandle;
  
  char workingDir[256];
  //getAbsFilePath("\\..\\cs\\cs_security_CBDP\\cbdp_secaccess.exe", exefilename, 256); 
  //getAbsFilePath("\\..\\cs\\cs_security_CBDP\\challenge.txt", challengefilename, 256);
  //getAbsFilePath("\\..\\cs\\cs_security_CBDP\\response.txt", responsefilename, 256);
  //getAbsFilePath("\\..\\cs\\cs_security_CBDP", workingDir, 256);
  registerUserFile("CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FVIDEO\\Security\\Security_CBDP\\cbdp_secaccess.exe", 0);
  getUserFilePath("cbdp_secaccess.exe", exefilename, 256);
  registerUserFile("CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FVIDEO\\Security\\Security_CBDP\\challenge.txt", 0);
  getUserFilePath("cbdp_secaccess.exe", challengefilename, 256);
  registerUserFile("CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FVIDEO\\Security\\Security_CBDP\\response.txt", 0);
  getUserFilePath("cbdp_secaccess.exe", responsefilename, 256);
  registerUserFile("CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FVIDEO\\Security\\Security_CBDP", 0);
  getUserFilePath("CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FVIDEO\\Security\\Security_CBDP", workingDir, 256);
  
  gDynamicWaitcnt=0;
  SetWritePath(workingDir);
  challengefileHandle = openFileWrite ("challenge.txt", 0);
  responsefilehandle = openFileWrite("response.txt",0);    
  
  filePutString (seed,326,challengefileHandle);
  
  filePutString ("",326,responsefilehandle);
       
  fileClose(responsefilehandle);
  sysExec(exefilename,"",workingDir);
  
  responsefilehandle = openFileRead(responsefilename,0);
  
  settimer(secDynamictimer,500);
  
  fileClose(challengefileHandle);
  
  
}

/** @brief this function get key from file
* Into arguments seed
* @param seed buffer of seed to generate key
* @return void data
*/
void DynamicCustomerKeyAutoGenerate(char seed[])
{
  char exefilename[256];
  dword exefileHandle;
  char challengefilename[256];
  dword challengefileHandle;
  char workingDir[256];
  
  //getAbsFilePath("\\..\\cs\\cs_customer_security_CBDP\\CustomerUnlock.exe", exefilename, 256); 
  //getAbsFilePath("\\..\\cs\\cs_customer_security_CBDP\\challenge.txt", challengefilename, 256);
  //getAbsFilePath("\\..\\cs\\cs_customer_security_CBDP\\response.txt", responseCUSTfilename, 256);
  //getAbsFilePath("\\..\\cs\\cs_customer_security_CBDP", workingDir, 256);
  
  registerUserFile("CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FVIDEO\\Security\\Customer_Security_CBDP\\CustomerUnlock.exe", 0);
  getUserFilePath("cbdp_secaccess.exe", exefilename, 256);
  registerUserFile("CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FVIDEO\\Security\\Customer_Security_CBDP\\challenge.txt", 0);
  getUserFilePath("cbdp_secaccess.exe", challengefilename, 256);
  registerUserFile("CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FVIDEO\\Security\\Customer_Security_CBDP\\response.txt", 0);
  getUserFilePath("cbdp_secaccess.exe", responseCUSTfilename, 256);
  registerUserFile("CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FVIDEO\\Security\\Customer_Security_CBDP", 0);
  getUserFilePath("CustomerPrj\\Restbus\\Diagnostics\\CAPL\\FVIDEO\\Security\\Customer_Security_CBDP", workingDir, 256);
  
  gDynamicCUSTWaitcnt=0;
  SetWritePath(workingDir);
  challengefileHandle = openFileWrite ("challenge.txt", 0);
  responseCUSTfilehandle = openFileWrite("response.txt",0);    
  
  filePutString(seed,330,challengefileHandle);
  
  filePutString("",330,responseCUSTfilehandle);
       
  fileClose(responseCUSTfilehandle);
  sysExec(exefilename,"",workingDir);
  
  responseCUSTfilehandle = openFileRead(responseCUSTfilename,0);
  
  settimer(secDynamiccusttimer,500);
  
  fileClose(challengefileHandle);
  
  
}

/** @brief This on system variable it will try access JLR ECU
*/

//JLR security access implementation
on sysvar_update sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::JLR_Prog_UnlockCAN
{
  long copiedBytes;
  securityType = SEEDNKEYFBLREQUEST;
   if ( @this )
    {
      sysGetVariableData(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Doip_Security_SubFunction1CAN, SecurityBuffer, copiedBytes);
      SeednKeyFBLRequest[1] = SecurityBuffer[0];
      if(securityType == SEEDNKEYFBLDYNAMICREQUEST)
      {
        sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN, "Dynamic Security Mode");
        StartDiagService( SEEDNKEYFBLDYNAMICREQUEST );
      }
      else if(securityType == SEEDNKEYFBLREQUEST)
      {
        sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN, "Static Security Mode");
        StartDiagService( SEEDNKEYFBLREQUEST );
      }
      else
      {
        sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN, "Conventional Security Mode");
        StartDiagService( SEEDNKEYREQUEST );
      }
    }
}

/** @brief This on system variable it will try access JLR ECU
*/

on sysvar_update sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::JLR_EOL_UnlockCAN
{
  long copiedBytes;
   if ( @this)
    {
      sysGetVariableData(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Doip_Security_SubFunction2CAN, SecurityBuffer, copiedBytes);
      SeednKeyFBLRequest[1] = SecurityBuffer[0];
      if(securityTypeJLR == SEEDNKEYJLRDYNAMICREQUEST)
      {
        sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN, "Dynamic Security Mode");
        StartDiagService( SEEDNKEYJLRDYNAMICREQUEST );
      }
      else if(securityTypeJLR == SEEDNKEYJLREOLREQUEST)
      {
        sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN, "Static Security Mode");
        StartDiagService( SEEDNKEYJLREOLREQUEST );
      }
      else
      {
        sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN, "Conventional Security Mode");
        StartDiagService( SEEDNKEYJLRREQUEST );
      }
    }
}

/** @brief This on system variable it will try access customer specific ECU
*/

on sysvar_update sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Customer_UnlockCAN
{
  long copiedBytes;
   if (@this)
    {
      
      sysGetVariableData(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Doip_Security_SubFunction3CAN, SecurityBuffer, copiedBytes);
      SeednKeyCustomerRequest[1] = SecurityBuffer[0];
      if(securityTypeCUST == SEEDNKEYCUSTOMERDYNAMICREQUEST)
      {
        sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN, "Dynamic Security Mode");
        StartDiagService( SEEDNKEYCUSTOMERDYNAMICREQUEST );
      }
      else if(securityTypeCUST == SEEDNKEYCUSTOMERREQUEST)
      {
        sysSetVariableString(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::Display_Security_ModeOutputCAN, "Static Security Mode");
        StartDiagService( SEEDNKEYCUSTOMERREQUEST );
        write("env - 2");
      }
      
    }
}

on timer ActPMode
{
    StartDiagService( P_MODE_ACT_P2 );
}

/** @brief This on system variable it will set RBECOL mode 
*/
on sysvar_update sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::RBEOL_Mode
{
    if ( @this )
    {
        StartDiagService( P_MODE_ACT_P1 ); //send part 1
        setTimer(ActPMode,200); //wait and send part2
        
        //Putvalue(EnvRBEOL,0); // Reset Value for next use
        sysSetVariableInt(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::RBEOL_Mode, 0);
    }
}


/** @brief This on system variable it will set RBEOL_PlantMode1 mode 
*/
on sysvar_update sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::RBEOL_PlantMode1
{
    if ( @this )
    {
        StartDiagService( P_MODE_ACT_P1 ); //send part 1
        //setTimer(ActPMode,200); //wait and send part2
        
        //Putvalue(EnvActPMode1,0); // Reset Value for next use
      sysSetVariableInt(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::RBEOL_PlantMode1, 0);
    }
}

/** @brief This on system variable it will set RBEOL_PlantMode2 mode 
*/

on sysvar_update sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::RBEOL_PlantMode2
{
    if ( @this  )
    {
        StartDiagService( P_MODE_ACT_P2 ); //send part 1
        //setTimer(ActPMode,200); //wait and send part2
        
        //Putvalue(EnvActPMode2,0); // Reset Value for next use
      sysSetVariableInt(sysvar::DIAG_FVIDEO::FVIDEO_SECURITY::RBEOL_PlantMode2, 0);
    }
}

/** @brief this function initialize seed and key on start
*/

ini_seed_key()
{

  strncpy(seedList[0], "30819D8001018101008A01009008000000000000000091300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009F201C52424131564944454F312F465633312F4A4C52313A434E30303030319F21102B06010401A9469348150201060113019F2210200000000000000100080000008000009F231020000000000000010008000000800000",  elcount(seedList[0]));
  //write("seedList[0] =%s elcount(dest)=%d",seedList[0],elcount(seedList[0]));
  strncpy(seedList[1], "30819F8001018101008A01009008000000000000000091304D50483533392020202003FF7100490000000000000000000000000000000000020202020202020202020202020202029F201F52424131414253455350312F4F454D41313A434E3A44554D4D5930303030319F210F2B06010401A94693481502016701019F2210300000000000007F10080000000000009F2310000000000000007F100800000000",  elcount(seedList[1]));
  //write("seedList[1] =%s elcount(seedList[1])=%d",seedList[1],elcount(seedList[1]));
  strncpy(seedList[2],"30819F8001018101008A01009008000000000000000091304D50483533392020202003FF7100490000000000000000000000000000000000020202020202020202020202020202029F201F52424131414253455350312F4F454D41313A434E3A44554D4D5930303030319F210F2B06010401A94693481502016701019F2210300000000000007F10080000000000009F2310000000000000007F1008000000000000",elcount(seedList[2]));
  //write("seedList[2] =%s elcount(seedList[2])=%d",seedList[2],elcount(seedList[2]));
  strncpy(seedList[3],"30819F8001018101008A01009008000000000000000091300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009F201E52424131564944454F312F465633312F424F534348313A434E30303030319F21102B06010401A946934815020106011D019F2210200000000000000100080000008000009F231020000000000000010008000000800000",elcount(seedList[3]));
  //write("seedList[3] =%s elcount(seedList[3])=%d",seedList[3],elcount(seedList[3]));
  
  strncpy(seedList[4],"30819C8001018101008A01009008000000000000000091300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009F201C524241354656473345564F5F312F424F534348313A434E30303030319F210F2B06010401A94693481502011C1D019F2210200000000000000100080000008000009F231020000000000000010008000000800000",elcount(seedList[4]));
  
  
  strncpy(keyList[0],"308203BB8001018101019F2982010028138F30A9D4CC3ED31C89795FEAEFA94E7ABB3D1E13027BAAD683273D9AAD14C55D10394FB8E8D907CA34ABEDDB8001534980F964BE27FC8DE86D1F40C200099EF4EB62586DD7BAF8A63DC99CEEEBB84BD5113AE83F29A5E64D9CD378037C71A06FA7409D08D1E0005A9813F8043CAC2CFD455FE8E6EB090DA0863D118D5338D1242CD0CBCD594099A128972860859C939B409A3C6B305B673DE5AD13FC449860CB07400052ED86A25C1F70EA5F9F14EE03FF2B4484A1B7B150BE7C5C33BA42DFD97EBF54B4D07EA0C18BFDE87FB8C39FCAB8A25CABA4969E81FF078F1318F5F82A4A0B85022D1A53A1C9DC53AC401C6DFE8A816C5490F9533094CF0BDD2D3FBF2A8202AB048202A77F218202A27F4E8201985F290100421C52424131564944454F312F465633312F4A4C52313A434E30303030317F49820119060E2B06010401A946934815010108018182010099775462531F09B852752C801F8491CAE2CA197CF3195BBF72FF3ACC1A7A2ECE2641EE1EAC3A28590D733373253FCBD36827C6E16BD717FBDA984C30F836301B59623980B8B4982CF5D9E6F6FEF66B7F03CD706B0D4D33BE3E7BDC31BAAE1F9A3483B58A4F9BDCFC6F23D91289724E67D681231CF98998968D0ACE6799FEC1F6FF6B1AE67037A4D9200EDF45F9E46EF42195C7FDF9564C0D44AFF89497B75906755071C32D3D8457DDAC8625F7C792E5FBA029F0C240E3A303195220CD80C69FD4AD344B932E932D6FDC370793B5DC34E3437FC1EDE1069E17F4EC5F83E820DD2175DF8FE9B882062B76EC9300DF28AED082B1F735BD26ED865D36AB48D609DF82030100015F201C52424134354533464232444538373539374631333A504E30303030317F4C2406102B06010401A9469348150201060113015310200000000000000100080000008000005F25060109000302085F24060408000803005F378201006D943AD262B4FA16CE9DB826893F9A9D6CB3DD8476DD15D3444562C7C035C804E2019A111C80D3940F446944EB4E9839694C3EB6A58C5E0990A7CA809A99C7B6D2415AC7E3AAE6DA776AF2EB5D9DDBBA6DDC702B6D4A54C702CF9681C08BF5CF20D9002AF9C3558D777289E1780E7A4C8CB0955865A8CB70D8F255BC13B5895E277D25086D8EDF96B05C0E06A23F6950149C71D71651CD25E12AD2391846AAA12E10BA9B50E920D59A7EF6BF1FF04D86BAB23891A0835541365EF7820E03063D0407E445D6D1432F68813A2BFB672AA5F515E47AC4D59509427E13D000259740AE7BF0BE2A61760BF6229264E27194B73FB791D230DE5CF449F6FB69A5DD0C08",elcount(keyList[0]));
  //write("keyList[0] =%s elcount(keyList[0])=%d",keyList[0],elcount(keyList[0]));
  strncpy(keyList[1],"308203C28001018101019F2982010039F7A7AEBDA7DF966A44E1E4E3CEB500D470BFDDF9B116BF4994651D0B72ED643B9754A5B4C9025DC8DF0D6FE3896717E3B0D162DAD9FDDA37D82530829F3087DF1AC56AA23A4D8AC0534335B040BB0E1D9C564EED712BFF19FE7A79C276890B49A33A1E3620CA59552D3F547DB55D16F8C5A45E7939409D10A03C9539E42C940978C926613F58D1C4BA30500B2E41C5E384C9C9F4093A1C7C29CCAD0CD1D070E063E4C589D659724083F1A1A0AFFED8C64906676E702544B188E458DFD12D27F9310007794B3298A9F3C917A00F8DD8FED5EAB2163C01819E19CC1DF616CBD6A067F23E3BD1B8D3504AC027CA51E8DE50B49BAF729E483820BC8A90A77C6E0ABF2A8202B2048202AE7F218202A97F4E82019F5F290100421F52424131414253455350312F4F454D41313A434E3A44554D4D5930303030317F49820118060D2B06010401A94693481501090181820100A84281722368FD5F651E97832CBC25A7209D1DDEC8A0D49DF47EFD240B5660A84F20652159FD5780BDFBF2850DA7F2A585AA6DE6336A628B746CEC356B06BF1510776B9273C5B58CB91C332B7E0679E01EF3B97C4DAFCFEA8F6F50323B71B18ACD9282120EA249193B9A89223BA7CC96D6EC20BC33DC0309D33157430E37B59713612A77EEC1A1AADBD5A5BFEF73BE476639E3141B6689E01F0A7595BB3295163B3466E1A5606416A20096CB2F6EE14BCD428C1AEB51C2D6C7BF0F351D193DA806201B059EDBE840092E9F3A0FA72F8D4716A8D7D97BC75CC5FDB480CBB0AC4A489E03F004C80277F614C96621B909FA496484F5C94B96B5E6D512C693999D1F82030100015F202252424134434644373533364146354645303444423A504E3A44554D4D5930303030317F4C23060F2B06010401A94693481502016701015310000000000000007F10080000000000005F25060108000200085F24060200000200075F37820100594E2F425DA8A208AD2284FBA8B8D3E5CFC52D6896D46F6C7132AF5F9080166EA989EA9E805D7018A4B6E801F02097DF1E54C0ACEF7D2B28B5D5F8C5964C30094F211E4C5A7F93EDDC228CB10A30DAE4A934C03F4E7B5129045E95D4178AA72830401812066E4354576A7D8DC90ACF82C215423C7D99197731005B8952145C708565147C59336EAF068AD59FE319D54F9091DBBBF10DE78B12975D614F15D9717BCFEFEFF003E999042C65DD5FC5FB3E4D6A70CA20C7C0235670B1BC3D9BA31A15AD393A0E29D7E44A39D9786B321C8878ADBA68701462414C8D519782E3A62085B9A4C9B73F08699C5E8BFF9DD5112755588FB73E84DF6690",elcount(keyList[1]));
  //write("keyList[1] =%s elcount(keyList[1])=%d",keyList[1],elcount(keyList[1]));
  strncpy(keyList[2],"308203C28001018101019F2982010039F7A7AEBDA7DF966A44E1E4E3CEB500D470BFDDF9B116BF4994651D0B72ED643B9754A5B4C9025DC8DF0D6FE3896717E3B0D162DAD9FDDA37D82530829F3087DF1AC56AA23A4D8AC0534335B040BB0E1D9C564EED712BFF19FE7A79C276890B49A33A1E3620CA59552D3F547DB55D16F8C5A45E7939409D10A03C9539E42C940978C926613F58D1C4BA30500B2E41C5E384C9C9F4093A1C7C29CCAD0CD1D070E063E4C589D659724083F1A1A0AFFED8C64906676E702544B188E458DFD12D27F9310007794B3298A9F3C917A00F8DD8FED5EAB2163C01819E19CC1DF616CBD6A067F23E3BD1B8D3504AC027CA51E8DE50B49BAF729E483820BC8A90A77C6E0ABF2A8202B2048202AE7F218202A97F4E82019F5F290100421F52424131414253455350312F4F454D41313A434E3A44554D4D5930303030317F49820118060D2B06010401A94693481501090181820100A84281722368FD5F651E97832CBC25A7209D1DDEC8A0D49DF47EFD240B5660A84F20652159FD5780BDFBF2850DA7F2A585AA6DE6336A628B746CEC356B06BF1510776B9273C5B58CB91C332B7E0679E01EF3B97C4DAFCFEA8F6F50323B71B18ACD9282120EA249193B9A89223BA7CC96D6EC20BC33DC0309D33157430E37B59713612A77EEC1A1AADBD5A5BFEF73BE476639E3141B6689E01F0A7595BB3295163B3466E1A5606416A20096CB2F6EE14BCD428C1AEB51C2D6C7BF0F351D193DA806201B059EDBE840092E9F3A0FA72F8D4716A8D7D97BC75CC5FDB480CBB0AC4A489E03F004C80277F614C96621B909FA496484F5C94B96B5E6D512C693999D1F82030100015F202252424134434644373533364146354645303444423A504E3A44554D4D5930303030317F4C23060F2B06010401A94693481502016701015310000000000000007F10080000000000005F25060108000200085F24060200000200075F37820100594E2F425DA8A208AD2284FBA8B8D3E5CFC52D6896D46F6C7132AF5F9080166EA989EA9E805D7018A4B6E801F02097DF1E54C0ACEF7D2B28B5D5F8C5964C30094F211E4C5A7F93EDDC228CB10A30DAE4A934C03F4E7B5129045E95D4178AA72830401812066E4354576A7D8DC90ACF82C215423C7D99197731005B8952145C708565147C59336EAF068AD59FE319D54F9091DBBBF10DE78B12975D614F15D9717BCFEFEFF003E999042C65DD5FC5FB3E4D6A70CA20C7C0235670B1BC3D9BA31A15AD393A0E29D7E44A39D9786B321C8878ADBA68701462414C8D519782E3A62085B9A4C9B73F08699C5E8BFF9DD5112755588FB73E84DF66906EEAC927EF7055",elcount(keyList[2]));
  //write("keyList[2] =%s elcount(keyList[2])=%d",keyList[2],elcount(keyList[2]));
  strncpy(keyList[3],"308203BC8001018101019F29820100A84CA20439021CAAF51F373DBC1372DE789D591979C1799EDDA851AF607FB1B1B4459C6219C2C10FD05734AC1978100C0106EBFC9867B806D0822ED4345611E61A5E48F44EC431E9CA7FBE28F2A9C2198597916F2E25CB59145DCEE3E69BA7D86E1EA572A4440628F29D39C408E31E90BC4C2E45BE3A68BB0BE9814A7B8F7126BBA3108CEFD5E6099AAB9042F75DEC8DDB1A1BB39A199BB3520684A53CEE1A27A0A72E84D226DE7559811D0DCE95903CF9387DA6FCF2C496E37350AB71A262621FB1EE06F888C298FBBF32F90637318A2C0A555496CDB63A1141F4614ADC40E7AA7D96AF38A27BAD06C8D3F8E14F47601C91C073220954E7FE0ABECD06C09DBDBF2A8202AC048202A87F218202A37F4E8201995F290100421E52424131564944454F312F465633312F424F534348313A434E30303030317F49820118060D2B06010401A94693481501080181820100BA2BF24110DC1673F048BDC0FCD654BB11D6326E016ACF4837956A23171408BC4061BCAE4821A382A5A1CB00E5C4097DE648FFE0CCA8B21A92E189DF5059B82DD9BFFE4AF45F255BCF85258F58A3322B96BE38A709BB9EB32ADCF3AF8EB065348473AA78946F5EB5DA9B455BCD1C90D27084D4D0D7E7DEE62BC55B553D08E1AB82400369D09A73F1169E381482EA58ABB7112DD47FF6793999CE61CE69926AF74AA0EF730D1C4F8033427BD1013A4334ED4FAD1A9818850FB4E667A05340C938ED1BE37C687BED5583238ECF182A99696D596EFABBF25C3D1EC9A5E49C727C4BF023F9211622BEE6CB2E64074B52A885DF531EB4DB65FAAC3248A072E2B2C48982030100015F201C52424134453941344344434632433545434339313A504E30303030317F4C2406102B06010401A946934815020106011D015310200000000000000100080000008000005F25060200000400025F24060400000401075F378201009AA1C4A9BCBE4E37655661CEF1E8667E4C347145B9315CD739A9087C641AF3B96E64E7AA80FE63223B2E6A094A7B49F950A280AE4A12C8EF582322D1BF255D1321336EC519138952C44EC2EA0BE1F45D0295D1EE557A67C37F9C5909BAEE957D4577D42A356B8E9733023F7C7EE8C11C4CF4ACD2D53E55C6BEB6A4EAE2D0994EB7DEB76C4049C7A6192D61851870404FEA55E655B8FEFBADE5A1F7A08DACD174FFBD9A92C68FEE8D4AE43DBD7556B854CF37A5A849DAE7C74C361F4F9DCB67322B40C37F0753974FD86894AA12AB1324BD089090EF9705E881ECD76F44410B037E342C3CBE4FB9976126F6BC67CF69F1E3080DE9D7500793AB879EBB8690F5CB",elcount(keyList[3]));
  //write("keyList[3] =%s elcount(keyList[3])=%d",keyList[3],elcount(keyList[3]));
  
  strncpy(keyList[4],"308205398001018101019F298201808399D309E95EB4F993E64C1693D10612294A7BAA57F98134C8D5E0B7693C200539FC83F4A3F6AAE864C468CA32CC73BBBE8E0A601E071077C154334FB6B1F508342374A8691D3632551438F2BDFA13783CE91402BDA9EB9CDF4B708A1C519D196BA7A45844E3DEEF5C67AFC90D63164DD93585692207E65A87627B5AB2773FBB24DFACA46BB9242FF15A8A0584B81B6C71D1C148389007758E12740AEEB06F050239B449BA079499630A6151781192E56268CEF1E4027158AD1268034D76CB6119EBDC0A7E141693A0D9DFB88C8A244B8BA7E1CAC99EE6DBA522DC2E5627B1E46BD158260A0902B5B77F7CE85512A36031203F9FBC3BDC96F05447461B266EFAE170AB545EB6A5E6AC5DF05E2D573750359BD11143382B8CC3EB74C1D9CDF4561D952EF08B238E39FEF37C864DBEC2730F77849BAFC8B439127F0E7A54260DA19A35E9EDDA5A47366D6AB4AA771A1273DD2CDD1D268E8C3DA16448EBEB63B1D57E4349ED99BA9A6CDE607B9B2AA01BED8686B0DC5BDC295C3EB7C9188F3673F7BF2A8203A9048203A57F218203A07F4E8202165F290100421C524241354656473345564F5F312F424F534348313A434E30303030317F49820198060D2B06010401A94693481501080581820180B8EFCFBFB20384CE901B3CA3A74D88B178869D15A131EDB3B374839D69B54497445746279923DD0E9735B76834D77803818CCDC82C9A2A438C0E076BEE0AF8091BFFC599C170D9793EAB9D7891E6B95ED80C1824C059A6F367D938D6921F9BDD8879E37E61941D80D215BCC8BBE55037A48C7AD4C7A70444A323E1493E7607324B60F376B439A8B71B6F78E7079769775251D160EE7AA83775FA1AC41ABB3EF3E8C657556DD33C7BAE8214C1C883C2C95890CED251AC75B1B87DB76BB9E68068AD3BDA5FC6E60491F9972FBE4F62FADCC5B4ABF22277614352E2A768954020CF3B8F7DD8C3E1CB7146EFB093A16E8CA6EC4C217E31420FEC92C1792AA9B7065176994FF016246C30EC6B8EA6810CAB3AE76BED9DA40D06377B4CAE397366F42808B472ECB6D44674407CC903F824201A2A097C65024CBBE6340F3187307D0E41212EB23CB4D60304D4DAF9B7AA8203818B28C007643255E12ACA887C86D31F7476BAF1A164FD9DDD12FFB6507FB76EAEAAC36D785B183E1FAE67E67D6612001182030100015F201C52424134444333454242314535354444363241373A504E30303030317F4C23060F2B06010401A94693481502011C1D015310200000000000000100080000008000005F25060203000602075F24060503000602095F3782018089C4A1D38064B25BA564632F619B317923726079B4A7D730AAA33BE0810722B27DABEA42AA873A6FDA929EC20D6DFA7CADDB297F1A2E39E133FB4C0350D4D5E59C10EBE178ED56EAD361D322B167F6A328807767409D3D07CF8F7C716D9D8E1D880AB424DF56378B8DD679DA0CB9DACC7F1229882B2766C01A7237818F7FE1C22ACFE4F9F3A1DF8D4A48A2C41FC8229F1F42EFA2C6EF92368B19CF1E103B0679F8508D803C84FB6C6E3ADC0FE5C847CCE7534F3D7598F2641516E5B3A92A6340E96911BABBAFFEFD835524E4F7A22BCA20069028FEC0BF1436D9BA4D11987B83517C07767284FFA08C4C1BFCCC91763430DC05AE8459D83F5675455C1E99BA21E3FFB7261BAA69403B2B3B6EC74AE8E692AEDE1184961980E078BEB8D8579196FC760F8D04B1B8243E8AD87EC19FB24F923F0419111D76E53D1B6DA7807A73BBD37D2A5A2768C4BAA81A548E8419E0708AF7915FA87B34D702FBD34C5A4B15364DBD51544C23B440D1209723AE9C7B67335C05683AB49D9830C91A3F64DCE2E8",elcount(keyList[4]));
  

}


