/*@!Encoding:1252*/
/**
 * @file copy_cm_project.can
 * @author ADAS_HIL_TEAM
 * @date 08-21-2023
 * @brief 
 *
 * ################################################################
 * C O P Y R I G H T S
 * ----------------------------------------------------------------
 * Copyright (c) 2023 by Robert Bosch GmbH. All rights reserved.
 
 * The reproduction, distribution and utilization of this file as
 * well as the communication of its contents to others without express
 * authorization is prohibited. Offenders will be held liable for the
 * payment of damages. All rights reserved in the event of the grant
 * of a patent, utility model or design.
 *
 * ################################################################
*/

includes
{
	#include "..\..\..\CustomerPrj\CarMaker\camera_view.cin"
	#include "..\..\..\CustomerPrj\CarMaker\vehicle_variant.cin"
	#include "..\..\..\CustomerPrj\CarMaker\cm_versions.cin"
}

variables
{
  char absfilePath[256];
  char absdirPath[256];
  msTimer cf_modify_tmr, copy_tmr, cm_tmr, mvnx_fvideo_tmr, mvnx_svs_tmr, rendering_pc_status_timer, cm_runtime_error_tmr, mvnx_fps_timer, copy_from_shared, mvnx_scenario_tmr;
  msTimer net_share_tmr_rendering;
  int wait_time = 1000; 
  int bufferLength = 256;
  char buf[256];
  char buf_cm[256];
  char buf_mvnx_fv[256];
  char buf_mvnx_svs[256];
  char buf_mvnx_status[256];
  char buf_cm_error_message[256];
  char buf_mvnx_fps[256];
  char buf_mvnx_scene[256];
  char buf_copy_back[256];
  char params[256];
  char cm_error_buf[256];
  int64 buf_svs_sensors, buf_uss_sensor, buf_dil, buf_rsi;
  double buf_camera_x_direciton,buf_camera_y_direciton, buf_camera_z_direciton;
  double buf_camera_x_roll, buf_camera_y_pitch, buf_camera_z_yaw;
  dword fh,fh_modify,fh_cm, fh_mvnx_fv, fh_mvnx_svs, fh_mvnx_status, fh_error_log, fh_fps_status, fh_copy_repo, fh_mvnx_scene;
  char buf_net_share_rendering[256];        // New buffer for filehandler for network drives status check.
  dword fh_net_share_rendering;             // New filehandler for network drives status check.
  long status_net_share_rendering;          // New status read for network drives status check.
  long status, status_cm, status_mvnx_fv, status_mvnx_svs, status_mvnx, status_fps_mvnx, status_copy_from_rt, status_mvnx_scene, status_byo_rt;
  long timeout_max = 600000; // Copy timer timeout to 10 minutes
  long timeout_apps = 600000; // Timeout for starting MovieNX/CarMaker (10 min)
  long check_timeout_modify_tmr = 0;
  long check_timeout_copy_tmr = 0;
  long check_timeout_cm_tmr = 0;
  long check_timeout_mvnx_fvideo_tmr = 0;
  long check_timeout_mvnx_svs_tmr = 0;
  long check_timeout_copy_from_shared = 0;
  long check_timeout_mvnx_fps_timer = 0;
  long check_timeout_rendering_pc_status_timer = 0;
  long check_timeout_mvnx_scenario_tmr = 0;
  char cm_version[20];
  char camera_view[20];
  char vehicle_variant[40];
}

on start
{

}
/**
* @brief Runs several batch scripts when hil_ctrl::hil_mode == Carmaker (modify_carfiles.bat, start_client.bat, copy_Carmker_project.bat)
* 
*/
on sysvar hil_ctrl::hil_mode
{
    if (@hil_ctrl::simulated_bus_mode==0)
    {
      write("Execution with RT Rack");
      // RT rack case - modify gpuconfig file, modify car file
      if (@this == Carmaker && @hil_ctrl::init_rbs==0)
        {	
          
          modify_carfiles();
          
          // Open rpyc server and check Connection with Rendering PC
          getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts\\start_client.bat check_connection", absfilePath, 256);
          getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts", absdirPath, 256);
          sysExec(absfilePath, absdirPath);		     
          setTimerCyclic(rendering_pc_status_timer,wait_time,wait_time);

        } 
    }
    else if (@hil_ctrl::simulated_bus_mode==1)
    {
      write("Execution without RT Rack");
      if (@this == Carmaker && @hil_ctrl::init_rbs==0)
      {	
        // TBD modify gpu file
        
        modify_carfiles();
        write("Calling client check");
        // Open rpyc server and check Connection with Rendering PC
        getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts\\start_client.bat check_connection dummy", absfilePath, 256); // "dummy" addded as argument to avoid copy on RT Rack
        getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts", absdirPath, 256);
        sysExec(absfilePath, absdirPath);		
        setTimerCyclic(rendering_pc_status_timer,wait_time,wait_time);
      }
    }
    // TBD use case to handle Linux cloud execution no gpufile modification, no copy folders
}


void modify_carfiles()
{
	sysGetVariableLongLong(sysVar::hil_ctrl::svs_cameras_sim,buf_svs_sensors); 
  sysGetVariableLongLong(sysVar::hil_ctrl::ultrasonic_sensors_sim,buf_uss_sensor);
  sysGetVariableFloat(sysVar::hil_ctrl::movienx_camera_x_direciton, buf_camera_x_direciton);
  sysGetVariableFloat(sysVar::hil_ctrl::movienx_camera_y_direciton, buf_camera_y_direciton);
  sysGetVariableFloat(sysVar::hil_ctrl::movienx_camera_z_direciton, buf_camera_z_direciton);
  sysGetVariableFloat(sysVar::hil_ctrl::movienx_camera_x_roll, buf_camera_x_roll);
  sysGetVariableFloat(sysVar::hil_ctrl::movienx_camera_y_pitch, buf_camera_y_pitch);
  sysGetVariableFloat(sysVar::hil_ctrl::movienx_camera_z_yaw, buf_camera_z_yaw);
  sysGetVariableLongLong(sysVar::hil_drv::DIL_mode, buf_dil);
  sysGetVariableLongLong(sysVar::hil_ctrl::radar_fc_raw_sim, buf_rsi);
  if (@hil_ctrl::cm_modify_test_run == 1) {
	  strncpy(vehicle_variant, vehicle_variant_matrix[@hil_ctrl::vehicle], 64);
	  snprintf(params,elcount(params),"%d %d %f %f %f %f %f %f %d %d %s", buf_svs_sensors, buf_uss_sensor, buf_camera_x_direciton, buf_camera_y_direciton,
		  buf_camera_z_direciton, buf_camera_x_roll, buf_camera_y_pitch, buf_camera_z_yaw, buf_dil, buf_rsi, vehicle_variant);
  } else {
	 snprintf(params,elcount(params),"%d %d %f %f %f %f %f %f %d %d", buf_svs_sensors, buf_uss_sensor, buf_camera_x_direciton, buf_camera_y_direciton,
      buf_camera_z_direciton, buf_camera_x_roll, buf_camera_y_pitch, buf_camera_z_yaw, buf_dil, buf_rsi); 
  }
	
  getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts\\modify_carfiles.bat", absfilePath, 256);
  getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts", absdirPath, 256);
  write("Command to be called is :: %s %s", absfilePath, params, absdirPath); 
  sysExec(absfilePath, params, absdirPath);
  setTimerCyclic(cf_modify_tmr,wait_time,wait_time);
}

/**
* @brief Copies CarMaker Project locally to D:\CarMaker_Project on Single PC only for Hybrid Logic
*/
void local_copy_hybrid()
{
  write("Copy CM Project locally");
  getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts\\copy_Carmker_project.bat", absfilePath, 256);
  getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts", absdirPath, 256);
  sysExec(absfilePath, absdirPath);
  setTimerCyclic(copy_tmr,wait_time,wait_time);
}

/**
* @brief Terminates all MovieNx instances on Canoe preStop
*/
on preStop
{
    if (@hil_ctrl::rendering_pc_status_buf == 1)
    {
      getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts\\start_client.bat terminate_movienx all_instances", absfilePath, 256);
      getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts", absdirPath, 256);
      sysExec(absfilePath, absdirPath);      
    }
}


/**
* @brief Timer to check the value written in D:\\CarMaker_Shared\\cf_modify_done.txt
*/
on timer cf_modify_tmr
{
  if (@hil_ctrl::simulated_bus_mode==0)
  {		
	  long local_status = 0; 
      char buf[256] = "";
	  fh_modify = openFileRead("D:\\CarMaker_Shared\\cf_modify_done.txt",0);
      fileGetString(buf,bufferLength,fh_modify);
      fileClose(fh_modify);
      check_timeout_modify_tmr += wait_time;
//       write("check timeout_modify_tmr is: %d",check_timeout_modify_tmr);
      if (check_timeout_modify_tmr >= timeout_max)
      {
         writeLineEx(1,3,"Modifying Carfiles failed!!!Timeout of 10 mins exceeded.");
         cancelTimer(cf_modify_tmr); 
         sysSetVariableString(sysvar::hil_ctrl::abort_message, "CarmakerCarFilesUpdateError");
         check_timeout_modify_tmr = 0;
      }
      
      strtol(buf, 0, local_status);
      switch (local_status)
      {
        case 1:
          write("Modifying Carfiles succesfully");
          cancelTimer(cf_modify_tmr); // if modification OK then continue with CM logic
          getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts\\copy_Carmker_project.bat", absfilePath, 256);
          getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts", absdirPath, 256);
          sysExec(absfilePath, absdirPath);
          setTimerCyclic(copy_tmr,wait_time,wait_time);
          setTimerCyclic(cm_tmr,wait_time,wait_time);
          check_timeout_modify_tmr = 0;
          local_status = 0; // reseting the variable to avoid false runs
          break;
        case 2:
          writeLineEx(1,3,"Modifying Carfiles failed!!!.");
          cancelTimer(cf_modify_tmr);
          check_timeout_modify_tmr = 0;
          sysSetVariableString(sysvar::hil_ctrl::abort_message, "CarmakerCarFilesUpdateError");
		  local_status = 0;
          break;
      }
  }
  else if (@hil_ctrl::simulated_bus_mode==1) //add condition for Hybrid setup - Rendering PC present
  {		
	  long local_status = 0; 
    char buf[256] = "";
	  fh_modify = openFileRead("D:\\CarMaker_Shared\\cf_modify_done.txt",0);
      fileGetString(buf,bufferLength,fh_modify);
      fileClose(fh_modify);
      check_timeout_modify_tmr += wait_time;
//       write("check timeout_modify_tmr is: %d",check_timeout_modify_tmr);
      if (check_timeout_modify_tmr >= timeout_max)
      {
         writeLineEx(1,3,"Modifying Carfiles failed!!!Timeout of 10 mins exceeded.");
         cancelTimer(cf_modify_tmr); 
         sysSetVariableString(sysvar::hil_ctrl::abort_message, "CarmakerCarFilesUpdateError");
         check_timeout_modify_tmr = 0;
      }
      
      strtol(buf, 0, local_status);
      switch (local_status)
      {
        case 1:
          write("Modifying Carfiles succesfully");
          cancelTimer(cf_modify_tmr); // if modification OK then continue with CM logic
          // Continue with Hybrid logic - Logic waits now for Rendering PC check if Rendering exist, local copy is triggered before starting CM.
          setTimerCyclic(copy_tmr,wait_time,wait_time);
          setTimerCyclic(cm_tmr,wait_time,wait_time);
          check_timeout_modify_tmr = 0;
          local_status = 0; // reseting the variable to avoid false runs
          break;
        case 2:
          writeLineEx(1,3,"Modifying Carfiles failed!!!.");
          cancelTimer(cf_modify_tmr);
          check_timeout_modify_tmr = 0;
          sysSetVariableString(sysvar::hil_ctrl::abort_message, "CarmakerCarFilesUpdateError");
		  local_status = 0;
          break;
      }
  }
}


/**
* @brief Timer to check the value written in D:\\CarMaker_Shared\\done.txt
*/
on timer copy_tmr
{
  // Copy into X drive shared with rendering pc and rt rack
  if (@hil_ctrl::simulated_bus_mode==0 || (@hil_ctrl::simulated_bus_mode==1 && @hil_ctrl::abort_msg_movienx==1)) //If Distributed mode or Hybrid mode active.
  {
    char buf[256] = "";
    long copy_status = 0;
    fh = openFileRead("D:\\CarMaker_Shared\\done.txt",0);
      fileGetString(buf,bufferLength,fh);
      fileClose(fh);
      check_timeout_copy_tmr += wait_time;
//      write("check timeout_copy_tmr is: %d",check_timeout_copy_tmr);
      if (check_timeout_copy_tmr >= timeout_max)
      {
         write("Copying CarMaker project failed!!!Timeout of 10 mins exceeded.");
         cancelTimer(copy_tmr); 
         sysSetVariableString(sysvar::hil_ctrl::abort_message, "Carmakercopyfoldererror");
         check_timeout_copy_tmr = 0;
      }
      
      strtol(buf, 0, copy_status);
      switch (copy_status)
      {
        case 1:
          write("CarMaker project copied succesfully");
          cancelTimer(copy_tmr);
          check_timeout_copy_tmr = 0;
          @hil_ctrl::copy_cm_done = 1;
          copy_status = 0; // reseting the variable to avoid false runs
          break;
        case 2:
          writeLineEx(1,3,"Error copying CarMaker project.Permission deined");
          cancelTimer(copy_tmr);
          check_timeout_copy_tmr = 0;
          sysSetVariableString(sysvar::hil_ctrl::abort_message, "Carmakercopyfoldererror");
          copy_status = 0; // reseting the variable to avoid false runs
          break;
        case 3:
          writeLineEx(1,3,"Copying CarMaker project failed!!!.");
          cancelTimer(copy_tmr);
          check_timeout_copy_tmr = 0;
          sysSetVariableString(sysvar::hil_ctrl::abort_message, "Carmakercopyfoldererror");
          copy_status = 0; // reseting the variable to avoid false runs
          break;  
      }
  }
  else if (@hil_ctrl::simulated_bus_mode==1 && @hil_ctrl::abort_msg_movienx!=1)
  {
    // No RT rack neither Rendering PC therefore no copy of folders neeed
    write ("No Rendering PC available - Single PC");
    @hil_ctrl::copy_cm_done = 1;
    cancelTimer(copy_tmr);
  }
}

/**
* @brief Calls start_fvideo_render(); or start_svs_vib();
*/
on sysvar hil_ctrl::load_cm_done
{
  // Vector RT rack is present
//  write("load cm done on copy_cm_project"); // for debugging only
  if ((@hil_ctrl::simulated_bus_mode==0) && (@hil_ctrl::rt_rack_state==2))
  {
    if ((@this == 1) && (@hil_ctrl::fvideo_sim == 2) && (@hil_ctrl::movienx_fvideo_done == 0)) //Start MovieNX for front video if conditions met only once.
    {
      start_fvideo_render("192.168.1.5");
    }
    else if ((@this == 1) && (@hil_ctrl::svs_cameras_sim == 1) && (@hil_ctrl::movienx_svs_done == 0)) //Start MovieNX for SVS if conditions met only once.
    {
      start_svs_vib("192.168.1.5");
    }
    else
    {
      if (@hil_ctrl::load_cm_done == 1) @hil_ctrl::cm_ready_to_start = 1;
      else {
        @hil_ctrl::cm_ready_to_start = 0;
      }
        
    }
  }
  else if ((@hil_ctrl::simulated_bus_mode==1) && (@hil_ctrl::abort_msg_movienx==1))
  {
//    write("Retake logic control");

     if ((@this == 1) && (@hil_ctrl::fvideo_sim == 2) && (@hil_ctrl::movienx_fvideo_done == 0)) //Start MovieNX for front video if conditions met only once.
     {
       write("Starting MovieNX on Rendering PC for FVideo");
       start_fvideo_render("192.168.1.10");
     }
     else if ((@this == 1) && (@hil_ctrl::svs_cameras_sim == 1) && (@hil_ctrl::movienx_svs_done == 0)) //Start MovieNX for SVS if conditions met only once.
     {
       write("calling SVS CM Hybrid");
       start_svs_vib("192.168.1.10");
     }
     else
     {
       if (@hil_ctrl::load_cm_done == 1) @hil_ctrl::cm_ready_to_start = 1;
       else {
         @hil_ctrl::cm_ready_to_start = 0;
       }
         
     }
  }
}

/**
* @brief Calls start_svs_vib(); with main trigger hil_ctrl::movienx_fvideo_done = 1
*/
on sysvar hil_ctrl::movienx_fvideo_done
{
  canceltimer(mvnx_fvideo_tmr);
  if ((@this == 1) &&  (@hil_ctrl::svs_cameras_sim == 1) && (@hil_ctrl::movienx_svs_done == 0) && (@hil_ctrl::rt_rack_state==2)) //Start MovieNX for SVS if conditions met only once.
  {
    start_svs_vib("192.168.1.5");   
  }
  else if ((@this == 1) &&  (@hil_ctrl::svs_cameras_sim == 1) && (@hil_ctrl::movienx_svs_done == 0) && (@hil_ctrl::simulated_bus_mode==1))
  {
//    write("Entering hybrid SVS"); // debug only
    start_svs_vib("192.168.1.10");  // hybrid logic works only if correct parameters available on GPU Config and Car File
  }
  else if (@this == 2)
  {
    @hil_ctrl::cm_ready_to_start = 2; 
  }
  else if (((@hil_ctrl::svs_cameras_sim != 1)) && @hil_ctrl::hil_mode ==  Carmaker)
  {
    @hil_ctrl::cm_ready_to_start = 1;
  }
  
}

on sysvar hil_ctrl::cm_ready_to_start
{
  if ((@this == 1) && (@hil_ctrl::movienx_fvideo_done == 1)) {
    setTimerCyclic(mvnx_scenario_tmr,wait_time,wait_time);  
  }
}
/**
* @brief Sets @hil_ctrl::cm_ready_to_start depending on hil_ctrl::movienx_svs_done value
*/
on sysvar hil_ctrl::movienx_svs_done
{
  canceltimer(mvnx_svs_tmr);
  if (@this ==1)
  {    
   @hil_ctrl::cm_ready_to_start = 1;
  }
  else if (@this == 2)
  {
   @hil_ctrl::cm_ready_to_start = 2; 
  }
}

/**
* @brief Starts MovieNX FVideo on Rendering PC
* @param None
* @return Void
*/
void start_fvideo_render(char host_ip[]) 
{
//    if (@hil_ctrl::simulated_bus_mode==0)
//    {
    strncpy(vehicle_variant, vehicle_variant_matrix[@hil_ctrl::vehicle], 64);
    strncpy(camera_view, camera_view_matrix[@hil_ctrl::camera_view], 64);
    strncpy(cm_version, cm_version_matrix[@hil_ctrl::cm_version][0], 64);
    getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts\\start_client.bat movienx_fvideo ", absfilePath, 256);
    strncat(absfilePath, cm_version, 256);
    strncat(absfilePath, " ", 256);
    strncat(absfilePath, camera_view, 256);
    strncat(absfilePath, " ", 256);
    strncat(absfilePath, vehicle_variant, 256);
    strncat(absfilePath, " ", 256);
    strncat(absfilePath, host_ip, 256);
    getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts", absdirPath, 256);
    write("Command to be called is :: %s", absfilePath);
    sysExec(absfilePath, absdirPath);
    setTimerCyclic(mvnx_fvideo_tmr,wait_time,wait_time);
//    }    
 }

/**
* @brief Starts MovieNX SVS on Rendering PC
* @param None
* @return Void
*/ 
void start_svs_vib(char host_ip[])

{
//    if (@hil_ctrl::simulated_bus_mode==0)  //WARNIN: check commented out.Check if issues with distributed and hybrid logic.
//    {
      strncpy(cm_version, cm_version_matrix[@hil_ctrl::cm_version][0], 64);    
      getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts\\start_client.bat movienx_svs", absfilePath, 256);
      strncat(absfilePath, " ", 256);
      strncat(absfilePath, cm_version, 256);
      strncat(absfilePath, " ", 256);
      strncat(absfilePath, host_ip, 256);
      getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts", absdirPath, 256);
      sysExec(absfilePath, absdirPath);
      setTimerCyclic(mvnx_svs_tmr,wait_time,wait_time);
//    }    
}

/**
* @brief Terminates MovieNX Fvideo on Rendering PC when hil_ctrl::fvideo_sim = 0
*/
on sysvar hil_ctrl::fvideo_sim
{
  if (@this == 0)
  {
    if ((@hil_ctrl::simulated_bus_mode==0) && (@hil_ctrl::rt_rack_state==2)) // Distributed mode only
    {
      getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts\\start_client.bat terminate_movienx fvideo", absfilePath, 256);
      getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts", absdirPath, 256);
      sysExec(absfilePath, absdirPath);
      @hil_ctrl::movienx_fvideo_done = 0;
    }
  }
}

/**
* @brief Terminates MovieNX SVS on Rendering PC when hil_ctrl::fvideo_sim = 0
*/
on sysvar hil_ctrl::svs_cameras_sim
{
  if (@this == 0)
  {
    if (@hil_ctrl::simulated_bus_mode==0)
    {
      getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts\\start_client.bat terminate_movienx svs", absfilePath, 256);
      getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts", absdirPath, 256);
      sysExec(absfilePath, absdirPath);
      @hil_ctrl::movienx_svs_done = 0;
    }
  }
}


/**
* @brief Timer to check the value written in D:\\CarMaker_Shared\\cm_status.txt
*/
on timer cm_tmr
{
  // RT rack available, check for carmaker start app in the RT rack
  if (@hil_ctrl::simulated_bus_mode==0)
  {
    fh_cm = openFileRead("D:\\CarMaker_Shared\\cm_status.txt", 0);
    fileGetString(buf_cm,bufferLength,fh_cm);
    fileClose(fh_cm);
    check_timeout_cm_tmr += wait_time;
//    write("check timeout_cm_tmr is: %d",check_timeout_cm_tmr);
    if (check_timeout_cm_tmr >= timeout_apps)
    {
      writeLineEx(1,3,"Starting CarMaker failed!!!Timeout exceeded.");
      cancelTimer(cm_tmr);
      sysSetVariableString(sysvar::hil_ctrl::abort_message, "Carmakerstarterror");
      check_timeout_cm_tmr = 0;
    }
    
    strtol(buf_cm, 0, status_cm);
    switch (status_cm)
    {
      case 1:
        write("CarMaker app starting on RT Rack.");
        cancelTimer(cm_tmr);
        check_timeout_cm_tmr = 0;
        @hil_ctrl::cm_app_started = 1;
        status_cm = 0; // reseting the variable to avoid false runs
        break;
      case 2:
        writeLineEx(1,3,"CM on RT Rack was unable to start");
        cancelTimer(cm_tmr);
        check_timeout_cm_tmr = 0;
        sysSetVariableString(sysvar::hil_ctrl::abort_message, "Carmakerstarterror");
        break;
    }
  }
  else if (@hil_ctrl::simulated_bus_mode==1) // Verify this condition for Single PC and Hybrid
  {
    // No RT rack available, start carmaker in GUI PC
    // TBD read app started from GUI PC automatically and not use a fixed timer
    check_timeout_cm_tmr += wait_time;
    if (check_timeout_cm_tmr >= 30000)
    {
      @hil_ctrl::cm_app_started = 1;
      cancelTimer(cm_tmr);
      check_timeout_cm_tmr = 0;
    }
  }
}

/**
* @brief Timer to check the value written in D:\\CarMaker_Shared\\movienx_fvideo_status.txt
*/
on timer mvnx_fvideo_tmr
{
//  if (@hil_ctrl::simulated_bus_mode==0)
//  {
    fh_mvnx_fv = openFileRead("D:\\CarMaker_Shared\\movienx_fvideo_status.txt", 0);
    fileGetString(buf_mvnx_fv,bufferLength,fh_mvnx_fv);
    fileClose(fh_mvnx_fv);
    check_timeout_mvnx_fvideo_tmr += wait_time;
//    write("check timeout_mvnx_fvideo_tmr is: %d",check_timeout_mvnx_fvideo_tmr);
    if (check_timeout_mvnx_fvideo_tmr >= timeout_apps)
    {
      writeLineEx(1,3,"MovieNX Fvideo failed!!!Timeout exceeded.");
      cancelTimer(mvnx_fvideo_tmr); 
      check_timeout_mvnx_fvideo_tmr = 0;
      sysSetVariableString(sysvar::hil_ctrl::abort_message, "MovieNXerror");
    }
    
    strtol(buf_mvnx_fv, 0, status_mvnx_fv);
    switch (status_mvnx_fv)
    {
      case 1:
        write("Movienx FVideo app started on Rendering PC.");
        cancelTimer(mvnx_fvideo_tmr);
        check_timeout_mvnx_fvideo_tmr = 0;
        @hil_ctrl::movienx_fvideo_done = 1;
        break;
      case 2:
        cancelTimer(mvnx_fvideo_tmr);
        writeLineEx(1,3,"MovieNX Fvideo was unable to start");
        check_timeout_mvnx_fvideo_tmr = 0;
        sysSetVariableString(sysvar::hil_ctrl::abort_message, "MovieNXerror");
        break;
      case 3:
        writeLineEx(1,2,"MovieNX app cannot be closed on Rendering PC");
        cancelTimer(mvnx_fvideo_tmr);
        check_timeout_mvnx_fvideo_tmr = 0;
        sysSetVariableString(sysvar::hil_ctrl::abort_message, "Wrn_MovieNX_cannot_be_closed");
        break;
    }
//  }
}

/**
* @brief Timer to check the value written in D:\\CarMaker_Shared\\movienx_svs_status.txt
*/
on timer mvnx_svs_tmr
{
//  if (@hil_ctrl::simulated_bus_mode==0)
//  {
    fh_mvnx_svs = openFileRead("D:\\CarMaker_Shared\\movienx_svs_status.txt", 0);
    fileGetString(buf_mvnx_svs,bufferLength,fh_mvnx_svs);
    fileClose(fh_mvnx_svs);
    check_timeout_mvnx_svs_tmr += wait_time;
//    write("check timeout_mvnx_svs_tmr is: %d",check_timeout_mvnx_svs_tmr);
    if (check_timeout_mvnx_svs_tmr >= timeout_apps)
    {
      writeLineEx(1,3,"MovieNX SVS failed!!!Timeout exceeded.");
      check_timeout_mvnx_svs_tmr = 0;
      sysSetVariableString(sysvar::hil_ctrl::abort_message, "MovieNXRSIerror");
      cancelTimer(mvnx_svs_tmr); 
    }
    
    strtol(buf_mvnx_svs, 0, status_mvnx_svs);
    switch (status_mvnx_svs)
    {
      case 1:
        write("Movienx SVS app started on Rendering PC.");
        check_timeout_mvnx_svs_tmr = 0;
        @hil_ctrl::movienx_svs_done = 1;
        cancelTimer(mvnx_svs_tmr);
        break;
      case 2:
        writeLineEx(1,3,"MovieNX SVS was unable to start");
        check_timeout_mvnx_svs_tmr = 0;
        sysSetVariableString(sysvar::hil_ctrl::abort_message, "MovieNXRSIerror");
        cancelTimer(mvnx_svs_tmr);
        break;
      case 3:
        writeLineEx(1,2,"MovieNX app cannot be closed on Rendering PC");
        check_timeout_mvnx_svs_tmr = 0;
        sysSetVariableString(sysvar::hil_ctrl::abort_message, "Wrn_MovieNX_cannot_be_closed");
        cancelTimer(mvnx_fvideo_tmr);
        break;         
    }
//  }
}

/**
* @brief Timer to check the value written in D:\\CarMaker_Shared\\rendering_pc_status.txt
*/
on timer rendering_pc_status_timer
{
  // Check if there is a rendering PC in the system and RPYC server is on
  if (@hil_ctrl::simulated_bus_mode==0)
  {
   
    fh_mvnx_status = openFileRead("D:\\CarMaker_Shared\\rendering_pc_status.txt", 0);
    fileGetString(buf_mvnx_status,bufferLength,fh_mvnx_status);
    fileClose(fh_mvnx_status);
    check_timeout_rendering_pc_status_timer += wait_time;
//    write("check timeout_rendering_pc_status_timer is: %d",check_timeout_rendering_pc_status_timer);
    if (check_timeout_rendering_pc_status_timer >= timeout_max)
    {
       writeLineEx(1,3,"Rendering PC and RPYC server timer elapsed");
       cancelTimer(rendering_pc_status_timer); 
       sysSetVariableString(sysvar::hil_ctrl::abort_message, "mvnxstatustmrelapsed");
       check_timeout_rendering_pc_status_timer = 0;
    }
    
    
    strtol(buf_mvnx_status, 0, status_mvnx);
    switch (status_mvnx)
    {
      case 1:
        write("Rendering PC up and RPYC server running.");
        check_timeout_rendering_pc_status_timer = 0;
        cancelTimer(rendering_pc_status_timer);
        @hil_ctrl::abort_msg_movienx = 1;
        @hil_ctrl::rendering_pc_status_buf = 1;
        getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts\\start_client.bat terminate_movienx all_instances", absfilePath, 256);
			  getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts", absdirPath, 256);
			  sysExec(absfilePath, absdirPath); 
        break;
      case 2:
        writeLineEx(1,2,"No communication with Rendering PC or RPYC is down.");
        check_timeout_rendering_pc_status_timer = 0;
		    cancelTimer(rendering_pc_status_timer);
        @hil_ctrl::abort_msg_movienx = 2;
        @hil_ctrl::rendering_pc_status_buf = 2;
        break;
	    case 3:
        writeLineEx(1,3,"Wrong RPYC server version detected.");
        check_timeout_rendering_pc_status_timer = 0;
		    cancelTimer(rendering_pc_status_timer);
        @hil_ctrl::abort_msg_movienx = 3;
        @hil_ctrl::rendering_pc_status_buf = 3;
        sysSetVariableString(sysvar::hil_ctrl::abort_message, "RenderingPCnotavailable");
        break;
    }
  }
  else if (@hil_ctrl::simulated_bus_mode==1)
  {
   // Check if there is a rendering PC in the system and RPYC server is on
    fh_mvnx_status = openFileRead("D:\\CarMaker_Shared\\rendering_pc_status.txt", 0);
    fileGetString(buf_mvnx_status,bufferLength,fh_mvnx_status);
    fileClose(fh_mvnx_status);
    check_timeout_rendering_pc_status_timer += wait_time;
//    write("check timeout_rendering_pc_status_timer is: %d",check_timeout_rendering_pc_status_timer);
    if (check_timeout_rendering_pc_status_timer >= timeout_max)
    {
       writeLineEx(1,3,"Rendering PC and RPYC server timer elapsed");
       cancelTimer(rendering_pc_status_timer); 
       sysSetVariableString(sysvar::hil_ctrl::abort_message, "mvnxstatustmrelapsed");
       check_timeout_rendering_pc_status_timer = 0;
    }
    
    
    strtol(buf_mvnx_status, 0, status_mvnx);
    switch (status_mvnx)
    {
      case 1:
        write("Rendering PC up and RPYC server running.");
        check_timeout_rendering_pc_status_timer = 0;
        cancelTimer(rendering_pc_status_timer);
        @hil_ctrl::abort_msg_movienx = 1;
        @hil_ctrl::rendering_pc_status_buf = 1;
        getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts\\start_client.bat terminate_movienx all_instances", absfilePath, 256);
			  getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts", absdirPath, 256);
			  sysExec(absfilePath, absdirPath); 
        break;
      case 2:
        writeLineEx(1,2,"No communication with Rendering PC or RPYC is down.");
        check_timeout_rendering_pc_status_timer = 0;
		    cancelTimer(rendering_pc_status_timer); 
        @hil_ctrl::abort_msg_movienx = 2; // reserved for rendering pc and rt rack in the same computer new use case
        @hil_ctrl::rendering_pc_status_buf = 2;
        break;
	    case 3:
        writeLineEx(1,3,"Wrong RPYC server version detected.");
        check_timeout_rendering_pc_status_timer = 0;
		    cancelTimer(rendering_pc_status_timer);
        @hil_ctrl::abort_msg_movienx = 3;
        @hil_ctrl::rendering_pc_status_buf = 3;
        sysSetVariableString(sysvar::hil_ctrl::abort_message, "RenderingPCnotavailable");
        break;
    }
//    @hil_ctrl::abort_msg_movienx = 4; // reserved for rendering pc and rt rack in the same computer new use case
//    cancelTimer(rendering_pc_status_timer);
    // MovieNX killed in batch file kill_cm.bat no need for extra action
  }
 
}

/**
* @brief If abort_msg_movienx = 1 then a Rendering PC is pressent and online, CM logic will avoid BYO RT Rack changes.
*/
on sysvar hil_ctrl::abort_msg_movienx
{
  if (@this == 1 && @hil_ctrl::simulated_bus_mode==0) // checked.
  {
    @hil_ctrl::rt_rack_state = 2; //Rendering PC present, CM Logic stays as it was ignoring BYO RT Rack changes.
    write("Rendering PC available");
  }
  else if (@this == 1 && @hil_ctrl::simulated_bus_mode==1) 
  {
    local_copy_hybrid(); //Rendering PC present, CM Logic stays as it was ignoring BYO RT Rack changes.
    write("Rendering PC available for Hybrid Logic");
  }
}

/**
* @brief If trigger_net_share_check = 1 then a Rendering PC is pressent, network shared will be tested.
*/
on sysvar hil_ctrl::trigger_net_share_check
{
  if (@this == 1)
  {
    setTimerCyclic(net_share_tmr_rendering, 1000);
    write("Checking shared drive");
  }
}
/**
* @brief Timer checks stauts of the mapped drive on RT Rack, if not possible to reconnect then abort message is set.
*/
on timer net_share_tmr_rendering
{
  if (@hil_ctrl::simulated_bus_mode==1)
  {
    fh_net_share_rendering= openFileRead("D:\\CarMaker_Shared\\Mapped_Drives_Status_Rendering.txt", 0);
    fileGetString(buf_net_share_rendering,bufferLength,fh_net_share_rendering);
    fileClose(fh_net_share_rendering);
    strtol(buf_net_share_rendering, 0, status_net_share_rendering);
    switch (status_net_share_rendering)
    {
      case 1:
        write("Network drive available and connected to the Rendering PC.");
        cancelTimer(net_share_tmr_rendering);
        @hil_ctrl::network_drives_status = 1;
        break;
      case 2:
        writeLineEx(1,3,"Network drive not available for the Rendering PC, reconnection not possible!\nPlease check shared drive on source PC!!");
        cancelTimer(net_share_tmr_rendering);
        sysSetVariableString(sysvar::hil_ctrl::abort_message, "Network_drive_not_available");
        @hil_ctrl::network_drives_status = 2;
        break;
    }
  }
}

/**
* @brief Starts cm_runtime_error_tmr when hil_ctrl::cm_runtime_error = 1
*/
on sysvar hil_ctrl::cm_runtime_error
{
  if (@this ==1)
  {    
   setTimer(cm_runtime_error_tmr, wait_time);
  }
}

/**
* @brief Timer to check the value written in D:\\CarMaker_Shared\\error_log.txt
*/
on timer cm_runtime_error_tmr
{
	fh_error_log = openFileRead("D:\\CarMaker_Shared\\error_log.txt", 0);
	fileGetString(buf_cm_error_message,bufferLength,fh_error_log);
	writeLineEx(1,3, "%s", buf_cm_error_message);
  @hil_ctrl::cm_runtime_error = 0;
  fileClose(fh_error_log);
  cancelTimer(cm_runtime_error_tmr);
}


on sysvar Customer_specific::cm_stopsim
{
  if (@this ==1)
  {    
//   setTimer(mvnx_fps_timer, wait_time);
  }
}

/**
* @brief Timer to check the value written in D:\\CarMaker_Shared\\movienx_fps_status.txt
*/
on timer mvnx_fps_timer
{
  if (@hil_ctrl::simulated_bus_mode==0)
  {
    fh_fps_status = openFileRead("D:\\CarMaker_Shared\\movienx_fps_status.txt", 0);
    fileGetString(buf_mvnx_fps,bufferLength,fh_fps_status);
    fileClose(fh_fps_status);
    
    check_timeout_mvnx_fps_timer += wait_time;
//    write("check timeout_mvnx_fps_timer is: %d",check_timeout_mvnx_fps_timer);
    if (check_timeout_mvnx_fps_timer >= timeout_max)
    {
       writeLineEx(1,3,"MovieNX fps timer elapsed");
       cancelTimer(mvnx_fps_timer); 
       sysSetVariableString(sysvar::hil_ctrl::abort_message, "mvnxfpstmrelapsed");
       check_timeout_mvnx_fps_timer = 0;
    }
    
    strtol(buf_mvnx_fps, 0, status_fps_mvnx);
	if (status_fps_mvnx == 1)
	{	
		cancelTimer(rendering_pc_status_timer);
    sysSetVariableString(sysvar::hil_ctrl::abort_message, "MovieNXperformanceerror");
		writeLineEx(1,3, "MovieNX fps dropped below 30 frames for more that three frames.");		
	}
  }
}

on timer mvnx_scenario_tmr
{
  if (@hil_ctrl::simulated_bus_mode==0)
  {
    fh_mvnx_scene = openFileRead("D:\\CarMaker_Shared\\movienx_scene_status.txt", 0);
    fileGetString(buf_mvnx_scene,bufferLength,fh_mvnx_scene);
    fileClose(fh_mvnx_scene);
    check_timeout_mvnx_scenario_tmr += wait_time;
//    write("check timeout_mvnx_scenario_tmr is: %d",check_timeout_mvnx_scenario_tmr);
    if (check_timeout_mvnx_scenario_tmr >= timeout_max)
    {
       writeLineEx(1,3,"MovieNX scenario load timer elapsed");
       cancelTimer(mvnx_scenario_tmr); 
       sysSetVariableString(sysvar::hil_ctrl::abort_message, "mvnxscenarioloadtmrelapsed");
       check_timeout_mvnx_scenario_tmr = 0;
    }

    strtol(buf_mvnx_scene, 0, status_mvnx_scene);
	switch (status_mvnx_scene)
    {
      case 1:
        write("Scene loaded and started on MovieNX.");
        check_timeout_mvnx_scenario_tmr = 0;
        status_mvnx_scene = 0;
        cancelTimer(mvnx_scenario_tmr);  
        break;
      case 2:
        check_timeout_mvnx_scenario_tmr = 0;
        cancelTimer(rendering_pc_status_timer);
        sysSetVariableString(sysvar::hil_ctrl::abort_message, "MovieNXscenarioError");
		    writeLineEx(1,3, "MovieNX scene was not loaded successfully.");
        status_mvnx_scene = 0;
        break;
    }
  }
}


/**
* @brief Starts copy_from_shared when hil_ctrl::copy_project_from_shared = 1
*/
on sysvar hil_ctrl::copy_project_from_shared
{
	if (@this ==1)
  {    
   setTimerCyclic(copy_from_shared, wait_time, wait_time); //timer checks first and second copy
  }	
}

/**
* @brief Timer to check the value written in D:\\CarMaker_Shared\\copy_back_to_repo_status.txt
*/
on timer copy_from_shared
{	
    check_timeout_copy_from_shared += wait_time;
//    write("check timeout_copy_from_shared is: %d",check_timeout_copy_from_shared);
    if (check_timeout_copy_from_shared >= timeout_max)
    {
       writeLineEx(1,3,"Copy from shared timer elapsed");
       cancelTimer(copy_from_shared); 
       check_timeout_copy_from_shared = 0;
    }
  
  if (@hil_ctrl::simulated_bus_mode==0)
  {
    fh_copy_repo = openFileRead("D:\\CarMaker_Shared\\copy_back_to_repo_status.txt", 0);
    fileGetString(buf_copy_back,bufferLength,fh_copy_repo);
    fileClose(fh_copy_repo);
    
    strtol(buf_copy_back, 0, status_copy_from_rt);
    switch (status_copy_from_rt)
    {
      case 1:
//        cancelTimer(copy_from_shared); // Start copy on GUI PC - Timer keep running
		    getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts\\copy_project_back.bat local", absfilePath, 256);
		    getAbsFilePath("Platform\\Classe\\Scripts\\CarMaker_scripts", absdirPath, 256);
		    sysExec(absfilePath, absdirPath);
        break;
      case 2:
        write("Copy project from RT Rack back to repo was successful.");
        cancelTimer(copy_from_shared);
        @hil_ctrl::copy_project_from_shared = 0;
        break;  
      case 3:
        writeLineEx(1,3,"Copy project from RT Rack back to repo was unsuccessful!!!");
        cancelTimer(copy_from_shared);
        sysSetVariableString(sysvar::hil_ctrl::abort_message, "Carmakercopyfoldererror");
        break;
    }
  }
	
}
//The following is code used for python downloading and deployment on the Rt Rack which is not going to be used for now
//See https://rb-tracker.bosch.com/tracker08/browse/ADASXIL-465
/*
on sysvar hil_ctrl::deploy_py_libs
{
  if (@this == 1)
  {
    getAbsFilePath("Platform\\ToolInstaller\\Download_RT_Rack_py_libraries.bat", absfilePath, 256);
		getAbsFilePath("Platform\\ToolInstaller", absdirPath, 256);
		sysExec(absfilePath, absdirPath);
  }
}
*/