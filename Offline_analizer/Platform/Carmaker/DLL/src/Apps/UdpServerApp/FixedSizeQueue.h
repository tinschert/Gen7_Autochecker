#pragma once

#include <array>
#include <stdexcept>
#include <mutex>

/// @brief An implementation of a fixed size queue
/// @note Generated by ChatGPT 4.0 mini w/ minor modifications by LUR1PLY
template <typename T, std::size_t Size>
class FixedSizeQueue
{
public:
    /// @brief Constructs a FixedSizeQueue with the specified maximum size.
    FixedSizeQueue() : m_front(0), m_rear(0), m_count(0) {}

    /// @brief Adds an element to the end of the queue.
    /// @param value The value to be added to the queue.
    /// @throws std::overflow_error if the queue is full.
    void enqueue(const T &value)
    {
        std::lock_guard<std::mutex> lock(m_mutex); // Lock the mutex for thread safety
        if (m_count == Size)
        {
            throw std::overflow_error("Queue is full");
        }
        m_data[m_rear] = value;
        m_rear = (m_rear + 1) % Size;
        m_count++;
    }

    /// @brief Removes and returns the front element of the queue.
    /// @return The front element of the queue.
    /// @throws std::underflow_error if the queue is empty.
    T dequeue()
    {
        std::lock_guard<std::mutex> lock(m_mutex); // Lock the mutex for thread safety
        if (m_count == 0)
        {
            throw std::underflow_error("Queue is empty");
        }
        T value = m_data[m_front];
        m_front = (m_front + 1) % Size;
        m_count--;
        return value;
    }

    /// @brief Checks if the queue is full.
    /// @return true if the queue is full, false otherwise.
    bool isFull() const
    {
        std::lock_guard<std::mutex> lock(m_mutex); // Lock the mutex for thread safety
        return m_count == Size;
    }

    /// @brief Checks if the queue is empty.
    /// @return true if the queue is empty, false otherwise.
    bool isEmpty() const
    {
        std::lock_guard<std::mutex> lock(m_mutex); // Lock the mutex for thread safety
        return m_count == 0;
    }

    /// @brief Returns the current number of elements in the queue.
    /// @return The number of elements in the queue.
    std::size_t size() const
    {
        std::lock_guard<std::mutex> lock(m_mutex); // Lock the mutex for thread safety
        return m_count;
    }

    /// @brief Looks at the first element of the queue without removing it.
    /// @return The front element of the queue.
    /// @throws std::underflow_error if the queue is empty.
    T peek() const
    {
        std::lock_guard<std::mutex> lock(m_mutex); // Lock the mutex for thread safety
        if (m_count == 0)
        {
            throw std::underflow_error("Queue is empty");
        }
        return m_data[m_front];
    }

private:
    /// @brief Container to hold the queue elements
    std::array<T, Size> m_data;

    /// @brief Index of the front element
    std::size_t m_front;

    /// @brief Index of the next insertion point
    std::size_t m_rear;

    /// @brief Current number of elements in the queue
    std::size_t m_count;

    /// @brief Mutex for synchronizing access to the queue
    mutable std::mutex m_mutex;
};
