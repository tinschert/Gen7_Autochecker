# -*- coding: utf-8 -*-
# @file create_OsekTp.py
# @author ADAS_HIL_TEAM
# @date 10-03-2023
##################################################################
# C O P Y R I G H T S
# ----------------------------------------------------------------
# Copyright (c) 2023 by Robert Bosch GmbH. All rights reserved.

# The reproduction, distribution and utilization of this file as
# well as the communication of its contents to others without express
# authorization is prohibited. Offenders will be held liable for the
# payment of damages. All rights reserved in the event of the grant
# of a patent, utility model or design.

##################################################################


import re, os
import os, sys
try:
    from Control.logging_config import logger
except ImportError:
    sys.path.append(os.path.dirname(os.path.abspath(__file__)) + r"\..\Control")
    from logging_config import logger
try:
    sys.path.append(os.getcwd() + r"\..\..\CustomerPrj\Restbus\Scripts")
    from pattern_matching import *
except ImportError:
    sys.path.append(os.getcwd() + r"\..\..\..\..\CustomerPrj\Restbus\Scripts")
    from pattern_matching import *


def generate_osektp_includes_can(network_name, node_name, pdu_name):
    """
    It includes cin file of canTp PDU

    Args:
      node_name: node name
      pdu_name: name of the canTp PDU

    Returns: node_list, which includes canTp PDU cin files

    """
    node_list=[]
    node_list.append(f'  #include "OSEKTP\\OSEKTP_{network_name}_{node_name}_{pdu_name}.cin"  ///For handling  pdu {pdu_name} with OSEKtp')
    return node_list

def generate_TimerForNpdu(network_name, pdu_name):
    """
    It creates variable for the timer to set cyclic canTp PDU

    Args:
      network_name: network name
      pdu_name: name of the canTp PDU

    Returns: node_cin, it returns variable for the timer to set cyclic canTp PDU

    """
    node_cin=[]
    node_cin.append('  msTimer npduTimer_{0}_{1};'.format(network_name,pdu_name))
    return node_cin

def generate_includes_osektp(para_dict):
    """
    It includes common osekTp files

    Args:
      para_list: 

    Returns: node_cin, with includes common osekTp cin files

    """
    network_name, node_name, message_name, pdu_name, payload_pdu, file_path = para_dict['network_name'], para_dict['node_name'], para_dict['message_name'], para_dict['pdu_name'], para_dict['payload_pdu'], para_dict['file_path']

    script_path = "\\".join(os.path.dirname(os.path.abspath(__file__)).split("\\")[-4:])
    node_cin.append("// Autogenerated by -> " + script_path + r"\create_OsekTp.py")

    node_cin.append('')
    node_cin.append('includes')
    node_cin.append('{')
    #node_cin.append('  #include "OSEKTP.cin"')
    node_cin.append('}')


def generate_variables_osektp(para_dict,DataLength,npdu_dict):
    """
    It adds variables to create canTp handle

    Args:
      para_list: list of network_name,node_name ,message_name, pdu_name, payload_pdu, file_path
      DataLength: Length of NPdu data

    Returns: node_cin, returns all the variables created for canTp handle

    """
    network_name = para_dict['network_name']
    node_name = para_dict['node_name']
    message_name = para_dict['message_name']
    pdu_name = para_dict['pdu_name']
    payload_pdu = para_dict['payload_pdu']
    file_path = para_dict['file_path']

    node_cin.append('')
    node_cin.append('variables')
    node_cin.append('{')
    node_cin.append('  const     kBufferSizeJumbo_{0}_{1} = {2};  // Jumbo frames'.format(node_name, pdu_name, DataLength))
    for msg, values in npdu_dict.items():
        if values[0] == pdu_name and values[1] in pdu_skip:
            node_cin.append('  const     kBufferSizeJumbo_{0}_{1}_short = 108;  // Jumbo frames Small packet'.format(node_name, pdu_name))
            node_cin.append('  const     kBufferSizeJumbo_{0}_{1}_large= 2048;  // Jumbo frames Big packet'.format(node_name, pdu_name))
    node_cin.append('  const int kDuration_RxLEDOn_ms_{0}_{1} = 2000;'.format(node_name, pdu_name))
    node_cin.append('  const int kDuration_TxLEDOn_ms_{0}_{1} = 2000;'.format(node_name, pdu_name))
    node_cin.append('  const int kDuration_ErrLEDOn_ms_{0}_{1} = 4000;'.format(node_name, pdu_name))
    node_cin.append('  const int kDuration_RxLEDFlashOff_ms_{0}_{1} = 30000;'.format(node_name, pdu_name))
    node_cin.append('  const int kDuration_TxLEDFlashOff_ms_{0}_{1} = 30000;'.format(node_name, pdu_name))
    node_cin.append('  const int kDuration_LEDFlash_ms_{0}_{1} = 400;'.format(node_name, pdu_name))
    node_cin.append('  const int kId_{0}_{1} = 1;'.format(node_name, pdu_name))
    node_cin.append('  BYTE gbCANFDactive_{0}_{1} = 0;'.format(node_name, pdu_name))
    node_cin.append('  long gHandle_{0}_{1};'.format(node_name, pdu_name))
    node_cin.append('  long gECUAddress_{0}_{1};'.format(node_name, pdu_name))
    node_cin.append('  long gTargetAddress_{0}_{1};'.format(node_name, pdu_name))
    node_cin.append('  long gTxIdentifier_{0}_{1};'.format(node_name, pdu_name))
    node_cin.append('  long gRxIdentifier_{0}_{1};'.format(node_name, pdu_name))
    node_cin.append('}')


def generate_ontmr_osektp(para_dict):
    """
    It generates the timer to glow sending and receiving indication LED

    Args:
      para_list: list of network_name,node_name ,message_name, pdu_name, payload_pdu, file_path

    Returns: calls ontimer_osektp, ontimer_toggleLEDosektp

    """
    network_name = para_dict['network_name']
    node_name = para_dict['node_name']
    message_name = para_dict['message_name']
    pdu_name = para_dict['pdu_name']
    payload_pdu = para_dict['payload_pdu']
    file_path = para_dict['file_path']
    
    if para_dict.get('cantp_pdu_type','')!='Flowcontrol_pdu':
        ontimer_osektp(network_name, pdu_name, node_name, "tSwitchOffRxLED_{0}_{1}".format(node_name, pdu_name), "tFlashRxLED_{0}_{1}".format(node_name, pdu_name), "sysDataReceivedInd", "// Switch off led for ReceivingData")
        ontimer_osektp(network_name, pdu_name, node_name, "tSwitchOffTxLED_{0}_{1}".format(node_name, pdu_name), "tFlashTxLED_{0}_{1}".format(node_name, pdu_name), "sysDataTransmittedConf", "// Switch off led for TransmittingData")
        ontimer_osektp(network_name, pdu_name, node_name, "tSwitchOffErrLED_{0}_{1}".format(node_name, pdu_name), "tFlashErrLED_{0}_{1}".format(node_name, pdu_name), "sysErrorInd", "")
        ontimer_toggleLEDosektp(network_name, pdu_name, node_name, "tFlashRxLED_{0}_{1}".format(node_name, pdu_name), "sysDataReceivedInd", "// toggle Rx LED")
        ontimer_toggleLEDosektp(network_name, pdu_name, node_name, "tFlashTxLED_{0}_{1}".format(node_name, pdu_name), "sysDataTransmittedConf", "// toggle Tx LED")
        ontimer_toggleLEDosektp(network_name, pdu_name, node_name, "tFlashErrLED_{0}_{1}".format(node_name, pdu_name), "sysErrorInd", "// toggle Err LED")


def ontimer_osektp(network_name, pdu_name, node_name, timer1, timer2, sysvar, text):
    """
    It creates timer for LED swicth off

    Args:
      network_name: network name
      pdu_name: pdu name 
      node_name: node name  
      timer1: timer to Switch OFF LED
      timer2: timer to Flash LED
      sysvar: to update the systerm variable
      text: to add the comment

    Returns: node_cin, on timer function

    """
    node_cin.append('')
    node_cin.append('on timer {0}'.format(timer1))
    node_cin.append('{')
    if text != "":
        node_cin.append('   {0}'.format(text))
    node_cin.append('   cancelTimer({0});'.format(timer2))
    node_cin.append('   @sysvar::{0}::{1}::{2}::GeneralSettings::{3} = 0;'.format(network_name,node_name, pdu_name, sysvar))
    node_cin.append('}')


def ontimer_toggleLEDosektp(network_name, pdu_name, node_name, timer1, sysvar, text):
    """
    It create timer for toggling LED

    Args:
      network_name: network name
      pdu_name: pdu name 
      node_name: node name  
      timer1: timer to Toggle LED
      sysvar: to update the systerm variable
      text: to add the comment

    Returns: node_cin, on timer function

    """
    node_cin.append('')
    node_cin.append('on timer {0}'.format(timer1))
    node_cin.append('{')
    if text != "":
        node_cin.append('   {0}'.format(text))
    node_cin.append('   @sysvar::{0}::{1}::{2}::GeneralSettings::{3} = @sysvar::{0}::{1}::{2}::GeneralSettings::{3} ? 0: 1;'.format(network_name,node_name, pdu_name, sysvar))
    node_cin.append('}')


def OnStart_callTxRX(para_dict):
    """
    It is part of canTp handle configuration

    Args:
      para_list: list of network_name,node_name ,message_name, pdu_name, payload_pdu, file_path

    Returns: returns the canTp handle configuration

    """
    network_name = para_dict['network_name']
    node_name = para_dict['node_name']
    message_name = para_dict['message_name']
    pdu_name = para_dict['pdu_name']
    payload_pdu = para_dict['payload_pdu']
    file_path = para_dict['file_path']

    node_cin.append('{ \n   // long dbHandle; \n   // dbHandle = CanTpGetDBConnection();')
    node_cin.append('   // if (dbHandle > 0) \n   // { \n      // CanTpCloseConnection(dbHandle); \n   // }')
    node_cin.append('\n   setwriteDbgLevel(@sysvar::sysDbgLevel); \n   CanTpSetVerbosity(@sysvar::sysTPVerboseLevel);')
    node_cin.append('   { \n      // Check if CAN FD is active for this bus \n      CANSettings arbitration; \n      CANSettings data;      ')
    node_cin.append('      canFdGetConfiguration( 1, arbitration, data); \n      gbCANFDactive_{0}_{1} = ((arbitration.flags & 0x100) != 0 ? 1 : 0);'.format(node_name, pdu_name))
    node_cin.append('   }')
    node_cin.append('   if( 0 == gbCANFDactive_{0}_{1}) \n      // Disable CAN FD controls when CAN FD is not active'.format(node_name, pdu_name))
    node_cin.append('   {')
    node_cin.append('      enableControl( "GeneralConnectionSettings", "cboGeneral_CANFDFrameLen", 0); \n      enableControl( "GeneralConnectionSettings", "chkGeneral_CANFDBRS", 0);')
    node_cin.append('      enableControl( "Settings_{0}_{1}", "cboCANFD_{0}_{1}", 0); \n      enableControl( "Settings_{0}_{1}", "chkCANFDBRS_{0}_{1}", 0);'.format(node_name, pdu_name))

def generate_onsysvar_osektp(para_dict):
    """
    It will generate function to create canTp handle and configure canTp handle parameters 

    Args:
      para_list: list of network_name,node_name ,message_name, pdu_name, payload_pdu, file_path

    Returns:node_cin, returns function to create canTp handle and configure canTp handle parameters 

    """
    network_name = para_dict['network_name']
    node_name = para_dict['node_name']
    message_name = para_dict['message_name']
    pdu_name = para_dict['pdu_name']
    payload_pdu = para_dict['payload_pdu']
    file_path = para_dict['file_path']

    error_mess = ["Timeout while waiting for CF", "Timeout while waiting for FC", "Undefined error",
                  "TP DLL busy, only one transmission at a time", "Unexpected PDU received",
                  "Timeout while trying to send a CAN frame", "Too many wait frames sent", "Receiver buffer overflow",
                  "Wrong parameter", "Invalid status in FC frame"]
    #if "FC" not in pdu_name.upper().split('_'):
    #if pdu_fc_pattern not in pdu_name.split('_'):
   # pdu_fc_pattern_check = [True if re.search(NPDU_FC_Pattern, pdu_name) else False]
##    if re.search(NPDU_FC_Pattern, pdu_name):
    node_cin.append('')
    node_cin.append('OnStart_callTx_{0}_{1}()'.format(node_name, pdu_name))
    OnStart_callTxRX(para_dict)
    node_cin.append(' \n   }')
    node_cin.append('\n   Init_{0}_{1}();'.format(node_name, pdu_name))
    node_cin.append('}')
##    else:
##        node_cin.append('')
##        node_cin.append('OnStart_callRx_{0}_{1}()'.format(node_name, pdu_name))
##        OnStart_callTxRX(para_list)
##        node_cin.append('}')
##        node_cin.append('\n   Init_{0}_{1}();'.format(node_name, pdu_name))
##        node_cin.append('}')

    node_cin.append('')
    node_cin.append('Init_{0}_{1}()'.format(node_name, pdu_name))
    node_cin.append('{')
    node_cin.append('   long connHandle; \n   long addressingMode; \n   long extIdFlag; \n   extIdFlag = 0; \n   if (gHandle_{0}_{1} > 0)'.format(node_name, pdu_name))
    node_cin.append('   {')
    node_cin.append('      CanTpCloseConnection(gHandle_{0}_{1});'.format(node_name, pdu_name))
    node_cin.append('   }')
    node_cin.append('   gHandle_{1}_{2} = CanTpCreateConnection(@sysvar::{0}::{1}::{2}::GeneralSettings::sysAddrMode);'.format(network_name,node_name, pdu_name))
    node_cin.append('   connHandle = gHandle_{0}_{1};'.format(node_name, pdu_name))
    node_cin.append(' \n   /* Addressing */ \n   addressingMode = CanTpGetAddressingMode(connHandle);')
    node_cin.append('   switch (addressingMode) {')
    node_cin.append('      case kNormal:        write("%s, connection %d: Addressing mode = Normal", "{2}", kId_{0}_{1}); break;'.format(node_name, pdu_name, network_name))
    node_cin.append('      case kExtendedBased: write("%s, connection %d: Addressing mode = Extended (based)", "{2}", kId_{0}_{1}); break;'.format(node_name, pdu_name, network_name))
    node_cin.append('      case kNormalFixed:   write("%s, connection %d: Addressing mode = NormalFixed", "{2}", kId_{0}_{1}); break;'.format(node_name, pdu_name, network_name))
    node_cin.append('      case kMixed:         write("%s, connection %d: Addressing mode = Mixed", "{2}", kId_{0}_{1}); break;'.format(node_name, pdu_name, network_name))
    node_cin.append('      case kMixed11Bit:    write("%s, connection %d: Addressing mode = Mixed (11 bit)", "{2}", kId_{0}_{1}); break;'.format(node_name, pdu_name, network_name))
    node_cin.append('      case kExtendedFree:  write("%s, connection %d: Addressing mode = Extended (free)", "{2}", kId_{0}_{1}); break;'.format(node_name, pdu_name, network_name))
    node_cin.append('   } \n   if (addressingMode == kMixed || addressingMode == kMixed11Bit) \n   {')
    node_cin.append('      CanTpSetAddressExtension(connHandle, @sysvar::{0}::{1}::{2}::GeneralSettings::sysAddrExtension);'.format(network_name,node_name, pdu_name))
    node_cin.append('   }')
    node_cin.append('   if (addressingMode == kExtendedBased) \n   {')
    node_cin.append('      CanTpSetBaseIdentifier(connHandle, @sysvar::{0}::{1}::{2}::GeneralSettings::sysBaseAddress);'.format(network_name,node_name, pdu_name))
    node_cin.append('   }')
    node_cin.append('   if (addressingMode == kExtendedBased || \n      addressingMode == kExtendedFree || \n      addressingMode == kNormalFixed || \n      addressingMode == kMixed) \n   {')
    node_cin.append('      CanTpSetEcuAddress(connHandle, @sysvar::{0}::{1}::{2}::GeneralSettings::sysECUAddress);'.format(network_name,node_name, pdu_name))
    node_cin.append('      CanTpSetTargetAddress(connHandle, @sysvar::{0}::{1}::{2}::GeneralSettings::sysTargetAddress);'.format(network_name,node_name, pdu_name))
    node_cin.append('      write("%s, connection %d: ECU address = 0x%02x", "{2}", kId_{0}_{1}, CanTpGetEcuAddress(connHandle));'.format(node_name, pdu_name, network_name))
    node_cin.append('      write("%s, connection %d: Target address = 0x%x", "{2}", kId_{0}_{1}, CanTpGetTargetAddress(connHandle));'.format(node_name, pdu_name, network_name))
    node_cin.append(' \n   } \n   if (addressingMode == kNormal || \n      addressingMode == kExtendedFree || \n      addressingMode == kMixed11Bit) \n   {')
    node_cin.append('      if (@sysvar::{0}::{1}::{2}::GeneralSettings::sysUseExtId)'.format(network_name,node_name, pdu_name))
    node_cin.append('      { \n         extIdFlag = 0x80000000; \n      }')
    node_cin.append('      CanTpSetRxIdentifier(connHandle, extIdFlag | @sysvar::{0}::{1}::{2}::GeneralSettings::sysRxIdentifier);'.format(network_name,node_name, pdu_name))
    node_cin.append('      CanTpSetTxIdentifier(connHandle, extIdFlag | @sysvar::{0}::{1}::{2}::GeneralSettings::sysTxIdentifier);'.format(network_name,node_name, pdu_name))
    node_cin.append('      write( "%s, connection %d: Rx Id = 0x%x", "{2}", kId_{0}_{1}, CanTpGetRxIdentifier(connHandle));'.format(node_name, pdu_name, network_name))
    node_cin.append('      write( "%s, connection %d: Tx Id = 0x%x", "{2}", kId_{0}_{1}, CanTpGetTxIdentifier(connHandle));'.format(node_name, pdu_name, network_name))
    node_cin.append('   }')
    node_cin.append('   gECUAddress_{1}_{2} = @sysvar::{0}::{1}::{2}::GeneralSettings::sysECUAddress;'.format(network_name,node_name, pdu_name))
    node_cin.append('   gTargetAddress_{1}_{2} = @sysvar::{0}::{1}::{2}::GeneralSettings::sysTargetAddress;'.format(network_name,node_name, pdu_name))
    node_cin.append('   gTxIdentifier_{1}_{2} = @sysvar::{0}::{1}::{2}::GeneralSettings::sysTxIdentifier;'.format(network_name,node_name, pdu_name))
    node_cin.append('   gRxIdentifier_{1}_{2} = @sysvar::{0}::{1}::{2}::GeneralSettings::sysRxIdentifier;'.format(network_name,node_name, pdu_name))
    node_cin.append('   write("%s, connection %d: Base address = 0x%x", "{2}", kId_{0}_{1}, CanTpGetBaseIdentifier(connHandle));'.format(node_name, pdu_name, network_name))
    node_cin.append('   write("%s, connection %d: Address extension = %d", "{2}", kId_{0}_{1}, CanTpGetAddressExtension(connHandle));'.format(node_name, pdu_name, network_name))
    node_cin.append('   write("%s, connection %d: Use extended IDs = %d","{2}", kId_{1}_{2}, @sysvar::{0}::{1}::{2}::GeneralSettings::sysUseExtId);'.format(network_name,node_name, pdu_name))
    #if "FC" in pdu_name.upper().split('_'):
    #if pdu_fc_pattern in pdu_name.split('_'):
   # pdu_fc_pattern_check = [True if re.search(NPDU_FC_Pattern, i) else False for i in pdu_name]
    if para_dict.get('cantp_pdu_type','')=='Flowcontrol_pdu':
        node_cin.append('\n   /* Flow Control */')
        node_cin.append('   CanTpUseFlowControlFrames(connHandle, @sysvar::{0}::{1}::{2}::GeneralSettings::sysUseFC);'.format(network_name,node_name, pdu_name))
        node_cin.append('   write("%s, connection %d: Use flow control = %d", "{2}", kId_{0}_{1}, CanTpIsUseFlowControlFrames(connHandle));'.format(node_name, pdu_name, network_name))
        node_cin.append('   CanTpSetBlockSize(connHandle, @sysvar::{0}::{1}::{2}::GeneralSettings::sysBlockSize);'.format(network_name,node_name, pdu_name))
        node_cin.append('   write("%s, connection %d: Block size = %d", "{2}", kId_{0}_{1}, CanTpGetBlockSize(connHandle));'.format(node_name, pdu_name, network_name))
        node_cin.append('   CanTpSetSTmin(connHandle, @sysvar::{0}::{1}::{2}::GeneralSettings::sysSTmin);'.format(network_name,node_name, pdu_name))
        node_cin.append('   write("%s, connection %d: ST min = %d", "{2}", kId_{0}_{1}, CanTpGetSTmin(connHandle));'.format(node_name, pdu_name, network_name))
        node_cin.append('   CanTpSetFlowControlDelay(connHandle, @sysvar::{0}::{1}::{2}::GeneralSettings::sysFlowControlDelay);'.format(network_name,node_name, pdu_name))
        node_cin.append('   write("%s, connection %d: Flow control delay = %d ms", "{0}", kId_{1}_{2}, @sysvar::{0}::{1}::{2}::GeneralSettings::sysFlowControlDelay);'.format(network_name,node_name, pdu_name))
        node_cin.append('   CanTpUseFlowControlBlockSize(connHandle, @sysvar::{0}::{1}::{2}::GeneralSettings::sysUseFCBlockSize);'.format(network_name,node_name, pdu_name))
        node_cin.append('   write("%s, connection %d: Use FC block size = %d", "{2}", kId_{0}_{1}, CanTpIsUseFlowControlBlockSize(connHandle));'.format(node_name, pdu_name, network_name))
    else:
        node_cin.append('   CanTpUseFlowControlFrames(connHandle, @sysvar::{0}::{1}::{2}::GeneralSettings::sysUseFC);'.format(network_name,node_name, pdu_name))
    node_cin.append(' \n   /*  Other settings */')
##    node_cin.append('   CanTpSetFirstSequenceNumber(connHandle, @sysvar::{0}::{1}::{2}::GeneralSettings::sysStartSN);'.format(network_name,node_name, pdu_name))
##    node_cin.append('   write("%s, connection %d: Start SN = %d", "{2}", kId_{0}_{1}, CanTpGetFirstSequenceNumber(connHandle));'.format(node_name, pdu_name, network_name))
    node_cin.append('   CanTpSetPadding(connHandle, @sysvar::{0}::{1}::{2}::GeneralSettings::sysPaddingValue);'.format(network_name,node_name, pdu_name))
    node_cin.append('   write("%s, connection %d: Padding value = %d", "{2}", kId_{0}_{1}, CanTpGetPadding(connHandle));'.format(node_name, pdu_name, network_name))
    node_cin.append('   CanTpSetMaximumReceiveLength(connHandle,@sysvar::{0}::{1}::{2}::GeneralSettings::sysMaxReceiveLength);'.format(network_name,node_name, pdu_name)) 
    node_cin.append('   write("%s, connection %d: Max. receiver length = %d", "{2}", kId_{0}_{1}, CanTpGetMaximumReceiveLength(connHandle));'.format(node_name, pdu_name, network_name))
    node_cin.append(' \n   /* CAN FD */')
    node_cin.append('   if( 1 == gbCANFDactive_{0}_{1})'.format(node_name, pdu_name))
    node_cin.append('   {')
    node_cin.append('      CanTpSetMaxCANFDFrameLength( connHandle, @sysvar::{0}::{1}::{2}::GeneralSettings::sysMaxFDFrameLen);'.format(network_name,node_name, pdu_name))
    node_cin.append('      write("%s, connection %d: Max. CAN FD frame length = %d", "{0}", kId_{1}_{2}, @sysvar::{0}::{1}::{2}::GeneralSettings::sysMaxFDFrameLen);'.format(network_name,node_name, pdu_name))
    node_cin.append('      CanTpSetBitRateSwitch( connHandle, @sysvar::{0}::{1}::{2}::GeneralSettings::sysBitRateSwitch);'.format(network_name,node_name, pdu_name))
    node_cin.append('      write("%s, connection %d: Bit rate switch = %d", "{0}", kId_{1}_{2}, @sysvar::{0}::{1}::{2}::GeneralSettings::sysBitRateSwitch);'.format(network_name,node_name, pdu_name))
    node_cin.append('   }')
    node_cin.append('   CanTpWriteConnectionSettings(connHandle);')
    node_cin.append('}')


def generate_CallTx_Npdu_hil_ctrl(para_dict, hil_ctrl_node_dict):
    network_name = para_dict['network_name']
    node_name = para_dict['node_name']
    message_name = para_dict['message_name']
    pdu_name = para_dict['pdu_name']
    payload_pdu = para_dict['payload_pdu']
    file_path = para_dict['file_path']
    if para_dict.get('cantp_pdu_type','')=='Flowcontrol_pdu' and payload_pdu in pdu_skip:
        node_cin.append('')
        node_cin.append('CallTx_{0}_{1}_hil_ctrl_{2}()'.format(node_name, pdu_name, hil_ctrl_node_dict[node_name]))
        node_cin.append('{')
        node_cin.append('   if (@sysvar::hil_ctrl::{0} == 2 || @sysvar::hil_ctrl::{0} == 0)'.format(hil_ctrl_node_dict[node_name]))
        node_cin.append('   {')
        node_cin.append('      CanTpUseFlowControlFrames(gHandle_{0}_{1}, 0);'.format(node_name, pdu_name))
        node_cin.append('      write("%s, connection %d: Use flow control = %d", "{0}", kId_{1}_{2}, CanTpIsUseFlowControlFrames(gHandle_{1}_{2}));'.format(network_name, node_name, pdu_name))
        node_cin.append('      //CanTpWriteConnectionSettings(gHandle_{0}_{1});'.format(node_name, pdu_name))
        node_cin.append('   }')
        node_cin.append('   else if(@sysvar::hil_ctrl::{0} == 1)'.format(hil_ctrl_node_dict[node_name]))
        node_cin.append('   {')
        node_cin.append('      CanTpUseFlowControlFrames(gHandle_{0}_{1}, 1);'.format(node_name, pdu_name))
        node_cin.append('      write("%s, connection %d: Use flow control = %d", "{0}", kId_{1}_{2}, CanTpIsUseFlowControlFrames(gHandle_{1}_{2}));'.format(network_name, node_name, pdu_name))
        node_cin.append('      //CanTpWriteConnectionSettings(gHandle_{0}_{1});'.format(node_name, pdu_name))
        node_cin.append('   }')
        node_cin.append('}')


def save_cin_file(para_dict):
    """
    It writes the osekTp capl code and saves in cin file, as per canTp NPDU

    Args:
      para_list: list of network_name,node_name ,message_name, pdu_name, payload_pdu, file_path

    Returns: Rturns generated cin file

    """
    # Open and save OSEKTP_Nodename_pdu .cin file
    network_name = para_dict['network_name']
    node_name = para_dict['node_name']
    message_name = para_dict['message_name']
    pdu_name = para_dict['pdu_name']
    payload_pdu = para_dict['payload_pdu']
    file_path = para_dict['file_path']
    try:
        file = f'{file_path}/OSEKTP/OSEKTP_{network_name}_{node_name}_{pdu_name}.cin'
        osektp_folder_path = f'{file_path}/OSEKTP'
        if not os.path.exists(osektp_folder_path):
            os.makedirs(osektp_folder_path)
        with open(file, 'w') as outfile:
            outfile.write("\n".join(str(item) for item in node_cin))
        logger.info(f"{file} updated successfully")
    except:
        logger.warning(f"{node_name} was NOT updated successfully", exc_info=True)

def create_OsekTP_node_main(para_dict,DataLength, npdu_dict, hil_ctrl_node_dict):
    """
    It will call the function to include cin files name, create and generates the variable
    Args:
      para_dict: para_dict of network_name,node_name ,message_name, pdu_name, payload_pdu, file_path
      DataLength: Length of NPDu data

    Returns: 

    """
    global node_cin
    node_cin = ['/*@!Encoding:1252*/']
    generate_includes_osektp(para_dict)
    generate_variables_osektp(para_dict,DataLength,npdu_dict)
    ##        generate_ontmr_osektp(para_list)
    generate_onsysvar_osektp(para_dict)
    generate_CallTx_Npdu_hil_ctrl(para_dict, hil_ctrl_node_dict)
    save_cin_file(para_dict)
        
