/*@!Encoding:1252*/
/**
 * @file Initialization.can
 * @author ADAS_HIL_TEAM
 * @date 08-21-2023
 * @brief  contains code that initilizes variables to the correct init values for Classe	 includes the files necessary for initialization. Those files are mostly auto-generated based on the Excel-Tables! (RW) Question: Do I understand the stuff below correctly?
 *
 * ################################################################
 * C O P Y R I G H T S
 * ----------------------------------------------------------------
 * Copyright (c) 2023 by Robert Bosch GmbH. All rights reserved.
 
 * The reproduction, distribution and utilization of this file as
 * well as the communication of its contents to others without express
 * authorization is prohibited. Offenders will be held liable for the
 * payment of damages. All rights reserved in the event of the grant
 * of a patent, utility model or design.
 *
 * ################################################################
*/

includes
{
  #include "init_rbs.cin"
  #include "..\\..\\..\\FDX\\Nodes\\fdx_init.cin"
  #include "..\\..\\..\\..\\Platform\\Classe\\Nodes\\Initialization\\classe_init.cin"
}

variables {
  /**
  * enumeration which contains all nodes and important features which should be initialized from signal.ini file.
  * Member os this enum shall represent different section of signal.ini file
  */
  
  // Variant variables
  const byte a_variant = 0;
  const byte b_variant = 1;
  
  char SIGNAL_INIFILE[255] = "\\CustomerPrj\\Restbus\\Variants\\a_variant_veh_0.ini"; /*By default load the a_variant ini fine*/
  char SIGNAL_INIFILE_a_variant_veh_0[255] = "\\CustomerPrj\\Restbus\\Variants\\a_variant_veh_0.ini"; /*!< path of a_variant in string format*/
  char SIGNAL_INIFILE_a_variant_veh_1[255] = "\\CustomerPrj\\Restbus\\Variants\\a_variant_veh_1.ini"; /*!< path of a_variant in string format*/
  char SIGNAL_INIFILE_b_variant_veh_0[255] = "\\CustomerPrj\\Restbus\\Variants\\b_variant_veh_0.ini"; /*!< path of b_variant in string format*/
  char SIGNAL_INIFILE_b_variant_veh_1[255] = "\\CustomerPrj\\Restbus\\Variants\\b_variant_veh_1.ini"; /*!< path of b_variant in string format*/
  char SIG_NAME[255] = "SIG_NAME";          /*!< channel name section on variant.ini */
  char variantFilePath[256];
  char workingDir[256];
  char variantInt[6];  
  
  dword cINFO        = 1;  
  dword cERROR       = 3;
  dword fileHandle;
  long  Sink;
  float retVal;  
  
  // Sensor set variables
  char SENSOR_SET_FILE[255] = "\\CustomerPrj\\Restbus\\Variants\\SensorSet.ini"; /*!< path of b_variant in string format*/
  char SENSOR_SET[255] = "SIG_NAME";          /*!< channel name section on SensorSet.ini */
  char sensorsetstr[256] = "[SENSOR_SET]\nset = ";
  

  // FDX variables
  dword FDX_cnt_global_counter;
  int FDX_global_counter_cycle = 1;  
  msTimer realtime;
  mstimer FDX_Update_Timer;
  mstimer delay_timer_MF4_renaming;
  
  int timenow = 0;
  int timebefore = 0;
  int timedelta = 0;
  int timedelta_cloe = 0;

  int previous_missed_loop = -2; // used for the initialization of the FDX communication
  int previous_alive_count = -2;
  int previous_alive_count_freeze = -1;
  
  // Init variables
  int init_count = 1;
  int initFlag = 0;
  int Update_Timer_Cycle = 10;
  int initcounter;
  int prestart_mode=1;  //1 - in on prestart function, 0 - not in prestart function anymore //this variable is used as a condition if the init_counter shall be set to 0 or not (in prestart mode is not needed)
  
  msTimer Bus_Update_Timer;
  mstimer Classe_Update_Timer;
  msTimer FDX_tmr_global_counter;
  msTimer waitOfftime;
} 

/************ Platform functions ************/
/****** To be Merged by Customer Project*****/

/**
  * @brief This event procedure is called on the start of the measurement
  * Set the timers so that every 5ms 
  */
on start
{
  prestart_mode = 0;
  setTimer(FDX_tmr_global_counter, FDX_global_counter_cycle);
}


/** \brief On Start This event procedure is called before the start of measurement (before the ON START event) 
 *  It initilizes all the environmental variables before the RED option to STOP measurement on the CANoe is enabled
*/
on prestart
{ 
  prestart_mode = 1;  //variable is used in the init functions (file init_rbs.cin) //note : auto code generation for init_rbs.cin has to be updated accordingly  
  @sysvar::Vehicle_Model::init_all_signals = 0;
  variantSelector();
  initcounter = 1;
  init_sequence_without_timers();
} 

/** \brief On Pre Stop This event procedure is called before the stop of measurement 
 *  It sets the powerMode_Rv env var to value 0, so the ECUs can be shutdown correctly
*/
on preStop
{
  
}

on stopMeasurement
{
  @sysvar::Vehicle_Model::init_all_signals = 0;
  cancelTimer(FDX_tmr_global_counter);
  save_last_sensor_set();
}

/**
  * @brief Missing frame and alive counter and monitoring
  */
on sysvar_update sysvar::FDX_in_HIL_specific_input_triggers::FDX_in_rt_counter_loop_back
{
  timenow = timenow()/100;
  timedelta = timenow()/100- timebefore;
  @Vehicle_Model::FDX_counter_delta_time = timedelta;
  if ((timedelta>10) && (timedelta<30))
  {
    previous_missed_loop = 0;
  }
  else
  {
    ++previous_missed_loop;
    @Vehicle_Model::FDX_counter_missed_loops = previous_missed_loop;
    if(previous_missed_loop > 3)
    {
      cancelTimer(FDX_tmr_global_counter);
      ++@Vehicle_Model::FDX_counter_max_missed_loops;
      @Vehicle_Model::FDX_abort_message = 1; //FDX  frame Timeout
    }
  }
  timebefore = timenow;
  if (previous_alive_count == @FDX_in_HIL_specific_input_triggers::FDX_in_rt_counter_loop_back)
  {
    ++previous_alive_count_freeze;
    if(previous_alive_count_freeze > 3)
    {
      cancelTimer(FDX_tmr_global_counter);
      @Vehicle_Model::FDX_abort_message = 2; //Alive counter freeze
      ++@FDX_out_HIL_specific_output_triggers::FDX_out_rt_counter;
    }
  }
  previous_alive_count = @FDX_in_HIL_specific_input_triggers::FDX_in_rt_counter_loop_back;
  
}

/**
  * @brief Updates the real time counter FDX_out_rt_counter.
  */
//on timer realtime
//{
//  @FDX_out_HIL_specific_output_triggers::FDX_out_rt_counter = timeNow()/100;
//  setTimer(realtime, 1);
//}

on sysvar sysvar::Vehicle_Model::Vehicle_Model_ON_OFF
{
  if(@this == 0)
  {
    setTimer(waitOfftime,2000);
  }
  else  if(@this == 2)
  {
    sensorSetDefault();
  }
}

on timer waitOfftime
{
  Stop();
}

/**
  * @brief  When the trace logging stops, rename the trace.
  */
on sysvar_update sysvar::FDX_in_HIL_specific_input_triggers::FDX_in_traceStart
{
  if(@this == 0) // when the logging stops, rename the trace
  {
    settimer(delay_timer_MF4_renaming,1000);
    @Vehicle_Model::init_all_signals = 1;
  }
}

/**
  * @brief Renames the trace logging MF4-file.
  */
on timer delay_timer_MF4_renaming
{
   sysExec("mf4_rename.exe Z:\\","");
}

/**
  * @brief If the button "Init All Signals" in Classe is pressed it will call init_all_signals function to re-init the environmental variables. (RW)
  */ 
on sysvar_change sysvar::Vehicle_Model::init_all_signals
{ 
  if(@this == 1)
  {  
    @Vehicle_Model::init_done = 0;
    @Vehicle_Model::init_all_signals = 0;
    @Vehicle_Model::Vehicle_Model_ON_OFF = 1;
    variantSelector();
    setTimerCyclic(FDX_Update_Timer,Update_Timer_Cycle);
  }
}    

on sysvar Vehicle_Model::init_rbs_signals
{
  if(@this == 1)
  {
    @Vehicle_Model::init_done = 0;
    @Vehicle_Model::Vehicle_Model_ON_OFF = 1;
    @Vehicle_Model::init_rbs_signals = 0;
    variantSelector();
    initcounter = 0;
    initFlag = 0;
    init_count = 1;
    setTimerCyclic(Bus_Update_Timer,Update_Timer_Cycle);
  }
}


on timer FDX_tmr_global_counter
{  
  if (@Vehicle_Model::Pass_sim == 0)
  {
     ++FDX_cnt_global_counter;
     FDX_cnt_global_counter %=65535;
     @FDX_out_HIL_specific_output_triggers::FDX_out_global_counter = FDX_cnt_global_counter;
  }
  else
  {
    @FDX_out_HIL_specific_output_triggers::FDX_out_global_counter = FDX_cnt_global_counter;
  }
  setTimer(FDX_tmr_global_counter, FDX_global_counter_cycle);
}

On timer Bus_Update_Timer
{
  rbs_init_with_timers();
}

On timer FDX_Update_Timer
{
  fdx_init_with_timers();
}

On timer Classe_Update_Timer
{
  classe_init_with_timers();
}

/**
  * @brief Initialization of FDX using timers. This can be called on the run.
  */
void fdx_init_with_timers()
{
  if (initFlag==0)
  {
    initFlag ++;
  }
  if (initFlag==1)
  {
    init_fdx();
  }
  if (initFlag==2)
  {
    initcounter = 0;
    initFlag = 0;
    init_count = 1;	
    cancelTimer(FDX_Update_Timer);
    setTimerCyclic(Classe_Update_Timer,Update_Timer_Cycle);
  }
}

/**
  * @brief Initialization of Classe using timers. This can be called on the run.
  */
void classe_init_with_timers()
{
  if (initFlag==0)
  {
    initFlag ++;
  }
  if (initFlag==1)
  {
    init_classe();
  }
  if (initFlag==2)
  {
    init_classe_obj_sim();
  }
  if (initFlag==3)
  {
    init_classe_ts_sim();
  }
  if (initFlag==4)
  {
    initcounter = 0;
    initFlag = 0;
    init_count = 1;	
    cancelTimer(Classe_Update_Timer);
    setTimerCyclic(Bus_Update_Timer,Update_Timer_Cycle);
  }
}

/**
  * @brief gets the corresponding value from signal.ini file for the requested signal
  * @param signal_name - name of the requested signal
  * @return -1 reading value for the requested signal failed
  * @return > -1 reading value for the requested signal was successfull
  */  
qword getSignalValue(char signal_name[])
{
  float val = -1; 
  val = getProfileFloat(SIG_NAME, signal_name, -1, SIGNAL_INIFILE);
  
  if (val == -1)
  {
    write("The signal %s was not found",signal_name);
  }
  return val;
}

/**
  * \fn void hand over to user
  * \brief reset of the init all signals button and sets the flag init done to true
  */
void hand_over_to_user()
{
  @sysvar::Vehicle_Model::init_all_signals = 0;
  @Vehicle_Model::init_done = 1;
}


/************ Platform template functions ************/
/******** To be adapted by Customer projects *********/

/**
  * @brief Initializes the signals using the signal.ini. Order: 1. FDX, 2. Classe, 3. RBS.
  * In those functions the signals are split into groups of 25. So max number of signals is 25*125=3125. This is for CANoe so it does not get a big load peak. (RW)
  * CARE: Must only be done at the beginning, when CANoe is started!! Reason is that the ECUs are being turned on and off which is why this must not be done while CANoe runs.
  * Question: Why is it neccessary that the values are written once on the preStart and once on the Start of the measurement? E.g. the init_FRadar() is called here and on the timer sequence. -> Possible Answer: The init with timers can be also used on the run
  */
void init_sequence_without_timers()
{
  for (init_count=0;init_count<125;) init_fdx();
  for (init_count=0;init_count<125;) init_classe();
  init_classe_obj_sim();
  // init_classe_line_sim;
  init_classe_ts_sim();
  for (init_count=0;init_count<125;) init_FRadar();       //125 groups - should be enough for most cases :) 
  for (init_count=0;init_count<125;) init_FVideo();       //125 groups - should be enough for most cases :) 
  for (init_count=0;init_count<125;) init_Map();          //125 groups - should be enough for most cases :) 
  for (init_count=0;init_count<125;) init_CRadarFL();     //125 groups - should be enough for most cases :) 
  for (init_count=0;init_count<125;) init_CRadarFR();     //125 groups - should be enough for most cases :) 
  for (init_count=0;init_count<125;) init_CRadarRL();     //125 groups - should be enough for most cases :) 
  for (init_count=0;init_count<125;) init_CRadarRR();     //125 groups - should be enough for most cases :) 
  for (init_count=0;init_count<125;) init_Rbs();          //125 groups - should be enough for most cases :) 
  initcounter = 0;
  initFlag = 0;
  init_count = 1;
  hand_over_to_user();
}

/**
  * @brief Initialization of RBS using timers. This can be called on the run.
  */
void rbs_init_with_timers()
{
  if(initFlag==0)
  {
    initFlag=1;
    write("FDX and Classe variables initialized...");
  }
  if((@Vehicle_Model::FRadar_sim == 1) && (initFlag==1))
  {
    init_FRadar();
  }
  else if(initFlag==1)
  {
    initFlag = 2;
    init_count = 1;
  }
  
  if((@Vehicle_Model::FVideo_sim == 1) && (initFlag==2))
  {
    init_FVideo();
  }
  else if(initFlag==2)
  {
    initFlag = 3;
    init_count = 1;
  }
  
  if((@Vehicle_Model::Map_sim == 1) && (initFlag==3))
  {
    init_Map();
  }
  else if(initFlag==3)
  {
    initFlag = 4;
    init_count = 1;
  }
  
  if((@Vehicle_Model::CRadarFL_sim == 1) &&(initFlag==4))
  {
    init_CRadarFL();
  }
  else if(initFlag==4)
  {
    initFlag = 5;
    init_count = 1;
  }
  
  if((@Vehicle_Model::CRadarFR_sim == 1) &&(initFlag==5))
  {
    init_CRadarFR();
  }
  else if(initFlag==5)
  {
    initFlag = 6;
    init_count = 1;
  }
  
  if((@Vehicle_Model::CRadarRL_sim == 1) &&(initFlag==6))
  {
    init_CRadarRL();
  }
  else if(initFlag==6)
  {
    initFlag = 7;
    init_count = 1;
  }
  
  if((@Vehicle_Model::CRadarRR_sim == 1)&&(initFlag==7))
  {
    init_CRadarRR();
  }
  else if(initFlag==7)
  {
    initFlag = 8;
    init_count = 1;
  }
  if(( @Vehicle_Model::Rbs_sim == 1) && (initFlag == 8))
  {
    init_Rbs();
  }
  else if(initFlag==8)
  {
    initFlag = 9;
    init_count = 1;
  }
  if(initFlag==9)
  {
    initcounter = 0;
    initFlag = 0;
    init_count = 1;	
    hand_over_to_user();
    cancelTimer(Bus_Update_Timer);
  }
}


/**
  * \fn void sets the sensor set by default
  * \brief sets the sensor set by default for Classe
  */
//void sensorSet()
//{
//  registerUserFile(SENSOR_SET_FILE, 0);
//  if(@sysvar::Vehicle_Model::RememberConfig == 1)
//  {
//    @sysvar::Vehicle_Model::FRadar_sim = (getProfileInt("SENSOR_SET", "set", 0, SENSOR_SET_FILE)&0xC000)>>14;
//    @sysvar::Vehicle_Model::FVideo_sim = (getProfileInt("SENSOR_SET", "set", 0, SENSOR_SET_FILE)&0x3000)>>12;
//    @sysvar::Vehicle_Model::CRadarFL_sim = (getProfileInt("SENSOR_SET", "set", 0, SENSOR_SET_FILE)&0x0C00)>>10;
//    @sysvar::Vehicle_Model::CRadarFR_sim = (getProfileInt("SENSOR_SET", "set", 0, SENSOR_SET_FILE)&0x0300)>>8;
//    @sysvar::Vehicle_Model::CRadarRL_sim = (getProfileInt("SENSOR_SET", "set", 0, SENSOR_SET_FILE)&0x00C0)>>6;
//    @sysvar::Vehicle_Model::CRadarRR_sim = (getProfileInt("SENSOR_SET", "set", 0, SENSOR_SET_FILE)&0x0030)>>4;
//    @sysvar::Vehicle_Model::Rbs_sim = (getProfileInt("SENSOR_SET", "set", 0, SENSOR_SET_FILE)&0x000C)>>2;
//    @sysvar::Vehicle_Model::Map_sim = (getProfileInt("SENSOR_SET", "set", 0, SENSOR_SET_FILE)&0x0003);
//    write("Sensor Set done");
//  }
//}

void sensorSetDefault()
{
    @sysvar::Vehicle_Model::FRadar_sim = 2;
    @sysvar::Vehicle_Model::FVideo_sim = 1;
    @sysvar::Vehicle_Model::CRadarFL_sim = 1;
    @sysvar::Vehicle_Model::CRadarFR_sim = 1;
    @sysvar::Vehicle_Model::CRadarRL_sim = 1;
    @sysvar::Vehicle_Model::CRadarRR_sim = 1;
    @sysvar::Vehicle_Model::Rbs_sim = 1;
    @sysvar::Vehicle_Model::Map_sim = 1;
}

/**
  * \fn void selects the variant ini file
  * \brief selects the variant ini file. Check the variable section and adapt accordingly if new variants are needed
  */
void variantSelector()
{
  write("Now loading the ini file...");
  if (@Vehicle_Model::vehicle == a_variant_veh_0)
  {
    strncpy(SIGNAL_INIFILE, SIGNAL_INIFILE_a_variant_veh_0, 255);
    write("Init Node Loading a_variant_veh_0 ini File");
  }
  else if (@Vehicle_Model::vehicle == a_variant_veh_1)
  {
    strncpy(SIGNAL_INIFILE, SIGNAL_INIFILE_a_variant_veh_1, 255);
    write("Init Node Loading a_variant_veh_1 ini File");
  }
  else if (@Vehicle_Model::vehicle == b_variant_veh_0)
  {
    strncpy(SIGNAL_INIFILE, SIGNAL_INIFILE_b_variant_veh_0, 255);
    write("Init Node Loading b_variant_veh_0 ini File");
  }
  else if (@Vehicle_Model::vehicle == b_variant_veh_1)
  {
    strncpy(SIGNAL_INIFILE, SIGNAL_INIFILE_b_variant_veh_1, 255);
    write("Init Node Loading b_variant_veh_1 ini File");
  }
  else
  {
    //Error Handling. Load first default ini file
    strncpy(SIGNAL_INIFILE, SIGNAL_INIFILE_a_variant_veh_0, 255);
  }  
  write("Current ini file path is:%s",SIGNAL_INIFILE);
  retVal = registerUserFile(SIGNAL_INIFILE, 0);
  
	if(retVal == -1)
  {
     writeLineEx(Sink, cERROR, "registration of .ini as User File failed");
  }
  else if(retVal == 1)
  {
     writeLineEx(Sink, cINFO, "registration of .ini as User File successful");
  }
  write("Done loading the ini file...");  

}


/**
  * \fn void saves the last sensor set used
  * \brief saves the last sensor set used into a ini file so it can be read afterwards
  */
void save_last_sensor_set()
{
  // save the last sensor set config
  getUserFilePath("SensorSet.ini",variantFilePath, 256);
  getUserFilePath("\\CustomerPrj\\Restbus\\Variants",workingDir, 256);
  setWritePath(workingDir);
  fileHandle =  openFileWrite (variantFilePath,0);
  
  ltoa((@sysvar::Vehicle_Model::FRadar_sim<<14)+(@sysvar::Vehicle_Model::FVideo_sim<<12)+
  (@sysvar::Vehicle_Model::CRadarFL_sim<<10)+(@sysvar::Vehicle_Model::CRadarFR_sim<<8)+
  (@sysvar::Vehicle_Model::CRadarRL_sim<<6)+
  (@sysvar::Vehicle_Model::CRadarRR_sim<<4)+(@sysvar::Vehicle_Model::Rbs_sim<<2)+
  (@sysvar::Vehicle_Model::Map_sim),variantInt,10);
  
  strncat(sensorsetstr,variantInt,elCount(sensorsetstr));

  filePutString(sensorsetstr,255,fileHandle);
  fileclose(fileHandle);
}
