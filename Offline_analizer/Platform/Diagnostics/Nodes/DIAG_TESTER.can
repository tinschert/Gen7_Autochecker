/*@!Encoding:1252*/
/**
 * @file DIAG_TESTER.can
 * @author ADAS_HIL_TEAM
 * @date 08-21-2023
 * @brief 
 *
 * ################################################################
 * C O P Y R I G H T S
 * ----------------------------------------------------------------
 * Copyright (c) 2023 by Robert Bosch GmbH. All rights reserved.
 
 * The reproduction, distribution and utilization of this file as
 * well as the communication of its contents to others without express
 * authorization is prohibited. Offenders will be held liable for the
 * payment of damages. All rights reserved in the event of the grant
 * of a patent, utility model or design.
 *
 * ################################################################
*/

includes
{
  #include "CAPL\Tester_On_Fuction.cin"
}

variables
{  
    byte      emptyString[kBufferSizeJumbo];

   
   	//Transmit
    const int txSize = 4096;
	  byte 	  TxDataBuffer[kBufferSizeJumbo];
   	int       TxLength;
    byte      TxDataBuffer_temp[3]={22,22,22};
	
	dword filehandle = 0;
    char buffer[32000];
    char text[512];
	char path[50] = "..\\CSV\\CCM_Event_List.csv";

    //Receive
    const int rxSize = 4098;
	  byte 	  RxDataBuffer[kBufferSizeJumbo];
   	int  	  RxBufferIndex;
   	int  	  RxLength_CAN;        
    char      hexaStr[6];

    //My evaluate
    int 	NrNeededRespBytes = 0;
	  int 	ReceiveBufferLength;

	  char	MVbuffer[500] = "";
	  char	MVbuffer2[500] = "0x";   	

    // Variables for Requests
	  int 	  DirectTxDataLen  = 0;
   	int   	  CurrentDiagServ  = 0;
	  int		  SId              = 0;
   	float 	  RespTime         = 0.0;

    //Constants for Diag Switch
    const int TESTER_PRESENT_ON = 0;
    const int DEFAULT_SESSION   = 1;
    const int PROGRAM_SESSION   = 2;
  	const int EXTENDED_SESSION	= 3;
    

  	const int EN_NOR_MSG_TX		= 3;
  	const int ECU_ID			    = 4;
  	const int ECU_DEV_ST    	= 5;
  	const int READ_DTC_BY_ST    = 6;
  	const int CLEAR_DTC			= 7;
  	const int READ_DTC_BY_ST_RBEOL = 89;
  	const int READ_DTC_PASS     = 13;

  	const int RD_CAMERA_LEFT    = 8;
  	const int RD_CAMERA_RIGHT   = 9;
  	const int RD_SW_VER         = 10;
  	const int TEST				      = 11;
  	const int DIRECT_RQ			    = 12;
  	const int RD_SERIAL_NR      = 14;
  	const int RESET             = 15;
  	const int START_IR_TEST     = 16;
  	const int STOP_IR_TEST      = 17;
  	const int START_IMG_TEST    = 18;
  	const int STOP_IMG_TEST     = 19;
  	const int GET_SYS_RUNTIME	  = 20;
  	const int RESET_RUNTIME		  = 21;
  	const int SHOW_ENG_INFO		  = 22;
  	const int ENV_DATA			= 23;
  	const int RD_CAN_SIG		= 24;
  	const int RD_TEMP    		= 25;
  	const int RD_CALIB_DATA     = 26;
  	const int RD_ECU_ST			= 27;
  	const int RD_TEMP_PROF		= 28;
    const int SKIP_CALIB		= 29;
  	const int CALIB_SHIFT_UP	= 30;
  	const int CALIB_SHIFT_DOWN	= 31;
  	const int CALIB_SHIFT_LEFT	= 32;
  	const int CALIB_SHIFT_RIGHT = 33;
  	const int CALIB_DATA_SAVE   = 34;
  	const int RD_MAX_CALIB_DATA = 35;
  	const int CALIB_AUTO        = 36;
  	const int CALIB_DATA_DEL    = 37;
  	const int READ_HIST_DTC    =  38;
  	const int CLEAR_HIST_DTC	= 39;
  	const int HIST_ENV_DATA		= 40;
  	const int START_CAM_ON		= 41;
  	const int START_CAM_OFF		= 42;
  	const int RQ_RES_CALIB_AUTO	= 43;
  	const int RQ_RES_SELFTEST	= 44;
  	const int RQ_RES_CHECKSUM	= 45;

    const int READ_HIST_DTC_BY_ST    = 47;
    const int FINGERPRINT       = 48;
    const int PROGDATE          = 49;
    const int SEEDNKEYREQUEST        =50;
    const int ALIGNMENT_START           =51; 
    const int ALIGNMENT_STOP     =52;
    const int ALIGNMENT_STATUS  =53;
    const int SEEDNKEYJLRRESP        =95;
    const int READ_ITC = 90;//M.I..
    const int CLEAR_ITC = 91;
    const int VIN_LEARN_START = 92;
    const int SEEDNKEYJLRREQUEST    =93;  
    const int VIN_LEARN_STATUS = 94;
    const int VIN_LEARN_STOP = 82;
    const int ECU_HARD_RESET = 83;
    const int ECU_SOFT_RESET = 84;
	
  	const int READ_BOSCH_CODING  = 85;
  	const int WRITE_BOSCH_CODING = 86;
  	const int CAMERA_RESET       = 87;
  	const int SEEDNKEYRESP       = 88;

    const int  READ_EWB_ACT      = 54;
    const int  READ_DEACT_FUNC   = 55;
    const int  PRE_WRITE         = 56;
    const int  DEACT_FUNC_FLA    = 57;
    const int  DEACT_FUNC_CCP    = 58;
    const int  DEACT_FUNC_VZE    = 59;
    const int  ALIGNMENT_RUN_STATUS =60;
    const int  ACT_EWB_VZF =61;
    const int  ACT_EWB_EHR =62;
    const int  ACT_EWB_FLA =63;
    const int  ACT_EWB_MOD =64;
    const int  ACT_EWB_HCA =65;
    const int  ACT_EWBs = 79; //MI
    const int  ACT_XCP =84;//MI 

    const int  READ_MASK_FAULT_CLASS =66; 
    const int  WRITE_MASK_FAULT_CLASS =67; 
    const int  READ_MASK_ERR_RCTN =68; 
    const int  WRITE_MASK_ERR_RCTN =69; 

    const int  READ_BAP_PERS =70; 
    const int  WRITE_BAP_PERS =71; 

    const int  READ_V_THRESHOLD_MAINBEAM_ON =72; 
    const int  WRITE_V_THRESHOLD_MAINBEAM_ON =73; 
    const int  READ_V_THRESHOLD_MAINBEAM_OFF =74; 
    const int  WRITE_V_THRESHOLD_MAINBEAM_OFF =75; 

    const int MINICODEREQUEST = 76;
    const int PRE_WRITE_MINICODE = 77;
    const int SEEDNKEYREPROGREQUESTWRITEKEY = 78;
    const int READ_Software_version    = 79;
   
    int InnerTempValue = 0;

    long copiedBytes ;

    //Anpassung Identifiers  all starting with 0x05
    const int EWB_VZE_ID=0x32;
    const int EWB_VZF_ID=0x33;
    const int EWB_EHR_ID=0x34;
    const int EWB_HCA_ID=0x35;
    const int EWB_MOD_ID=0x36;
    const int EWB_FLA_ID=0x37;
    const int DEACT_CCP_ID= 0x30;
    const int DEACT_FLA_ID= 0x19;
    const int DEACT_VZE_ID= 0x18;
    const int MASK_FAULT_CLASS_ID= 0x3C;
    const int MASK_ERR_RCTN_ID= 0x3B;
    const int BAP_PERS_ID= 0xA4;
    const int XCP_ID=0x30;//MI
    const int RB_SEC_MODE = 0xCC;
    const int SEEDNKEYBOSCHREQUEST = 0xCD;
    const int SEEDNKEYBOSCHRESP = 0xCE;

    //Anpassung Identifiers  all starting with 0x3B
    const int V_THRESHOLD_MAINBEAM_OFF_ID= 0x23;
    const int V_THRESHOLD_MAINBEAM_ON_ID= 0x24;

    //Anpassung Identifiers  all starting with 0x09 //MI
    const int EWBs_ID=0x02; //MI

    //Stringbuffer
    char 	  Stringbuffer[4098];
   	char	  StringAux[4098];	

    //read dtc variables
   	dword 	  errorDTC[256];
   	dword 	  errorStatus[256]; 
   	int  	  CurrentDTC = 0;
   	int  	  NrOfReadDTC ;   
	
	  dword 	  errorHistDTC[256];
   	byte 	  errorHistStatus[256]; 
   	int  	  CurrentHistDTC = 0;
   	int  	  NrOfHistDTC;  
   	int  	  NrOfReadHistDTC;   

	  // Tester Present Handling
   	msTimer   TesterPresentTimer;
   	const int TesterPresentTime = 2000;
   	const int FirstTesterPresentTime = 20;
    
  	/*   
   	message   TST_PhysicalReqCCM_UN msgDiagRequest = {
   				dword(0) = 0xffffffff,
   				dword(4) = 0xffffffff};

    
    message   TST_PhysicalRespCCM_UN ReqDiagMsgGlobal = {
   				dword(0) = 0x00000000,
   				dword(4) = 0x00000000}; 
    */
   	   
 	 
   	int 	  DiagActive = 0;       

    msTimer   UpdateRuntime;
	  const int UpdateCycle = 1000;
    
    //to doors-automate-tests

    int readTimeValue;          //elapsed time counter (ms)
    char DTCValue [255];        //internal container for error codes  
    msTimer readDtcTimer;       //for repeat the reading process
    int CNTR_VALUE=200;         //default timer resolution (ms)
    char readString[255];       //to store the read DTC command
    byte readRequest[255];      //to store the read DTC command
    int requestSize;            //
    char msString[30];          //for the information string
    byte ErrValue [4098];       //the representation of RxDataBuffer
    char ErrString [4098];      //the characteric representation of RxDataBuffer
    char tempString [4098];     //for internal use

    //Seed&key

    byte Fingerprint[9]={0x2e,0xf1,0x98,0x01,0x02,0x03,0x04,0x05,0x06};
    byte ProgrammingDate[6]={0x2e,0xf1,0x99,0x19,0x01,0x09};
    byte SeednKeyFBLRequest[2] = {0x27,0x61};
    byte SeednKeyJLREOLRequest[2] = {0x27,0x01};
    byte MinicodeRequest[2]= {0x27,0x21};
    dword seedReprogValue,  keyLowReprogValue, keyUpperReprogValue;
    dword keyReprogValue;
    dword authKey;
    byte     pufferEOL[10]={0,0,0,0,0,0,0,0,0,0};
    dword keyMaxReprogValue = 0xFFFFFFFF;
    dword WLA, WLAaktiv, WLApassiv; 

    byte whichlogin=0;
    dword result=0; 
    byte resultarray[6]={0x27,0,0,0,0,0};
    byte resultarra[5] = {0x27,0,0,0,0};
 
    // For new security Implementation
    char seedList[600][600];
    char keyList[2048][2048];
    char seedListJLR[600][600];
    char keyListJLR[2048][2048];
    int dynamicKeyLen;
    int securityType = SEEDNKEYREQUEST;
    int securityTypeJLR = SEEDNKEYJLRREQUEST;
    byte SecurityBuffer[1];
    int i, j, c_index, bin;
    byte input[8];
    int challenge[64], position_one[24], position_two[24];
    int init_array[24] = {1,0,0,1,0,1,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,1};
    byte sendKey[1024];

    int DynamicFlag = 0;
    char temp1[5];
    int k=0;
    char DynamicKey[2052];
    byte defaultsec[1];
    int Seed_buf[4]={0,0,0,0};
    int Seed_buf_Bosch[5]={0,0,0,0,0};
    msTimer JLRUnlockTimer;
    msTimer BoschUnlockTimer;
    msTimer ReadITCTimer;
    msTimer ClearITCTimer;
    char gstatusITC[22];
    msTimer VINTimer;
    int VINFlag;
    byte alignmentValue[2] = {0,0};
    int tempInt;
    msTimer alignmentTimer;
	  byte BoschCodingBuffer[50];
	
}

void StartDiagService( byte ServiceId )
{ 
    int i;
    long copiedBytes;

    CurrentDiagServ = ServiceId;
  
    if(ServiceId!=TESTER_PRESENT_ON)
         sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "...");
         sysSetVariableFloat(sysvar::DIAG_TESTER::sysDataReceived_Time, 0.0);   

   //Diag Switch
   switch ( ServiceId )
   {
	  case TESTER_PRESENT_ON:
							TxDataBuffer[0] = 0x3E;	
							TxDataBuffer[1] = 0x00;
							TxLength = 2;  
							TransmitTxBuffer();
							break;
	  case DEFAULT_SESSION:
							TxDataBuffer[0] = 0x10;
							TxDataBuffer[1] = 0x01;	
							TxLength = 2;  
							TransmitTxBuffer();
							break;
	  case PROGRAM_SESSION:
							TxDataBuffer[0] = 0x10;
							TxDataBuffer[1] = 0x02;	
							TxLength = 2;  
							TransmitTxBuffer();
							break;
	  case EXTENDED_SESSION:
							TxDataBuffer[0] = 0x10;
							TxDataBuffer[1] = 0x03;	//Extended diag session
							TxLength = 2;  
							TransmitTxBuffer();
							break;
    case ECU_HARD_RESET:
							TxDataBuffer[0] = 0x11;
							TxDataBuffer[1] = 0x01;	//Extended diag session
							TxLength = 2;  
							TransmitTxBuffer();
							break;
    case ECU_SOFT_RESET:
							TxDataBuffer[0] = 0x11;
							TxDataBuffer[1] = 0x03;	//Extended diag session
							TxLength = 2;  
							TransmitTxBuffer();
							break;
    case READ_DTC_BY_ST: 
							TxDataBuffer[0] = 0x19;
							TxDataBuffer[1] = 0x02;
							TxDataBuffer[2] = 0x09;  
							TxLength = 3; 
							TransmitTxBuffer();
							break;
	case CLEAR_DTC: 
							TxDataBuffer[0] = 0x14;
							TxDataBuffer[1] = 0xFF;  
							TxDataBuffer[2] = 0xFF;
							TxDataBuffer[3] = 0xFF;   
							TxLength = 4;
							TransmitTxBuffer();
							break;
	case DIRECT_RQ: 
							TxLength = DirectTxDataLen;
							TransmitTxBuffer();
							break;
/*
    case VIN_LEARN_START:
							TxDataBuffer[0] = 0x31;
							TxDataBuffer[1] = 0x01;
							TxDataBuffer[2] = 0x04;  
							TxDataBuffer[3] = 0x04; 
							TxLength = 4; 
							TransmitTxBuffer();
							break;
    case VIN_LEARN_STOP:
							TxDataBuffer[0] = 0x31;
							TxDataBuffer[1] = 0x02;
							TxDataBuffer[2] = 0x04;  
							TxDataBuffer[3] = 0x04; 
							TxLength = 4; 
							TransmitTxBuffer();
							break;
    case VIN_LEARN_STATUS:
							TxDataBuffer[0] = 0x31;
							TxDataBuffer[1] = 0x03;
							TxDataBuffer[2] = 0x04;  
							TxDataBuffer[3] = 0x04; 
							TxLength = 4; 
							TransmitTxBuffer();
							break;
    case RB_SEC_MODE: 
							TxDataBuffer[0] = 0x10;
							TxDataBuffer[1] = 0x60; 
							TxDataBuffer[2] = 0x42;
							TxDataBuffer[3] = 0x4F;
							TxDataBuffer[4] = 0x53;
							TxDataBuffer[5] = 0x43; 
							TxDataBuffer[6] = 0x48;
							TxLength = 7; 
							TransmitTxBuffer();
							break; 
    case READ_ITC:
							TxDataBuffer[0] = 0x22;
							TxDataBuffer[1] = 0xFD; 
							TxDataBuffer[2] = 0x09;
							TxLength = 3;
							TransmitTxBuffer();
							break;
    case CLEAR_ITC:
							TxDataBuffer[0] = 0x31;
							TxDataBuffer[1] = 0x01; 
							TxDataBuffer[2] = 0xF0;
							TxDataBuffer[3] = 0x01;
							TxLength = 4;
							TransmitTxBuffer();
							break;
	case ALIGNMENT_START:
							TxDataBuffer[0] = 0x31;
							TxDataBuffer[1] = 0x01; 
							TxDataBuffer[2] = 0x30;
							TxDataBuffer[3] = 0x4F;
							TxDataBuffer[4] = alignmentValue[0];
							TxDataBuffer[5] = alignmentValue[1];
							TxLength = 6;
							TransmitTxBuffer();
							break;
	case ALIGNMENT_STOP:
							TxDataBuffer[0] = 0x31;
							TxDataBuffer[1] = 0x02; 
							TxDataBuffer[2] = 0x30;
							TxDataBuffer[3] = 0x4F;
							TxLength = 4;
							TransmitTxBuffer();
							break;
  case ALIGNMENT_STATUS:
							TxDataBuffer[0] = 0x31;
							TxDataBuffer[1] = 0x03; 
							TxDataBuffer[2] = 0x30;
							TxDataBuffer[3] = 0x4F;
							TxLength = 4;
							TransmitTxBuffer();
							break;
	case ALIGNMENT_RUN_STATUS:
							TxDataBuffer[0] = 0x22;
							TxDataBuffer[1] = 0xA2; 
							TxDataBuffer[2] = 0x29;
							TxLength = 3;
							TransmitTxBuffer();
							break;
	case READ_BOSCH_CODING:
							TxDataBuffer[0] = 0x22;
							TxDataBuffer[1] = 0xFD;  
							TxDataBuffer[2] = 0x07;  
							TxLength = 3;
							TransmitTxBuffer();
							break;
	case SEEDNKEYBOSCHREQUEST: 
							TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x61;
							TxLength = 2;
							TransmitTxBuffer();
							break;
  case SEEDNKEYBOSCHRESP: 
							TxLength = 6;
							TransmitTxBuffer();
							break;
  case SEEDNKEYJLRRESP: 
							sysSetVariableData(sysvar::DIAG_TESTER::sysDataToTransmit,sendKey,elCount(sendKey));
							DirectTxDataLen = sysGetVariableData( sysvar::DIAG_TESTER::sysDataToTransmit, TxDataBuffer ,copiedBytes);
							DirectTxDataLen = copiedBytes;
							TransmitTxBuffer();
							break;
  case SEEDNKEYJLRREQUEST: 
							TxDataBuffer[0] = 0x27;
							TxDataBuffer[1] = 0x03;
							TxLength = 2;
							TransmitTxBuffer();
							break; 
    case WRITE_BOSCH_CODING: 
							TxLength = 49;
							TransmitTxBuffer();
							break;
	case SEEDNKEYRESP: 
							TxLength = 5;
							TransmitTxBuffer();
							//write("))))))))))))))))))) %d",TxLength);
							break; 
  case READ_Software_version: 
							TxDataBuffer[0] = 0x22;
							TxDataBuffer[1] = 0xF1;
							TxDataBuffer[2] = 0x88;  
							TxLength = 3; 
							TransmitTxBuffer();
							break;
*/
  }
}   

MyEvaluateResponse ()
{
	int i;
	int RespLength;

	char buffer[255];
	char buffer2[255]="0";

 
	strncpy(buffer2, "0", 6);
	strncpy(MVbuffer2, "",6);
	strncpy(MVbuffer, "",6);

	if( ReceiveBufferLength > 255 )
	{
		strncpy(buffer, "Answer length too big!",99);//English
    //strncpy(buffer, "Antwortlaenge zu gross!",99);//German
		//write("An error %s has occurred!", buffer)//English
		//write("Fehler '%s' ist aufgetreten!", buffer);an error has occurred
	}

	if( NrNeededRespBytes != 0 )
	{
		RespLength = NrNeededRespBytes;
	}
	else
	{
		RespLength = ReceiveBufferLength;
	}
	
	for(i=0; i < RespLength; i++)
	{
		ltoa(RxDataBuffer[i], MVbuffer2, 16);
		if( strlen( MVbuffer2 ) == 1 )
		{
			strncat(buffer2, MVbuffer2, 254);
			strncat(MVbuffer, buffer2, 254);
			strncpy(buffer2, "0", 6);
		}
		else
		{
			strncat(MVbuffer, MVbuffer2, 254);
		}
	}
  sysSetVariableString(sysvar::DIAG_TESTER::sysDataReceived_String ,MVbuffer);
}

void EvaluateRxData( int Length )
{
   int      DtcNr;  
   dword    auxRT;
   float    convert_rad_grad = 57.295779513082320876798154814105;

   dword    resultarray_32[6]={0,0,0,0,0,0};

   dword    REP_RBA_CBB_AKEY_VALUE  = 0x41916668;
   dword    REP_RBA_CBB_BKEY_VALUE  = 0x12774118;
   dword    REP_RBA_CBB_CKEY_VALUE  = 0x86905668;
   dword    REP_RBA_CBB_DKEY_VALUE  = 0x10371229;


   dword    WERK_RBA_CBB_AKEY_VALUE = 0x52917768;  //Minicode 2703/2704
   dword    WERK_RBA_CBB_BKEY_VALUE = 0x12774118;   // Porsche
   dword    WERK_RBA_CBB_CKEY_VALUE = 0x86905668;  // Porsche
   dword    WERK_RBA_CBB_DKEY_VALUE = 0x21482338;  // Porsche

   dword    DEV_RBA_CBB_AKEY_VALUE  = 0x46947376; //Minicode 2721/2722
   dword    DEV_RBA_CBB_BKEY_VALUE  = 0x12774118;  // Porsche
   dword    DEV_RBA_CBB_CKEY_VALUE  = 0x86905668;  // Porsche
   dword    DEV_RBA_CBB_DKEY_VALUE  = 0x45982573;   // Porsche

   dword    RBEOLPin = 0x42444441; //It has been derived from the ASCII values of "Bosch Diagnostics for Driver Assistance"
   dword    PMARequest = 0x80FA1108; //Plant mode activation part request

   dword    keytemp;
   char    buffer[50],tempbuffer[50];
   Byte    ByteValue[1];
   int     IdentifierId;
   int     IdentifierValue;

   int      i;
   dword j,m,k;
   
   char     Seed[1024];
   byte     puffer[128];
   byte securityRespBuffer[1100];
   char pufferStr[2200];
   char temp[5];
   char IMBuffer[4];
   int responseLen;
  
    //*****************************************************************//
    byte First_MID[4096];  
    byte Last_MID[4096];
    char	MVbuffer[4096] = "";
    char	MVbuffer2[4096] = "";
    char  buffer2[4096]="0"; 
    char	MVbuffer5[4096] = "";
    char	MVbuffer6[4096] = "";
    char  buffer5[4096]="0";
    dword bufferSize;
    int RBflag1 =0;
    int RBflag2 = 0;
    
    strncpy(buffer2, "0", 4);
	  strncpy(MVbuffer2, "",4);
	  strncpy(MVbuffer, "",4);
    strncpy(buffer5, "0", 4);
	  strncpy(MVbuffer6, "",4);
	  strncpy(MVbuffer5, "",4);


  
    //**************************************************************// 
    
    EvaluateResponse( );  
  
    switch ( CurrentDiagServ )  
    {
      
     case READ_DTC_BY_ST:  
          if ( RxDataBuffer[0] == 0x59 )
          {
            RxBufferIndex  = 3;
            NrOfReadDTC    = (Length - 3)/4;  
            DtcNr        = 1; 
            for (i = 0; i < NrOfReadDTC; i++)
            {
                  errorDTC[DtcNr]      = (dword)RxDataBuffer[RxBufferIndex++] << 16;
                  errorDTC[DtcNr]      += (dword)RxDataBuffer[RxBufferIndex++] << 8;
                  errorDTC[DtcNr]      += (dword)RxDataBuffer[RxBufferIndex++]; 
                  errorStatus[DtcNr++] = RxDataBuffer[RxBufferIndex++];
			   
            }
            if ( (NrOfReadDTC == 0) )
            {
              sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "No DTCs");
            }else{
                   sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "All DTCs received");
                  }

               CurrentDTC = 1;
               ShowDTCs();
            }
          break;
      /*
      case VIN_LEARN_STATUS:
      
             if(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x01)
             {
                putvalue(Env_VIN_Display,"Specified VIN already stored");
             }
             else if(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x00)
				     {
					      putvalue(Env_VIN_Display,"VIN Learn Successful");
				     } 
             else if(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0xFF)
				     {
					      putvalue(Env_VIN_Display,"VIN Learn Not Successful");
				     }
            else
            {
                putvalue(Env_VIN_Display,"Unknown Status");
            }
      break;
            
      case VIN_LEARN_START:
      
             if(RxDataBuffer[0] == 0x71 && RxDataBuffer[4] == 0x7B)
             {
                putvalue(Env_VIN_Display,"VIN Learn started");
             }  
             else
             {
                putvalue(Env_VIN_Display,"Unknown Status");
             }
      break;
            
      case VIN_LEARN_STOP:
      
             if(RxDataBuffer[0] == 0x71 && RxDataBuffer[4] == 0x7A)
             {
                putvalue(Env_VIN_Display,"VIN Learn Stopped");
             }  
             else if(RxDataBuffer[0] == 0x71 && RxDataBuffer[4] == 0x78)
             {
                putvalue(Env_VIN_Display,"VIN Learn Stopped before completion");
             }
             else
             {
                putvalue(Env_VIN_Display,"Unknown Status");
             }
      break;
      
            
      case SEEDNKEYJLRREQUEST: 
                Seed_buf[0] = RxDataBuffer[2];
                Seed_buf[1] = RxDataBuffer[3];
                Seed_buf[2] = RxDataBuffer[4];
                Key_Calculation();
                StartDiagService( SEEDNKEYRESP);
         break;

    
    case SEEDNKEYBOSCHREQUEST: 
           
          if(RxDataBuffer[0] != 0x7F)
          {
                Seed_buf_Bosch[0] = RxDataBuffer[2];
                Seed_buf_Bosch[1] = RxDataBuffer[3];
                Seed_buf_Bosch[2] = RxDataBuffer[4];
                Seed_buf_Bosch[3] = RxDataBuffer[5];
                calculate_key_Bosch();
                StartDiagService( SEEDNKEYBOSCHRESP);
          }
          else
          {
            canceltimer(ReadITCTimer);
            canceltimer(ClearITCTimer);
          }
    break;
      
    case READ_ITC:
      
                parseITCData(RxDataBuffer,Length);
    break;
      
    case ALIGNMENT_RUN_STATUS:
    case ALIGNMENT_STATUS:
          //write("^^^^^^^^ %x %x %x",RxDataBuffer[0],RxDataBuffer[3],RxDataBuffer[5]);
      
          if((RxDataBuffer[3] != 0x0F)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] != 0x0F))
          {
             if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x09)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x09))
             {
                putvalue(Env_Alignment_Display,"Target Not Found");
             }
             else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x07)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x07))
				     {
					      putvalue(Env_Alignment_Display,"Alignment Successful");
				     }
				     else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x08)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x08))
				     {
					      putvalue(Env_Alignment_Display,"Alignment Aborted");
				     }
             else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x0A)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x0A))
				     {
					      putvalue(Env_Alignment_Display,"Invalid Input Value");
				     }
             else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x06)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x06))
				     {
					      putvalue(Env_Alignment_Display,"Alignment Not Executed");
				     }
             else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x0B)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x0B))
				     {
					      putvalue(Env_Alignment_Display,"Horizontal Bad Angle");
				     }
             else if((RxDataBuffer[0] == 0x62 && RxDataBuffer[3] == 0x0C)||(RxDataBuffer[0] == 0x71 && RxDataBuffer[5] == 0x0C))
				     {
					      putvalue(Env_Alignment_Display,"Vertical Bad Angle");
				     }
				     else
				     {
					      putvalue(Env_Alignment_Display,"Unknown Error");
				     }
                  cancelTimer(alignmentTimer);
        }
				else
				{
					putvalue(Env_Alignment_Display,"Alignment in progress");
				}
				
	  break;
	  
	  case READ_BOSCH_CODING:
        for(i = 0; i<elcount(BoschCodingBuffer); i++)
    		{
    			BoschCodingBuffer[i] = RxDataBuffer[i];
    		}
    		
    		BoschCodingRead(RxDataBuffer);
    		break;
  */
  }

}  

int EvaluateResponse()
{  
   int ret; 
   ret = 0;

   if ( RxDataBuffer[0] == 0x7F )
   {
   
      switch ( RxDataBuffer[2] ) 
      {
         case 0x10:
                  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "General reject");
                  break;

         case 0x11: 
                  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Service not supported");
                  break;

         case 0x12: 
                  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "SubFunction Not Supported");
                  break;

         case 0x13: 
                  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, " InCorrect Message Length-invalid Format");
                  break;

         case 0x21: 
                  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Busy Repeat Request");
                  break;

         case 0x22: 
                  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Conditions Not Correct");
                  break;

     //    case 0x23: 
     //           sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Routine not complete");
     //           break;

         case 0x24: 
                  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Request Sequence Error");
                  break;

         case 0x26: 
                  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Failure Prevents Execution of requested action");
				  break;

         case 0x31: 
				  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Request Out Of Range");
				  break;

         case 0x33: 
				  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Security Access Denied");
				  break;

         case 0x35: 
				  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Invalid key");
				  break;

         case 0x36: 
				  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Exceed number of attempts");
				  break;

         case 0x37: 
				  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Time delay not expired");
				  break;

         case 0x78: 
				  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Request Correctly Received-Response Pending");
				  // Wait
				  ret = 0; 
				  break;

      //   case 0x80: 
      //      sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Service not supported in active mode");
      //   break;

         case 0x7E: 
				  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "SubFunction Not Supported In Active Diagnostic Session");
				  break;

         case 0x7F: 
				  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Service Not Supported In Active Diagnosic Session");
				  break;
             
         case 0x83: 
				  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Condition not correct - Engine running");
				  break;
         
         case 0x88: 
				  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Vehicle Speed Too High");
				  break;

         case 0x89: 
				  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Negative Response:ESP_v_Signal<= 50 km/h");
				  break;
         
        case 0x93:
				  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "VoltageTooLow");
				  break;

        case 0x92:
				  sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "VoltageTooHigh");
				  break;


         default:   
				 sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status, "Negative Response: Acknowledge not defined");
				 break;
         }
   }
   else
   {
      if ( RxDataBuffer[0] == ( SId + 0x40 ) )        
      {
         // Positive response
         sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status,"OK! Positive response");
         ret = 1; 
      }
      else                      
      {
        sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_Status ,"Unknown response");
        ret = 0; 
      }
   }

   return ( ret ); 
}

void TransmitTxBuffer (void)
{ 
  // OSEK TP supports up to 4 GiB with Jumbo frames, but limit that to a much lower value for this demo
  if (TxLength > kBufferSizeJumbo)
      TxLength = kBufferSizeJumbo;

  write("%s, connection %d: Send request for %d data bytes",gECU, kIdTester1, TxLength);

  setTimerCyclic(tFlashTxLEDTester1, kDuration_LEDFlash_ms);
  setTimer(tSwitchOffTxLEDTester1, kDuration_RxLEDFlashOff_ms);

  CanTpSendData(gHandleTester1, TxDataBuffer, TxLength);
 
	if(TxDataBuffer[0] != 0x3E)
  {
    sysSetVariableData(sysvar::DIAG_TESTER::sysDataReceived,emptyString,0);
    sysSetVariableInt(sysvar::DIAG_TESTER::sysNoOfBytesReceived,0);
    sysSetVariableString(sysvar::DIAG_TESTER::sysDataReceived_String,"");// delete old value from receive 

    sysSetVariableData(sysvar::DIAG_TESTER::sysDataToTransmit,TxDataBuffer,TxLength);
  }
	SId = TxDataBuffer[0];

}

OSEKTL_DataCon(long status)
{
	if (status != 0) 
	{
		RespTime = ( (float) timeNow() * (-1.0) );	
       	
	}
	else
	{
		write("Tx error, status is %d", status);
	}
}

on sysvar_update sysvar::DIAG_TESTER::SESSION::TESTER_PRESENT
{ 
    if ( @this ) 
    {
        StartDiagService( TESTER_PRESENT_ON );
        setTimer (TesterPresentTimer, FirstTesterPresentTime);//First time
    }
    else
    {
        cancelTimer (TesterPresentTimer);
    } 
}

on timer TesterPresentTimer
{
   StartDiagService( TESTER_PRESENT_ON );
   // reStart timer
   setTimer (TesterPresentTimer, TesterPresentTime);
} 

on sysvar_update sysvar::DIAG_TESTER::SESSION::DEF_SESS
{ 
    if ( @this ) 
    {
      StartDiagService( DEFAULT_SESSION );
    }
     
}

on sysvar_update sysvar::DIAG_TESTER::SESSION::PRO_SESS
{ 
    if (@this ) 
    {
      StartDiagService( PROGRAM_SESSION );
    }
    
}

on sysvar_update sysvar::DIAG_TESTER::SESSION::EXT_SESS
{ 
    if ( @this ) 
    {
      StartDiagService( EXTENDED_SESSION );
    }  
}

on sysvar_update sysvar::DIAG_TESTER::ECU_RESET::Hard_Rest
{ 
    if ( @this ) 
    {
      StartDiagService( ECU_HARD_RESET );
    }
     
}

on sysvar_update sysvar::DIAG_TESTER::ECU_RESET::Soft_Rest
{ 
    if ( @this ) 
    {
      StartDiagService( ECU_SOFT_RESET );
    }
     
}

on sysvar_update sysvar::DIAG_TESTER::DTC_INFO::DTC_Read
{ 
    if ( @this ) 
    {
        ClearDtcDisplay();
        StartDiagService( READ_DTC_BY_ST );
    }
}

on sysvar_update sysvar::DIAG_TESTER::DTC_INFO::DTC_Clear
{ 
    if ( @this ) 
    {
      StartDiagService( CLEAR_DTC );
	    ClearDtcDisplay();
    }
}

on sysvar_update sysvar::DIAG_TESTER::DTC_INFO::DTC_CountDown
{ 
    if ( @this ) 
    {
            CurrentDTC--;
            ShowDTCs(); 
        }
}

on sysvar_update sysvar::DIAG_TESTER::DTC_INFO::DTC_CountUP
{ 
    if ( @this ) 
    {
            CurrentDTC++;
            ShowDTCs(); 
        }
}

void GetDtcName (dword error,int DTC_or_historical)
{	
	char DTCText [256] = "";
  long res;
  int v;

  // Hole DTC Beschreibung aus Tabelle
  // res=GetDTCdescription_Kamera(error, DTCText);
  
  for (v = 0; v < elcount(DTCText); v++)
  {
      DTCText[v] = ' ';
  }
  
  res=GetDTCdescription(error, DTCText);
  
  write("GetDtcName=%d",res);
  if(res == 0) // DTC in Tabelle nicht gefunden
  {
      snprintf( DTCText, 255,"Unknown Error: %d",error);
  }

 	if (DTC_or_historical==1)  //ReadDTC
	{
    write("DTCText""%s",DTCText);
		res=sysSetVariableString(sysvar::DIAG_TESTER::DTC_INFO::DTC_Name,DTCText);
	}
   
}

long GetDTCdescription(dword error, char DTCText[])
{
  char str1[100]; 
  char str[100]; 
  long pos;
  int k, m;
  filehandle = 0;
  k = 0;
  
  ltoa(error, str1, 16); // dword to string
  toUpper(str, str1, elcount(str));
  
  filehandle = openFileRead(path, 0);

  if (filehandle != 0) 
  {   
     while (fileGetString(buffer, elcount(buffer), filehandle) != 0) // till end of file ...
  	 {        
         pos = strstr(buffer, str);
      	 
         if (pos != -1)
         {
          	 for (i = pos; i > 0 ; i--)
             {
                if (buffer[i] == ';')
                {
                    for (j = i-1; j > 0; j--)
                    {
                        if (buffer[j] != ';')
                				{
                           continue;
                        }
                        else
                        {
                           break;
                        }
                    }
                    
                    for (m = j+1; m <= i-1; m++)
                    {
                        DTCText[k++] = buffer[m];
                    }
                    
                    return 1;
                }               
          	  }	  
          }
      }
  }
  
  return 0;  
}

void ClearDtcDisplay (void)
{
   NrOfReadDTC = 0;
   CurrentDTC  = 0;
   ShowDTCs();
}

void ShowDTCs (void)
{
   char buffer[50];
   long buffer_dec;
   
   if ( CurrentDTC > NrOfReadDTC )
   {
      CurrentDTC = NrOfReadDTC;
   } 
   else if ( (CurrentDTC < 1) && (NrOfReadDTC) )
   {
      CurrentDTC = 1;
   }
   else if ( (CurrentDTC < 0) && (!NrOfReadDTC) )
   {
      CurrentDTC = 0;
   } 

   snprintf (buffer, 49, "%02d/%02d", CurrentDTC, NrOfReadDTC);
   sysSetVariableString(sysvar::DIAG_TESTER::DTC_INFO::DTC_Position,buffer);

   if ( CurrentDTC )
   {
      // DTC No
      snprintf (buffer, 49, "%06x",   errorDTC[CurrentDTC]);
      sysSetVariableString(sysvar::DIAG_TESTER::DTC_INFO::DTC_Nr,buffer);

      //DTC Status
      snprintf (buffer, 49, "%02x", errorStatus[CurrentDTC]);
      sysSetVariableString(sysvar::DIAG_TESTER::DTC_INFO::DTC_State,buffer);
      GetDtcName (errorDTC[CurrentDTC],1);
   }
   else
   {
      sysSetVariableString(sysvar::DIAG_TESTER::DTC_INFO::DTC_Nr,"----");
      sysSetVariableString(sysvar::DIAG_TESTER::DTC_INFO::DTC_State,"--");
      sysSetVariableString(sysvar::DIAG_TESTER::DTC_INFO::DTC_Name,"----");
   } 

}

FillErrString (int length)
{
  //to create string representation of (bin)ErrValue[] in (char)ErrString[]

  char temp[3];
  int i;
  strncpy(ErrString,"",0);
  if (length!=0)
  {
  for (i=0;i<length;i++) 
      {
      strncpy(tempString,"",0);
      ltoa(ErrValue[i],temp,16);
      if (strlen(temp)==1) strncpy(tempString,"0",2);
      strncat(tempString,temp,(strlen(tempString)+strlen(temp))+1);
      //if (i<10) write("%d.%s->%s",i,temp,tempString);
      strncat(ErrString,tempString,strlen(tempString)+strlen(ErrString)+1);
      }
  length=0;
  //write("***At %f ErrString= %s",timeNowFloat()/100000,ErrString);
  }


}

//on timer ActPMode
//{
//    StartDiagService( P_MODE_ACT_P2 );
//}

/*

on timer UpdateRuntime
{
	StartDiagService( GET_SYS_RUNTIME );
	SetTimer( UpdateRuntime, UpdateCycle);
}

on preStart
{

	char absPath[256];
  char absPathsecurity[250];
  
  registerUserFile("Ethernet SVC\\CCM_Event_List.csv", 0);
  getUserFilePath("CCM_Event_List.csv", absPath, 256);
  
  filehandle = openFileRead(path, 0);
  if (!filehandle) 
  {
    write("Error reading CSV file!!!");
  }
  
  // if(0!=  ReadDTCTableFile_Kamera(absPath))
  // {
  // write("Error reading CSV file!!!");
  // }
  
  //write("##############%s",absPath);

}

on start
{
    defaultsec[0] = 0x61;
    putvalue(Env_Doip_Security_SubFunctionCAN,defaultsec);
    defaultsec[0] = 0x01;
    putvalue(Env_Doip_Security_SubFunction2CN,defaultsec);
    // Default Suche nach DTC 000124
    putValue(Env_ITC_Display,"");
    putValue(Env_VIN_Display,"");
    putValue(Env_Alignment_Display,"");
    putValue(EnvTesterPresentOnOffCAN,0);
  
}

on envVar Env_ReadITC
{
   if ( getValue (this) )
   {
        putValue(Env_ITC_Display,"");
        StartDiagService( RB_SEC_MODE );
        setTimer(BoschUnlockTimer,100);
        setTimer(ReadITCTimer,300);
        
    }
}

on timer ReadITCTimer
{
  StartDiagService( READ_ITC );
}

on envVar EnvSetReadDTC
{
    int i;

    getValue(this,readString);

    if (strlen(readString)!=0) {

        //initialization
        requestSize = getValueSize(EnvSetReadDTC);
        strncpy(DTCValue,"",255);
        readTimeValue=0;
        putValue(EnvErrValueOutput,"");
        for (i=0;i<2048;i++) ErrValue[i]=0;
        //write("***At %fs (timer=%ims) request= %s",timeNowFloat()/100000,CNTR_VALUE,readString);

        //start timer at first time
        setTimer(readDtcTimer,CNTR_VALUE);

    } //end if
    //putValue(EnvDirectSend,readString);

	//getValue(EnvSetReadDTC,readString);
	if( strlen(readString) == 0 )
	{
		//write("Variable neu initialisiert");
		//putValue(EnvSendBuffer_1,0);
	}
	else
	{
		strncpy(tempString, "0x",3);

		for(i=0; i<= requestSize-3; i+=2)
		{
			tempString[2] = readString[i];
			tempString[3] = readString[i+1];
			tempString[4] = 0;
			readRequest[i/2] = atol( tempString );
		}
		//putValue(EnvTxData_1CAN, TransmitBuffer, length);
		//putValue(EnvTransferCAN, length);
		//putValue(EnvSendBuffer_1,1);

		TxLength = (requestSize - 1)/2;
        for (i=0; i<TxLength; i++) TxDataBuffer[i]=readRequest[i];
        TransmitTxBuffer();
	}

    putValue(EnvSetReadDTC,"");

}

on timer readDtcTimer
{
    int i;
    readTimeValue+=CNTR_VALUE;

    if (readTimeValue < 1000)   //try to read until 1000ms
    {
        //putValue(EnvDirectSend,readString);
		TxLength = (requestSize - 1)/2;
        for (i=0; i<TxLength; i++) TxDataBuffer[i]=readRequest[i];
        TransmitTxBuffer();


        strncpy(DTCValue,ErrString,strlen(ErrString)+1);
        //write("At %f DTCValue=%s",timeNowFloat()/100000,DTCValue);

        // if NOT "Busy Repeat Request", NOT "OK", NOT "Response Pending"
        if ( strncmp(DTCValue,"7f1921",6)!=0 &&     
             strncmp(DTCValue,"54",2)    !=0 &&
             strncmp(DTCValue,"7f1978",6)!=0 &&
             strlen(DTCValue)            !=0 )      
        {
            putValue(EnvErrValueOutput,DTCValue);
        } 
        else
        {
            //else (if "Busy...") do nothing
        }

        setTimer(readDtcTimer,CNTR_VALUE);
    }
    else  // time elapsed
    {
        cancelTimer(readDtcTimer);
        if (getValue(EnvErrValueOutput,DTCValue)==0)
        {
            putValue(EnvErrValueOutput,"No answer received.");
        }

        //syncronise the environmental variables
        putValue(EnvErrValueOutput,DTCValue);
        //write("***At %f EnvErrValueOutput= %s",timeNowFloat()/100000,DTCValue);

    }

}

on envVar Env_ClearITC
{
   if ( getValue (this) )
   {
        putValue(Env_ITC_Display,"");
        StartDiagService( RB_SEC_MODE );
        setTimer(BoschUnlockTimer,100);
        setTimer(ClearITCTimer,300);

    }
}

On timer ClearITCTimer
{
  StartDiagService( CLEAR_ITC );
  //setTimer(BoschUnlockTimer,100);
  setTimer(ReadITCTimer,300);
}

On envVar Env_VINLearn
{
  if ( getValue (this) )
  {
     putvalue(Env_JLRSecurity_CCM,1);
     setTimer(VINTimer,300);
     VINFlag = 1;
  }
}

On envVar Env_VINLearn_Stop
{
  if ( getValue (this) )
  {
     putvalue(Env_JLRSecurity_CCM,1);
     setTimer(VINTimer,300);
     VINFlag = 2;
  }
}

On envVar Env_VINLearn_Status
{
  if ( getValue (this) )
  {
     putvalue(Env_JLRSecurity_CCM,1);
     setTimer(VINTimer,300);
     VINFlag = 3;
  }
}

on timer VINTimer
{
  if(VINFlag == 1)
  {
    StartDiagService( VIN_LEARN_START );
  }
  else if(VINFlag == 2)
  {
    StartDiagService( VIN_LEARN_STOP );
  }
  else if(VINFlag == 3)
  {
    StartDiagService( VIN_LEARN_STATUS );
  }
  else if(VINFlag == 4)
  {
    StartDiagService( ECU_HARD_RESET );
  }
  else if(VINFlag == 5)
  {
    StartDiagService( ALIGNMENT_START );
    setTimerCyclic(alignmentTimer,500);
  }
  else if(VINFlag == 6)
  {
    StartDiagService( ALIGNMENT_STOP );
    setTimerCyclic(alignmentTimer,500);
  }
  else if(VINFlag == 7)
  {
    StartDiagService( ALIGNMENT_STATUS );
  }
}

On envVar Env_Alignment_Start
{
  if ( getValue (this) )
  {
     putvalue(Env_JLRSecurity_CCM,1);
     setTimer(VINTimer,300);
     VINFlag = 5;
     tempInt = (@Env_Alignment_Input *100);
     alignmentValue[0] = tempInt >>8;
     alignmentValue[1] = tempInt;
  }
}

on timer alignmentTimer
{
  StartDiagService(ALIGNMENT_RUN_STATUS);
}

On envVar Env_Alignment_Stop
{
  if ( getValue (this) )
  {
     putvalue(Env_JLRSecurity_CCM,1);
     setTimer(VINTimer,300);
     VINFlag = 6;
  }
}

On envVar Env_Alignment_Status
{
  if ( getValue (this) )
  {
     putvalue(Env_JLRSecurity_CCM,1);
     setTimer(VINTimer,300);
     VINFlag = 7;
  }
}

on envVar Env_JLRSecurity_CCM
{
   if ( getValue (this) )
    {
        
      StartDiagService( EXTENDED_SESSION );
      setTimer(JLRUnlockTimer,100);
      putvalue(Env_JLRSecurity_CCM,0);
    }
}

On timer JLRUnlockTimer
{
  StartDiagService( SEEDNKEYJLRREQUEST );
}

on envVar Env_BoschSecurity_CCM
{
   if ( getValue (this) )
    {
      StartDiagService( RB_SEC_MODE );
      setTimer(BoschUnlockTimer,100);
    }
}

On timer BoschUnlockTimer
{
  StartDiagService( SEEDNKEYBOSCHREQUEST );
}

on envVar Env_BoschCoding_Read
{
	if ( getValue (this) )
    {
      StartDiagService( READ_BOSCH_CODING );
    }
}

on envVar Env_BoschCoding_Write
{
	if ( getValue (this) && (BoschCodingBuffer[0] == 0x62))
    {
		BoschCodingWrite();
		for(i = 0; i<elcount(BoschCodingBuffer);i++)
		{
			TxDataBuffer[i] = BoschCodingBuffer[i];
		}
		StartDiagService( WRITE_BOSCH_CODING );
    }
}

CalculateKey (dword SeedValue,dword RBA_CBB_AKEY_VALUE, dword RBA_CBB_BKEY_VALUE, dword RBA_CBB_CKEY_VALUE, dword RBA_CBB_DKEY_VALUE)
{

        int      j;
        dword    keytemp;
      
        
        	keyReprogValue = SeedValue;

        	for(j = 0; j <8 ; j++)
        	{

            	keytemp = keyReprogValue ;
            	keyReprogValue = keyReprogValue + RBA_CBB_AKEY_VALUE;
	       		  // write(" keytemp and keyReprogValue  for j value %i beginning loop: %lx, %lx ",j, keytemp, keyReprogValue );    
    
    			if((keyMaxReprogValue - RBA_CBB_AKEY_VALUE) < keytemp)
    			{
    	  		//Rotate Right by 10 
 	       		keyLowReprogValue = keyReprogValue & (0x000001FF);
 	    			keyUpperReprogValue = keyLowReprogValue << 23;
 	    			keyReprogValue = keyReprogValue >> 9;
 	    			keyReprogValue = keyReprogValue | keyUpperReprogValue;
       			keyReprogValue = keyReprogValue ^ RBA_CBB_BKEY_VALUE;

           }
    			else
    			{
 	    		//Rotate Left by 13 
 	    		  keyUpperReprogValue = keyReprogValue & (0xFFF80000);
 			      keyLowReprogValue   = keyUpperReprogValue >> 19;
 			    	keyReprogValue      = keyReprogValue << 13;
		 	    	keyReprogValue      = keyReprogValue | keyLowReprogValue;
		        keyReprogValue      = keyReprogValue ^ RBA_CBB_CKEY_VALUE;

           }
         }
 
         keyReprogValue = keyReprogValue - RBA_CBB_DKEY_VALUE;
              
           
         //Key Algo end 
			    //   write(" final  keyReprogValue %lx",keyReprogValue ); 
}

void BoschCodingWrite()
{
	BoschCodingBuffer[0] = 0x2E;
	BoschCodingBuffer[1] = 0xFD;
	BoschCodingBuffer[2] = 0x07;

	BoschCodingBuffer[9] = @Env_DMonitoring_1>>8;
	BoschCodingBuffer[10] = @Env_DMonitoring_1;
	
	BoschCodingBuffer[11] = @Env_DMonitoring_2>>8;
	BoschCodingBuffer[12] = @Env_DMonitoring_2;
	
	BoschCodingBuffer[13] = @Env_DMonitoring_3>>8;
	BoschCodingBuffer[14] = @Env_DMonitoring_3;
	
	BoschCodingBuffer[15] = @Env_DMonitoring_4>>8;
	BoschCodingBuffer[16] = @Env_DMonitoring_4;
	
	BoschCodingBuffer[17] = @Env_DMonitoring_5>>8;
	BoschCodingBuffer[18] = @Env_DMonitoring_5;
	
	BoschCodingBuffer[19] = @Env_DMonitoring_6>>8;
	BoschCodingBuffer[20] = @Env_DMonitoring_6;
	
	BoschCodingBuffer[21] = @Env_DMonitoring_7>>8;
	BoschCodingBuffer[22] = @Env_DMonitoring_7;
	
	BoschCodingBuffer[23] = @Env_DMonitoring_8>>8;
	BoschCodingBuffer[24] = @Env_DMonitoring_8;
	
	BoschCodingBuffer[25] = @Env_DMonitoring_9>>8;
	BoschCodingBuffer[26] = @Env_DMonitoring_9;
	
	BoschCodingBuffer[27] = @Env_DMonitoring_10>>8;
	BoschCodingBuffer[28] = @Env_DMonitoring_10;
	
	BoschCodingBuffer[29] = @Env_DMonitoring_11>>8;
	BoschCodingBuffer[30] = @Env_DMonitoring_11;
	
	BoschCodingBuffer[31] = @Env_DMonitoring_12>>8;
	BoschCodingBuffer[32] = @Env_DMonitoring_12;
	
	BoschCodingBuffer[33] = @Env_DMonitoring_13>>8;
	BoschCodingBuffer[34] = @Env_DMonitoring_13;
	
	BoschCodingBuffer[35] = @Env_DMonitoring_14>>8;
	BoschCodingBuffer[36] = @Env_DMonitoring_14;
	
	BoschCodingBuffer[37] = @Env_DMonitoring_15>>8;
	BoschCodingBuffer[38] = @Env_DMonitoring_15;
	
	BoschCodingBuffer[39] = @Env_DMonitoring_16>>8;
	BoschCodingBuffer[40] = @Env_DMonitoring_16;
	
	BoschCodingBuffer[41] = @Env_DMonitoring_17>>8;
	BoschCodingBuffer[42] = @Env_DMonitoring_17;
	
	BoschCodingBuffer[43] = @Env_DMonitoring_18>>8;
	BoschCodingBuffer[44] = @Env_DMonitoring_18;
	
	BoschCodingBuffer[45] = @Env_DMonitoring_19>>8;
	BoschCodingBuffer[46] = @Env_DMonitoring_19;
	
	BoschCodingBuffer[47] = @Env_DMonitoring_20>>8;
	BoschCodingBuffer[48] = @Env_DMonitoring_20;
}

void BoschCodingRead(byte RxData1[])
{
  if(@Env_ReadBoschCode_Check == 1)
  {
    //Do nothing
  }
  else
  {
	@Env_DMonitoring_1 = (RxData1[9]<<8)+RxData1[10];
	@Env_DMonitoring_2 = (RxData1[11]<<8)+RxData1[12];
	@Env_DMonitoring_3 = (RxData1[13]<<8)+RxData1[14];
	@Env_DMonitoring_4 = (RxData1[15]<<8)+RxData1[16];
	@Env_DMonitoring_5 = (RxData1[17]<<8)+RxData1[18];
	@Env_DMonitoring_6 = (RxData1[19]<<8)+RxData1[20];
	@Env_DMonitoring_7 = (RxData1[21]<<8)+RxData1[22];
	@Env_DMonitoring_8 = (RxData1[23]<<8)+RxData1[24];
	@Env_DMonitoring_9 = (RxData1[25]<<8)+RxData1[26];
	@Env_DMonitoring_10 = (RxData1[27]<<8)+RxData1[28];
	@Env_DMonitoring_11 = (RxData1[29]<<8)+RxData1[30];
	@Env_DMonitoring_12 = (RxData1[31]<<8)+RxData1[32];
	@Env_DMonitoring_13 = (RxData1[33]<<8)+RxData1[34];
	@Env_DMonitoring_14 = (RxData1[35]<<8)+RxData1[36];
	@Env_DMonitoring_15 = (RxData1[37]<<8)+RxData1[38];
	@Env_DMonitoring_16 = (RxData1[39]<<8)+RxData1[40];
	@Env_DMonitoring_17 = (RxData1[41]<<8)+RxData1[42];
	@Env_DMonitoring_18 = (RxData1[43]<<8)+RxData1[44];
	@Env_DMonitoring_19 = (RxData1[45]<<8)+RxData1[46];
	@Env_DMonitoring_20 = (RxData1[47]<<8)+RxData1[48];
  }
	
}

void Key_Calculation()
{

 long request,response; // message handles
 byte KeyArray1, KeyArray2, KeyArray3;
 byte gChallengebyte[8];
 // Declare and initialize the temporary variables 
	long InitialVal ;
    //long challengebyte = 0X5E4D3C2B1A;
	byte Index, ModVal, RefIndex, BitValue,temp1,temp2,mask;

  InitialVal = 0XC541A9;request=0;response=0;Index=0; 
  ModVal=0; RefIndex=0; BitValue=0;temp1=0;temp2=0;mask=0;
  
  //Initialize the Challenge Bytes 
	gChallengebyte[7] = 0x34;//0x4D;
	gChallengebyte[6] = 0x31;//0x52;
	gChallengebyte[5] = 0x52;//0x52;
	gChallengebyte[4] = 0x52;//0x31;
	gChallengebyte[3] = 0x4D;//0x34;0

	// MSB of the Seed is stored in the least byte of the array 
	gChallengebyte[0] = Seed_buf[0];
	gChallengebyte[1] = Seed_buf[1];
	gChallengebyte[2] = Seed_buf[2];
   
  for (Index = 0; Index < 64; Index++)
	{
        ModVal = (Index % 8);
  
		if((ModVal == 0) && (Index != 0))
		{
   
          RefIndex++;
    }
        temp1 = (InitialVal & 0x000001);
        temp2= gChallengebyte[RefIndex] & (0x000001);
        gChallengebyte[RefIndex]= gChallengebyte[RefIndex]>>1;
        BitValue = temp1 ^ temp2;
        InitialVal = ( InitialVal >> 1);
      
        if(BitValue != 0)
        {
            InitialVal ^= 0x909028;
        }
	}
 //Byte R1 - Most Significant Byte of the Key 
	KeyArray1 = ((InitialVal & 0x000000F0) >> 4);
	KeyArray1 |= ((InitialVal & 0x00000F00) >> 4);

	// Byte R2 
	KeyArray2 = ((InitialVal & 0x00F00000) >> 20);
	KeyArray2 |=((InitialVal & 0x0000F000) >> 8);

	// Byte R3 - Least Significant Byte of the Key 
	KeyArray3 = ((InitialVal & 0x000F0000) >> 16);
	KeyArray3 |= ((InitialVal & 0x0000000F) << 4);
  TxDataBuffer[0] = 0x27;
  TxDataBuffer[1] = 0x04;
  TxDataBuffer[2] =KeyArray1;
  TxDataBuffer[3]=KeyArray2;
  TxDataBuffer[4]=KeyArray3;

}

void calculate_key_Bosch()
{
//Start Key Calculation
dword hexnumber,k1,k2,k3,k3_key;
hexnumber =0;
k3_key=0;
hexnumber =  (hexnumber | (Seed_buf_Bosch[0] & 0x000000FF)<<24);    // diagns_respbyte3 must remain constant //
hexnumber =  (hexnumber | (Seed_buf_Bosch[1] & 0x000000FF)<<16);    // diagns_respbyte4 must remain constant //
hexnumber =  (hexnumber | (Seed_buf_Bosch[2] & 0x000000FF)<<8);    // diagns_respbyte5 must remain constant //
hexnumber =  (hexnumber | (Seed_buf_Bosch[3] & 0x000000FF)<<0);    // diagns_respbyte6 must remain constant //
k1 = 0xB21ACD23;
k2 = k1 ^ hexnumber;
k3_key|= ((k2 & 0x000000FF)<<16);
k3_key|= ((k2 & 0x0000FF00)>>8);
k3_key|= ((k2 & 0x00FF0000)<<8);
k3_key|= ((k2 & 0xFF000000)>>16);
  TxDataBuffer[0] = 0x27;
  TxDataBuffer[1] = 0x62;
  TxDataBuffer[5]=((k3_key & 0x000000FF)>>0);
  TxDataBuffer[4]=((k3_key & 0x0000FF00)>>8);
  TxDataBuffer[3]=((k3_key & 0x00FF0000)>>16);
  TxDataBuffer[2]=((k3_key & 0xFF000000)>>24);
//End Key Calculation
}//endkey

void parseITCData(byte ITCList[],int Length)
{
  
  int ITCCount;
  int i,byteCount;
  char output[816];
  int temp;
  //cha
  
  ITCCount = (Length-3)/19;
  byteCount = 3;
  
  strncpy(output,"STATUS               Occ  VehSpd Volt   Temp EVID  AGE    Unique_ID --------------------------------------------------------------------",elcount(output));
  
  for(i=0;i<ITCCount;i++)
  {
   
    statusParser(ITCList[byteCount+1]);
    strncat(output,gstatusITC,elcount(output));
    convertAndSave(ITCList[byteCount+2],output,1);
    
    temp = (ITCList[byteCount+3] << 8) + ITCList[byteCount+4];
    convertAndSave(temp,output,4);
    
   // write("*****************%d %d %d",(ITCList[byteCount+5] << 8),ITCList[byteCount+6],temp);
    
    temp = (ITCList[byteCount+5] << 8) + ITCList[byteCount+6];
    //write("*****************%d %d %d",(ITCList[byteCount+5] << 8),ITCList[byteCount+6],temp);
    convertAndSave(temp,output,2);
    
    temp = (ITCList[byteCount+7] << 8) + ITCList[byteCount+8];
    convertAndSave(temp,output,3);
    
    temp = (ITCList[byteCount+9] << 8) + ITCList[byteCount+10];
    convertAndSave(temp,output,0);
    
    convertAndSave(ITCList[byteCount+11],output,99);
    convertAndSave(ITCList[byteCount+12],output,99);
    convertAndSave(ITCList[byteCount+13],output,99);
    convertAndSave(ITCList[byteCount+14],output,99);
    strncat(output," ",elcount(output));
    convertAndSave(ITCList[byteCount+15],output,99);
    convertAndSave(ITCList[byteCount+16],output,99);
    convertAndSave(ITCList[byteCount+17],output,99);
    convertAndSave(ITCList[byteCount+18],output,99);
    
    if(strlen(output)%68 != 0)
    {
      for(i = 0;i<(strlen(output)%68);i++)
      {
        strncat(output," ",elcount(output));
      }
    }
    byteCount+=19;
  
  }
  strncat(output,"\0",elcount(output));
  putValue(Env_ITC_Display,output);
  
}

On EnvVar EnvReadswversion
{
    
        if ( getValue ( this ) )
        {
            ClearDtcDisplay();
            StartDiagService( READ_Software_version );
        }

}

void statusParser(byte status)
{
  strncpy(gstatusITC,"",22);
  if(status == 0x11)
  {
    strncpy(gstatusITC,"FAILED_FIRST        ",22);
  }
  else if(status == 0x32)
  {
    strncpy(gstatusITC,"HEALED_AFTER_FAILED ",22);
  }
  else if(status == 0x31)
  {
    strncpy(gstatusITC,"FAILED_AFTER_HEALED ",22);
  }
  else
  {
    strncpy(gstatusITC,"NO_ITC              ",22);
  }
}

EvaluateEnvData()
{
  snprintf( StringAux,99,"Environment data:                ");
  strncpy( Stringbuffer, StringAux,255);

  switch( ( (word)RxDataBuffer[2] << 8 ) | (word)RxDataBuffer[3] )
  {
    default:
    {
    }
    break;
  }

  putValue( EnvEnvDataDisplay, Stringbuffer);

}

void GetSupplier(byte Code, char Supplier[])
{
   switch ( Code )
   {
	  case 0x03: 
	  	strncpy(Supplier,"Bosch",10);
	  break; 

      default:   
	  	strncpy(Supplier,"Error!!",10);
      break; 
   }
}

void convertAndSave(dword input,char output[],int unit)
{
  char temp[7];
  
  if(unit == 0)
  {
    ltoa(input,temp,10);
    strncat(output,temp,elcount(output));
    strncat(output," ",elcount(output));
  }
  else if(unit == 1)
  {
    ltoa(input,temp,10);
    strncat(output,temp,elcount(output));
    strncat(output,"(Occ) ",elcount(output));
  }
  else if(unit == 2)
  {
    ltoa(input,temp,10);
    strncat(output,temp,elcount(output));
    strncat(output,"mV ",elcount(output));
  }
  else if(unit == 3)
  {
    ltoa(input/10,temp,10);
    strncat(output,temp,elcount(output));
    strncat(output,"`C ",elcount(output));
  }
  else if(unit == 4)
  {
    ltoa(input,temp,10);
    strncat(output,temp,elcount(output));
    strncat(output,"m/s ",elcount(output));
  }
  else if(unit == 99)
  {
    ltoa(input,temp,16);
    if(strlen(temp) == 1)
    {
      strncat(output,"0",elcount(output));
      strncat(output,temp,elcount(output));
    } 
    else
    {
      strncat(output,temp,elcount(output));
    }
  }
  else
  {
      write("Error");
  }
}
*/

on busOff
{
   resetCan();
}


on sysvar_update sysvar::DIAG_TESTER::sysDataToTransmit_String
{
	dword i,length;
  dword 	SendBufferSize;
  char	MVbuffer[130000] = "";
  char	MVbuffer2[130000] = "0x"; 
  
  byte 	TransmitBuffer[65000];

  sysGetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_String, MVbuffer, elcount(MVbuffer));
  SendBufferSize = strlen(MVbuffer)+1;

  if( !strncmp(MVbuffer,"Idle",strlen(MVbuffer)) )
		{
			@sysvar::DIAG_TESTER::GeneralSettings::sysSendData=0;

		}
	else
		{
      strncpy(MVbuffer2, "0x",3);
			for(i=0; i<= SendBufferSize-3; i+=2)
				{
					MVbuffer2[2] = MVbuffer[i];
					MVbuffer2[3] = MVbuffer[i+1];
					MVbuffer2[4] = 0;
					TransmitBuffer[i/2] = atol( MVbuffer2 );
				}
			length = (SendBufferSize - 1)/2;
        
      sysSetVariableData(sysvar::DIAG_TESTER::sysDataToTransmit,TransmitBuffer,length);
        
      sysSetVariableString(sysvar::DIAG_TESTER::sysDataToTransmit_String,"Idle");
		}
}

