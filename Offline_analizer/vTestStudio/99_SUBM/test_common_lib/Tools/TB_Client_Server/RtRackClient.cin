/*@!Encoding:1252*/

/**
 * @copyright  (C) 2020-2020 Robert Bosch GmbH.\n
 * The reproduction, distribution and utilization of this file as well as
 * the communication of its contents to others without express authorization
 * is prohibited.\n
 * Offenders will be held liable for the payment of damages.\n
 * All rights reserved in the event of the grant of a patent, utility model or design.
 *
 * @file         RtRackClient.cin
 *                                            
 * @author       Manfred Rast (CC-DA/EAD2)
 * @date         08.09.2020
 * @version      0.2
 *
 * @brief Provide functions to execute commands on a remote server.
 *
 * @details TODO
 *
 */

variables
{
  //! Invalid socket for initialisation
  const dword INVALID_SOCKET = 0;
  
  //! Socket connection to the server on the lab PC
  dword rtc_ClientSocket;
    
  //! Buffer to receive data from the server on the lab PC
  char rtc_recvBuffer[1024];  
}

/**
 * Connect to the remote server specified by p_ServerIPAddress and p_ServerPort.
 *
 * @param[in] p_ServerIPAddress IP address of the lab PC where the Python Server is running
 * @param[in] p_ServerPort Port to communicate with the server on the lab PC
 *
 * @sideeffect write access to @ref rtc_ClientSocket
 */
void rtc_clientConnect(char p_ServerIPAddress[], dword p_ServerPort)
{
  dword result;
  long lastSocketError;

  rtc_ClientSocket = TcpOpen(0, 0);
  testWaitForTimeout(1000);  

  if (rtc_ClientSocket != INVALID_SOCKET)
  {
    result = TcpConnect(rtc_ClientSocket, IpGetAddressAsNumber(p_ServerIPAddress), p_ServerPort );
    testWaitForTimeout(1000);
    
    lastSocketError = IpGetLastSocketError(rtc_ClientSocket);
    
    if(10035 == lastSocketError)
    {
      testStepPass("RtRackClient", "TcpConnect successful to server %s on port %d", p_ServerIPAddress, p_ServerPort);
    }
    else
    {
      testStepFail("RtRackClient", "TcpConnect not successful to server %s on port %d", p_ServerIPAddress, p_ServerPort);
      testStepFail("RtRackClient", "TcpConnect: %d", result);
      testStepFail("RtRackClient", "IpGetLastSocketError(): %d", IpGetLastSocketError(rtc_ClientSocket));
    }
  }
  else
  {
    write("TcpOpen: FAILED");
    testStepFail("RtRackClient", "TcpOpen: FAILED");
  }
}

/**
 * Close the connection to the server.
 *
 * @sideeffect write access to @ref rtc_ClientSocket
 */
void rtc_clientCloseConnection()
{
  TcpClose(rtc_ClientSocket);
}

/**
 * Send data to the remote server.
 *
 * @param[in] p_ServerIPAddress IP address of the lab PC where the Python Server is running
 * @param[in] p_ServerPort Port to communicate with the server on the lab PC
 * @param[in] data  data to be send to the server
 */
export testfunction rtc_sendData(char p_ServerIPAddress[], dword p_ServerPort, char data[])
{
  long rc, lastSocketError;
  
  rtc_clientConnect(p_ServerIPAddress, p_ServerPort);
  
  rc = TcpSend(rtc_ClientSocket, data, elCount(data));
  testWaitForTimeout(1000);  

  if(0 == rc)
  {
    TestStepPass("RtRackClient", "Sending data successfull: %s", data);
    
    do
    {
      rc = rtc_recvData();
      testWaitForTimeout(1000);
    }
    while (997 == rc); // 997 = WSA_IO_PENDING, operation not completed
    
    TestStep("RtRackClient", "Received data from server: %s", rtc_recvBuffer);
  }
  else
  {
    lastSocketError = IpGetLastSocketError(rtc_ClientSocket);
    
    testStepFail("RtRackClient", "sendData(): TcpSend() returned: %d", rc);
    testStepFail("RtRackClient", "IpGetLastSocketError(): %d", lastSocketError);
  }
    
  rtc_clientCloseConnection();
}

/**
 * Receive data from the remote server.
 *
 * @sideeffect write access to @ref rtc_recvBuffer
 *
 * @return return code of IpGetLastSocketError(), called after TcpReceive()
 */
long rtc_recvData()
{
  long rc, lastSocketError;

  rc = TcpReceive(rtc_ClientSocket, rtc_recvBuffer, elCount(rtc_recvBuffer));
  testWaitForTimeout(1000);  

  lastSocketError = IpGetLastSocketError(rtc_ClientSocket);
  
  return lastSocketError;
}
